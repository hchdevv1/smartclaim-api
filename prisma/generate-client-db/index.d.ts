
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model accidentcauseover45days
 * 
 */
export type accidentcauseover45days = $Result.DefaultSelection<Prisma.$accidentcauseover45daysPayload>
/**
 * Model accidentplace
 * 
 */
export type accidentplace = $Result.DefaultSelection<Prisma.$accidentplacePayload>
/**
 * Model causeofinjuryside
 * 
 */
export type causeofinjuryside = $Result.DefaultSelection<Prisma.$causeofinjurysidePayload>
/**
 * Model causeofinjurywoundtype
 * 
 */
export type causeofinjurywoundtype = $Result.DefaultSelection<Prisma.$causeofinjurywoundtypePayload>
/**
 * Model claimants
 * 
 */
export type claimants = $Result.DefaultSelection<Prisma.$claimantsPayload>
/**
 * Model claimdocuments
 * 
 */
export type claimdocuments = $Result.DefaultSelection<Prisma.$claimdocumentsPayload>
/**
 * Model claimstatus
 * 
 */
export type claimstatus = $Result.DefaultSelection<Prisma.$claimstatusPayload>
/**
 * Model diagnosistypemapping
 * 
 */
export type diagnosistypemapping = $Result.DefaultSelection<Prisma.$diagnosistypemappingPayload>
/**
 * Model documenttype
 * 
 */
export type documenttype = $Result.DefaultSelection<Prisma.$documenttypePayload>
/**
 * Model illnesssurgery
 * 
 */
export type illnesssurgery = $Result.DefaultSelection<Prisma.$illnesssurgeryPayload>
/**
 * Model illnesstype
 * 
 */
export type illnesstype = $Result.DefaultSelection<Prisma.$illnesstypePayload>
/**
 * Model insurers
 * 
 */
export type insurers = $Result.DefaultSelection<Prisma.$insurersPayload>
/**
 * Model medicaltransactions
 * 
 */
export type medicaltransactions = $Result.DefaultSelection<Prisma.$medicaltransactionsPayload>
/**
 * Model policytype
 * 
 */
export type policytype = $Result.DefaultSelection<Prisma.$policytypePayload>
/**
 * Model servicesetting
 * 
 */
export type servicesetting = $Result.DefaultSelection<Prisma.$servicesettingPayload>
/**
 * Model transactionclaim
 * 
 */
export type transactionclaim = $Result.DefaultSelection<Prisma.$transactionclaimPayload>
/**
 * Model transactionclaimstatus
 * 
 */
export type transactionclaimstatus = $Result.DefaultSelection<Prisma.$transactionclaimstatusPayload>
/**
 * Model accidenttransactions
 * 
 */
export type accidenttransactions = $Result.DefaultSelection<Prisma.$accidenttransactionsPayload>
/**
 * Model proceduretransactions
 * 
 */
export type proceduretransactions = $Result.DefaultSelection<Prisma.$proceduretransactionsPayload>
/**
 * Model accidenttransactions22
 * 
 */
export type accidenttransactions22 = $Result.DefaultSelection<Prisma.$accidenttransactions22Payload>
/**
 * Model causeofinjurydetail
 * 
 */
export type causeofinjurydetail = $Result.DefaultSelection<Prisma.$causeofinjurydetailPayload>
/**
 * Model injurydetail
 * 
 */
export type injurydetail = $Result.DefaultSelection<Prisma.$injurydetailPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accidentcauseover45days
 * const accidentcauseover45days = await prisma.accidentcauseover45days.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accidentcauseover45days
   * const accidentcauseover45days = await prisma.accidentcauseover45days.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.accidentcauseover45days`: Exposes CRUD operations for the **accidentcauseover45days** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accidentcauseover45days
    * const accidentcauseover45days = await prisma.accidentcauseover45days.findMany()
    * ```
    */
  get accidentcauseover45days(): Prisma.accidentcauseover45daysDelegate<ExtArgs>;

  /**
   * `prisma.accidentplace`: Exposes CRUD operations for the **accidentplace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accidentplaces
    * const accidentplaces = await prisma.accidentplace.findMany()
    * ```
    */
  get accidentplace(): Prisma.accidentplaceDelegate<ExtArgs>;

  /**
   * `prisma.causeofinjuryside`: Exposes CRUD operations for the **causeofinjuryside** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Causeofinjurysides
    * const causeofinjurysides = await prisma.causeofinjuryside.findMany()
    * ```
    */
  get causeofinjuryside(): Prisma.causeofinjurysideDelegate<ExtArgs>;

  /**
   * `prisma.causeofinjurywoundtype`: Exposes CRUD operations for the **causeofinjurywoundtype** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Causeofinjurywoundtypes
    * const causeofinjurywoundtypes = await prisma.causeofinjurywoundtype.findMany()
    * ```
    */
  get causeofinjurywoundtype(): Prisma.causeofinjurywoundtypeDelegate<ExtArgs>;

  /**
   * `prisma.claimants`: Exposes CRUD operations for the **claimants** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Claimants
    * const claimants = await prisma.claimants.findMany()
    * ```
    */
  get claimants(): Prisma.claimantsDelegate<ExtArgs>;

  /**
   * `prisma.claimdocuments`: Exposes CRUD operations for the **claimdocuments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Claimdocuments
    * const claimdocuments = await prisma.claimdocuments.findMany()
    * ```
    */
  get claimdocuments(): Prisma.claimdocumentsDelegate<ExtArgs>;

  /**
   * `prisma.claimstatus`: Exposes CRUD operations for the **claimstatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Claimstatuses
    * const claimstatuses = await prisma.claimstatus.findMany()
    * ```
    */
  get claimstatus(): Prisma.claimstatusDelegate<ExtArgs>;

  /**
   * `prisma.diagnosistypemapping`: Exposes CRUD operations for the **diagnosistypemapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Diagnosistypemappings
    * const diagnosistypemappings = await prisma.diagnosistypemapping.findMany()
    * ```
    */
  get diagnosistypemapping(): Prisma.diagnosistypemappingDelegate<ExtArgs>;

  /**
   * `prisma.documenttype`: Exposes CRUD operations for the **documenttype** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documenttypes
    * const documenttypes = await prisma.documenttype.findMany()
    * ```
    */
  get documenttype(): Prisma.documenttypeDelegate<ExtArgs>;

  /**
   * `prisma.illnesssurgery`: Exposes CRUD operations for the **illnesssurgery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Illnesssurgeries
    * const illnesssurgeries = await prisma.illnesssurgery.findMany()
    * ```
    */
  get illnesssurgery(): Prisma.illnesssurgeryDelegate<ExtArgs>;

  /**
   * `prisma.illnesstype`: Exposes CRUD operations for the **illnesstype** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Illnesstypes
    * const illnesstypes = await prisma.illnesstype.findMany()
    * ```
    */
  get illnesstype(): Prisma.illnesstypeDelegate<ExtArgs>;

  /**
   * `prisma.insurers`: Exposes CRUD operations for the **insurers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Insurers
    * const insurers = await prisma.insurers.findMany()
    * ```
    */
  get insurers(): Prisma.insurersDelegate<ExtArgs>;

  /**
   * `prisma.medicaltransactions`: Exposes CRUD operations for the **medicaltransactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Medicaltransactions
    * const medicaltransactions = await prisma.medicaltransactions.findMany()
    * ```
    */
  get medicaltransactions(): Prisma.medicaltransactionsDelegate<ExtArgs>;

  /**
   * `prisma.policytype`: Exposes CRUD operations for the **policytype** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Policytypes
    * const policytypes = await prisma.policytype.findMany()
    * ```
    */
  get policytype(): Prisma.policytypeDelegate<ExtArgs>;

  /**
   * `prisma.servicesetting`: Exposes CRUD operations for the **servicesetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicesettings
    * const servicesettings = await prisma.servicesetting.findMany()
    * ```
    */
  get servicesetting(): Prisma.servicesettingDelegate<ExtArgs>;

  /**
   * `prisma.transactionclaim`: Exposes CRUD operations for the **transactionclaim** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactionclaims
    * const transactionclaims = await prisma.transactionclaim.findMany()
    * ```
    */
  get transactionclaim(): Prisma.transactionclaimDelegate<ExtArgs>;

  /**
   * `prisma.transactionclaimstatus`: Exposes CRUD operations for the **transactionclaimstatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactionclaimstatuses
    * const transactionclaimstatuses = await prisma.transactionclaimstatus.findMany()
    * ```
    */
  get transactionclaimstatus(): Prisma.transactionclaimstatusDelegate<ExtArgs>;

  /**
   * `prisma.accidenttransactions`: Exposes CRUD operations for the **accidenttransactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accidenttransactions
    * const accidenttransactions = await prisma.accidenttransactions.findMany()
    * ```
    */
  get accidenttransactions(): Prisma.accidenttransactionsDelegate<ExtArgs>;

  /**
   * `prisma.proceduretransactions`: Exposes CRUD operations for the **proceduretransactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Proceduretransactions
    * const proceduretransactions = await prisma.proceduretransactions.findMany()
    * ```
    */
  get proceduretransactions(): Prisma.proceduretransactionsDelegate<ExtArgs>;

  /**
   * `prisma.accidenttransactions22`: Exposes CRUD operations for the **accidenttransactions22** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accidenttransactions22s
    * const accidenttransactions22s = await prisma.accidenttransactions22.findMany()
    * ```
    */
  get accidenttransactions22(): Prisma.accidenttransactions22Delegate<ExtArgs>;

  /**
   * `prisma.causeofinjurydetail`: Exposes CRUD operations for the **causeofinjurydetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Causeofinjurydetails
    * const causeofinjurydetails = await prisma.causeofinjurydetail.findMany()
    * ```
    */
  get causeofinjurydetail(): Prisma.causeofinjurydetailDelegate<ExtArgs>;

  /**
   * `prisma.injurydetail`: Exposes CRUD operations for the **injurydetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Injurydetails
    * const injurydetails = await prisma.injurydetail.findMany()
    * ```
    */
  get injurydetail(): Prisma.injurydetailDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.20.0
   * Query Engine version: 06fc58a368dc7be9fbbbe894adf8d445d208c284
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    accidentcauseover45days: 'accidentcauseover45days',
    accidentplace: 'accidentplace',
    causeofinjuryside: 'causeofinjuryside',
    causeofinjurywoundtype: 'causeofinjurywoundtype',
    claimants: 'claimants',
    claimdocuments: 'claimdocuments',
    claimstatus: 'claimstatus',
    diagnosistypemapping: 'diagnosistypemapping',
    documenttype: 'documenttype',
    illnesssurgery: 'illnesssurgery',
    illnesstype: 'illnesstype',
    insurers: 'insurers',
    medicaltransactions: 'medicaltransactions',
    policytype: 'policytype',
    servicesetting: 'servicesetting',
    transactionclaim: 'transactionclaim',
    transactionclaimstatus: 'transactionclaimstatus',
    accidenttransactions: 'accidenttransactions',
    proceduretransactions: 'proceduretransactions',
    accidenttransactions22: 'accidenttransactions22',
    causeofinjurydetail: 'causeofinjurydetail',
    injurydetail: 'injurydetail'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "accidentcauseover45days" | "accidentplace" | "causeofinjuryside" | "causeofinjurywoundtype" | "claimants" | "claimdocuments" | "claimstatus" | "diagnosistypemapping" | "documenttype" | "illnesssurgery" | "illnesstype" | "insurers" | "medicaltransactions" | "policytype" | "servicesetting" | "transactionclaim" | "transactionclaimstatus" | "accidenttransactions" | "proceduretransactions" | "accidenttransactions22" | "causeofinjurydetail" | "injurydetail"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      accidentcauseover45days: {
        payload: Prisma.$accidentcauseover45daysPayload<ExtArgs>
        fields: Prisma.accidentcauseover45daysFieldRefs
        operations: {
          findUnique: {
            args: Prisma.accidentcauseover45daysFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidentcauseover45daysPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.accidentcauseover45daysFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidentcauseover45daysPayload>
          }
          findFirst: {
            args: Prisma.accidentcauseover45daysFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidentcauseover45daysPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.accidentcauseover45daysFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidentcauseover45daysPayload>
          }
          findMany: {
            args: Prisma.accidentcauseover45daysFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidentcauseover45daysPayload>[]
          }
          create: {
            args: Prisma.accidentcauseover45daysCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidentcauseover45daysPayload>
          }
          createMany: {
            args: Prisma.accidentcauseover45daysCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.accidentcauseover45daysCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidentcauseover45daysPayload>[]
          }
          delete: {
            args: Prisma.accidentcauseover45daysDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidentcauseover45daysPayload>
          }
          update: {
            args: Prisma.accidentcauseover45daysUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidentcauseover45daysPayload>
          }
          deleteMany: {
            args: Prisma.accidentcauseover45daysDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.accidentcauseover45daysUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.accidentcauseover45daysUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidentcauseover45daysPayload>
          }
          aggregate: {
            args: Prisma.Accidentcauseover45daysAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccidentcauseover45days>
          }
          groupBy: {
            args: Prisma.accidentcauseover45daysGroupByArgs<ExtArgs>
            result: $Utils.Optional<Accidentcauseover45daysGroupByOutputType>[]
          }
          count: {
            args: Prisma.accidentcauseover45daysCountArgs<ExtArgs>
            result: $Utils.Optional<Accidentcauseover45daysCountAggregateOutputType> | number
          }
        }
      }
      accidentplace: {
        payload: Prisma.$accidentplacePayload<ExtArgs>
        fields: Prisma.accidentplaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.accidentplaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidentplacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.accidentplaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidentplacePayload>
          }
          findFirst: {
            args: Prisma.accidentplaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidentplacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.accidentplaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidentplacePayload>
          }
          findMany: {
            args: Prisma.accidentplaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidentplacePayload>[]
          }
          create: {
            args: Prisma.accidentplaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidentplacePayload>
          }
          createMany: {
            args: Prisma.accidentplaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.accidentplaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidentplacePayload>[]
          }
          delete: {
            args: Prisma.accidentplaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidentplacePayload>
          }
          update: {
            args: Prisma.accidentplaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidentplacePayload>
          }
          deleteMany: {
            args: Prisma.accidentplaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.accidentplaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.accidentplaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidentplacePayload>
          }
          aggregate: {
            args: Prisma.AccidentplaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccidentplace>
          }
          groupBy: {
            args: Prisma.accidentplaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccidentplaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.accidentplaceCountArgs<ExtArgs>
            result: $Utils.Optional<AccidentplaceCountAggregateOutputType> | number
          }
        }
      }
      causeofinjuryside: {
        payload: Prisma.$causeofinjurysidePayload<ExtArgs>
        fields: Prisma.causeofinjurysideFieldRefs
        operations: {
          findUnique: {
            args: Prisma.causeofinjurysideFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$causeofinjurysidePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.causeofinjurysideFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$causeofinjurysidePayload>
          }
          findFirst: {
            args: Prisma.causeofinjurysideFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$causeofinjurysidePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.causeofinjurysideFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$causeofinjurysidePayload>
          }
          findMany: {
            args: Prisma.causeofinjurysideFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$causeofinjurysidePayload>[]
          }
          create: {
            args: Prisma.causeofinjurysideCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$causeofinjurysidePayload>
          }
          createMany: {
            args: Prisma.causeofinjurysideCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.causeofinjurysideCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$causeofinjurysidePayload>[]
          }
          delete: {
            args: Prisma.causeofinjurysideDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$causeofinjurysidePayload>
          }
          update: {
            args: Prisma.causeofinjurysideUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$causeofinjurysidePayload>
          }
          deleteMany: {
            args: Prisma.causeofinjurysideDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.causeofinjurysideUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.causeofinjurysideUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$causeofinjurysidePayload>
          }
          aggregate: {
            args: Prisma.CauseofinjurysideAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCauseofinjuryside>
          }
          groupBy: {
            args: Prisma.causeofinjurysideGroupByArgs<ExtArgs>
            result: $Utils.Optional<CauseofinjurysideGroupByOutputType>[]
          }
          count: {
            args: Prisma.causeofinjurysideCountArgs<ExtArgs>
            result: $Utils.Optional<CauseofinjurysideCountAggregateOutputType> | number
          }
        }
      }
      causeofinjurywoundtype: {
        payload: Prisma.$causeofinjurywoundtypePayload<ExtArgs>
        fields: Prisma.causeofinjurywoundtypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.causeofinjurywoundtypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$causeofinjurywoundtypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.causeofinjurywoundtypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$causeofinjurywoundtypePayload>
          }
          findFirst: {
            args: Prisma.causeofinjurywoundtypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$causeofinjurywoundtypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.causeofinjurywoundtypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$causeofinjurywoundtypePayload>
          }
          findMany: {
            args: Prisma.causeofinjurywoundtypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$causeofinjurywoundtypePayload>[]
          }
          create: {
            args: Prisma.causeofinjurywoundtypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$causeofinjurywoundtypePayload>
          }
          createMany: {
            args: Prisma.causeofinjurywoundtypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.causeofinjurywoundtypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$causeofinjurywoundtypePayload>[]
          }
          delete: {
            args: Prisma.causeofinjurywoundtypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$causeofinjurywoundtypePayload>
          }
          update: {
            args: Prisma.causeofinjurywoundtypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$causeofinjurywoundtypePayload>
          }
          deleteMany: {
            args: Prisma.causeofinjurywoundtypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.causeofinjurywoundtypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.causeofinjurywoundtypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$causeofinjurywoundtypePayload>
          }
          aggregate: {
            args: Prisma.CauseofinjurywoundtypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCauseofinjurywoundtype>
          }
          groupBy: {
            args: Prisma.causeofinjurywoundtypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CauseofinjurywoundtypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.causeofinjurywoundtypeCountArgs<ExtArgs>
            result: $Utils.Optional<CauseofinjurywoundtypeCountAggregateOutputType> | number
          }
        }
      }
      claimants: {
        payload: Prisma.$claimantsPayload<ExtArgs>
        fields: Prisma.claimantsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.claimantsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$claimantsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.claimantsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$claimantsPayload>
          }
          findFirst: {
            args: Prisma.claimantsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$claimantsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.claimantsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$claimantsPayload>
          }
          findMany: {
            args: Prisma.claimantsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$claimantsPayload>[]
          }
          create: {
            args: Prisma.claimantsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$claimantsPayload>
          }
          createMany: {
            args: Prisma.claimantsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.claimantsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$claimantsPayload>[]
          }
          delete: {
            args: Prisma.claimantsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$claimantsPayload>
          }
          update: {
            args: Prisma.claimantsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$claimantsPayload>
          }
          deleteMany: {
            args: Prisma.claimantsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.claimantsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.claimantsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$claimantsPayload>
          }
          aggregate: {
            args: Prisma.ClaimantsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClaimants>
          }
          groupBy: {
            args: Prisma.claimantsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClaimantsGroupByOutputType>[]
          }
          count: {
            args: Prisma.claimantsCountArgs<ExtArgs>
            result: $Utils.Optional<ClaimantsCountAggregateOutputType> | number
          }
        }
      }
      claimdocuments: {
        payload: Prisma.$claimdocumentsPayload<ExtArgs>
        fields: Prisma.claimdocumentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.claimdocumentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$claimdocumentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.claimdocumentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$claimdocumentsPayload>
          }
          findFirst: {
            args: Prisma.claimdocumentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$claimdocumentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.claimdocumentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$claimdocumentsPayload>
          }
          findMany: {
            args: Prisma.claimdocumentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$claimdocumentsPayload>[]
          }
          create: {
            args: Prisma.claimdocumentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$claimdocumentsPayload>
          }
          createMany: {
            args: Prisma.claimdocumentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.claimdocumentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$claimdocumentsPayload>[]
          }
          delete: {
            args: Prisma.claimdocumentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$claimdocumentsPayload>
          }
          update: {
            args: Prisma.claimdocumentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$claimdocumentsPayload>
          }
          deleteMany: {
            args: Prisma.claimdocumentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.claimdocumentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.claimdocumentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$claimdocumentsPayload>
          }
          aggregate: {
            args: Prisma.ClaimdocumentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClaimdocuments>
          }
          groupBy: {
            args: Prisma.claimdocumentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClaimdocumentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.claimdocumentsCountArgs<ExtArgs>
            result: $Utils.Optional<ClaimdocumentsCountAggregateOutputType> | number
          }
        }
      }
      claimstatus: {
        payload: Prisma.$claimstatusPayload<ExtArgs>
        fields: Prisma.claimstatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.claimstatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$claimstatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.claimstatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$claimstatusPayload>
          }
          findFirst: {
            args: Prisma.claimstatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$claimstatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.claimstatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$claimstatusPayload>
          }
          findMany: {
            args: Prisma.claimstatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$claimstatusPayload>[]
          }
          create: {
            args: Prisma.claimstatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$claimstatusPayload>
          }
          createMany: {
            args: Prisma.claimstatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.claimstatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$claimstatusPayload>[]
          }
          delete: {
            args: Prisma.claimstatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$claimstatusPayload>
          }
          update: {
            args: Prisma.claimstatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$claimstatusPayload>
          }
          deleteMany: {
            args: Prisma.claimstatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.claimstatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.claimstatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$claimstatusPayload>
          }
          aggregate: {
            args: Prisma.ClaimstatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClaimstatus>
          }
          groupBy: {
            args: Prisma.claimstatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClaimstatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.claimstatusCountArgs<ExtArgs>
            result: $Utils.Optional<ClaimstatusCountAggregateOutputType> | number
          }
        }
      }
      diagnosistypemapping: {
        payload: Prisma.$diagnosistypemappingPayload<ExtArgs>
        fields: Prisma.diagnosistypemappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.diagnosistypemappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnosistypemappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.diagnosistypemappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnosistypemappingPayload>
          }
          findFirst: {
            args: Prisma.diagnosistypemappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnosistypemappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.diagnosistypemappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnosistypemappingPayload>
          }
          findMany: {
            args: Prisma.diagnosistypemappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnosistypemappingPayload>[]
          }
          create: {
            args: Prisma.diagnosistypemappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnosistypemappingPayload>
          }
          createMany: {
            args: Prisma.diagnosistypemappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.diagnosistypemappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnosistypemappingPayload>[]
          }
          delete: {
            args: Prisma.diagnosistypemappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnosistypemappingPayload>
          }
          update: {
            args: Prisma.diagnosistypemappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnosistypemappingPayload>
          }
          deleteMany: {
            args: Prisma.diagnosistypemappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.diagnosistypemappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.diagnosistypemappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnosistypemappingPayload>
          }
          aggregate: {
            args: Prisma.DiagnosistypemappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiagnosistypemapping>
          }
          groupBy: {
            args: Prisma.diagnosistypemappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiagnosistypemappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.diagnosistypemappingCountArgs<ExtArgs>
            result: $Utils.Optional<DiagnosistypemappingCountAggregateOutputType> | number
          }
        }
      }
      documenttype: {
        payload: Prisma.$documenttypePayload<ExtArgs>
        fields: Prisma.documenttypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.documenttypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documenttypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.documenttypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documenttypePayload>
          }
          findFirst: {
            args: Prisma.documenttypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documenttypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.documenttypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documenttypePayload>
          }
          findMany: {
            args: Prisma.documenttypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documenttypePayload>[]
          }
          create: {
            args: Prisma.documenttypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documenttypePayload>
          }
          createMany: {
            args: Prisma.documenttypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.documenttypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documenttypePayload>[]
          }
          delete: {
            args: Prisma.documenttypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documenttypePayload>
          }
          update: {
            args: Prisma.documenttypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documenttypePayload>
          }
          deleteMany: {
            args: Prisma.documenttypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.documenttypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.documenttypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documenttypePayload>
          }
          aggregate: {
            args: Prisma.DocumenttypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumenttype>
          }
          groupBy: {
            args: Prisma.documenttypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumenttypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.documenttypeCountArgs<ExtArgs>
            result: $Utils.Optional<DocumenttypeCountAggregateOutputType> | number
          }
        }
      }
      illnesssurgery: {
        payload: Prisma.$illnesssurgeryPayload<ExtArgs>
        fields: Prisma.illnesssurgeryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.illnesssurgeryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$illnesssurgeryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.illnesssurgeryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$illnesssurgeryPayload>
          }
          findFirst: {
            args: Prisma.illnesssurgeryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$illnesssurgeryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.illnesssurgeryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$illnesssurgeryPayload>
          }
          findMany: {
            args: Prisma.illnesssurgeryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$illnesssurgeryPayload>[]
          }
          create: {
            args: Prisma.illnesssurgeryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$illnesssurgeryPayload>
          }
          createMany: {
            args: Prisma.illnesssurgeryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.illnesssurgeryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$illnesssurgeryPayload>[]
          }
          delete: {
            args: Prisma.illnesssurgeryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$illnesssurgeryPayload>
          }
          update: {
            args: Prisma.illnesssurgeryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$illnesssurgeryPayload>
          }
          deleteMany: {
            args: Prisma.illnesssurgeryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.illnesssurgeryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.illnesssurgeryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$illnesssurgeryPayload>
          }
          aggregate: {
            args: Prisma.IllnesssurgeryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIllnesssurgery>
          }
          groupBy: {
            args: Prisma.illnesssurgeryGroupByArgs<ExtArgs>
            result: $Utils.Optional<IllnesssurgeryGroupByOutputType>[]
          }
          count: {
            args: Prisma.illnesssurgeryCountArgs<ExtArgs>
            result: $Utils.Optional<IllnesssurgeryCountAggregateOutputType> | number
          }
        }
      }
      illnesstype: {
        payload: Prisma.$illnesstypePayload<ExtArgs>
        fields: Prisma.illnesstypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.illnesstypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$illnesstypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.illnesstypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$illnesstypePayload>
          }
          findFirst: {
            args: Prisma.illnesstypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$illnesstypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.illnesstypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$illnesstypePayload>
          }
          findMany: {
            args: Prisma.illnesstypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$illnesstypePayload>[]
          }
          create: {
            args: Prisma.illnesstypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$illnesstypePayload>
          }
          createMany: {
            args: Prisma.illnesstypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.illnesstypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$illnesstypePayload>[]
          }
          delete: {
            args: Prisma.illnesstypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$illnesstypePayload>
          }
          update: {
            args: Prisma.illnesstypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$illnesstypePayload>
          }
          deleteMany: {
            args: Prisma.illnesstypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.illnesstypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.illnesstypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$illnesstypePayload>
          }
          aggregate: {
            args: Prisma.IllnesstypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIllnesstype>
          }
          groupBy: {
            args: Prisma.illnesstypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<IllnesstypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.illnesstypeCountArgs<ExtArgs>
            result: $Utils.Optional<IllnesstypeCountAggregateOutputType> | number
          }
        }
      }
      insurers: {
        payload: Prisma.$insurersPayload<ExtArgs>
        fields: Prisma.insurersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.insurersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$insurersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.insurersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$insurersPayload>
          }
          findFirst: {
            args: Prisma.insurersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$insurersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.insurersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$insurersPayload>
          }
          findMany: {
            args: Prisma.insurersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$insurersPayload>[]
          }
          create: {
            args: Prisma.insurersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$insurersPayload>
          }
          createMany: {
            args: Prisma.insurersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.insurersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$insurersPayload>[]
          }
          delete: {
            args: Prisma.insurersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$insurersPayload>
          }
          update: {
            args: Prisma.insurersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$insurersPayload>
          }
          deleteMany: {
            args: Prisma.insurersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.insurersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.insurersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$insurersPayload>
          }
          aggregate: {
            args: Prisma.InsurersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInsurers>
          }
          groupBy: {
            args: Prisma.insurersGroupByArgs<ExtArgs>
            result: $Utils.Optional<InsurersGroupByOutputType>[]
          }
          count: {
            args: Prisma.insurersCountArgs<ExtArgs>
            result: $Utils.Optional<InsurersCountAggregateOutputType> | number
          }
        }
      }
      medicaltransactions: {
        payload: Prisma.$medicaltransactionsPayload<ExtArgs>
        fields: Prisma.medicaltransactionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.medicaltransactionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicaltransactionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.medicaltransactionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicaltransactionsPayload>
          }
          findFirst: {
            args: Prisma.medicaltransactionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicaltransactionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.medicaltransactionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicaltransactionsPayload>
          }
          findMany: {
            args: Prisma.medicaltransactionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicaltransactionsPayload>[]
          }
          create: {
            args: Prisma.medicaltransactionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicaltransactionsPayload>
          }
          createMany: {
            args: Prisma.medicaltransactionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.medicaltransactionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicaltransactionsPayload>[]
          }
          delete: {
            args: Prisma.medicaltransactionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicaltransactionsPayload>
          }
          update: {
            args: Prisma.medicaltransactionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicaltransactionsPayload>
          }
          deleteMany: {
            args: Prisma.medicaltransactionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.medicaltransactionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.medicaltransactionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicaltransactionsPayload>
          }
          aggregate: {
            args: Prisma.MedicaltransactionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicaltransactions>
          }
          groupBy: {
            args: Prisma.medicaltransactionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicaltransactionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.medicaltransactionsCountArgs<ExtArgs>
            result: $Utils.Optional<MedicaltransactionsCountAggregateOutputType> | number
          }
        }
      }
      policytype: {
        payload: Prisma.$policytypePayload<ExtArgs>
        fields: Prisma.policytypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.policytypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$policytypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.policytypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$policytypePayload>
          }
          findFirst: {
            args: Prisma.policytypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$policytypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.policytypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$policytypePayload>
          }
          findMany: {
            args: Prisma.policytypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$policytypePayload>[]
          }
          create: {
            args: Prisma.policytypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$policytypePayload>
          }
          createMany: {
            args: Prisma.policytypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.policytypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$policytypePayload>[]
          }
          delete: {
            args: Prisma.policytypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$policytypePayload>
          }
          update: {
            args: Prisma.policytypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$policytypePayload>
          }
          deleteMany: {
            args: Prisma.policytypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.policytypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.policytypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$policytypePayload>
          }
          aggregate: {
            args: Prisma.PolicytypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePolicytype>
          }
          groupBy: {
            args: Prisma.policytypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PolicytypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.policytypeCountArgs<ExtArgs>
            result: $Utils.Optional<PolicytypeCountAggregateOutputType> | number
          }
        }
      }
      servicesetting: {
        payload: Prisma.$servicesettingPayload<ExtArgs>
        fields: Prisma.servicesettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.servicesettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicesettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.servicesettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicesettingPayload>
          }
          findFirst: {
            args: Prisma.servicesettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicesettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.servicesettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicesettingPayload>
          }
          findMany: {
            args: Prisma.servicesettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicesettingPayload>[]
          }
          create: {
            args: Prisma.servicesettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicesettingPayload>
          }
          createMany: {
            args: Prisma.servicesettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.servicesettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicesettingPayload>[]
          }
          delete: {
            args: Prisma.servicesettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicesettingPayload>
          }
          update: {
            args: Prisma.servicesettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicesettingPayload>
          }
          deleteMany: {
            args: Prisma.servicesettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.servicesettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.servicesettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicesettingPayload>
          }
          aggregate: {
            args: Prisma.ServicesettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServicesetting>
          }
          groupBy: {
            args: Prisma.servicesettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicesettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.servicesettingCountArgs<ExtArgs>
            result: $Utils.Optional<ServicesettingCountAggregateOutputType> | number
          }
        }
      }
      transactionclaim: {
        payload: Prisma.$transactionclaimPayload<ExtArgs>
        fields: Prisma.transactionclaimFieldRefs
        operations: {
          findUnique: {
            args: Prisma.transactionclaimFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionclaimPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.transactionclaimFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionclaimPayload>
          }
          findFirst: {
            args: Prisma.transactionclaimFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionclaimPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.transactionclaimFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionclaimPayload>
          }
          findMany: {
            args: Prisma.transactionclaimFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionclaimPayload>[]
          }
          create: {
            args: Prisma.transactionclaimCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionclaimPayload>
          }
          createMany: {
            args: Prisma.transactionclaimCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.transactionclaimCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionclaimPayload>[]
          }
          delete: {
            args: Prisma.transactionclaimDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionclaimPayload>
          }
          update: {
            args: Prisma.transactionclaimUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionclaimPayload>
          }
          deleteMany: {
            args: Prisma.transactionclaimDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.transactionclaimUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.transactionclaimUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionclaimPayload>
          }
          aggregate: {
            args: Prisma.TransactionclaimAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactionclaim>
          }
          groupBy: {
            args: Prisma.transactionclaimGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionclaimGroupByOutputType>[]
          }
          count: {
            args: Prisma.transactionclaimCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionclaimCountAggregateOutputType> | number
          }
        }
      }
      transactionclaimstatus: {
        payload: Prisma.$transactionclaimstatusPayload<ExtArgs>
        fields: Prisma.transactionclaimstatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.transactionclaimstatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionclaimstatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.transactionclaimstatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionclaimstatusPayload>
          }
          findFirst: {
            args: Prisma.transactionclaimstatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionclaimstatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.transactionclaimstatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionclaimstatusPayload>
          }
          findMany: {
            args: Prisma.transactionclaimstatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionclaimstatusPayload>[]
          }
          create: {
            args: Prisma.transactionclaimstatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionclaimstatusPayload>
          }
          createMany: {
            args: Prisma.transactionclaimstatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.transactionclaimstatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionclaimstatusPayload>[]
          }
          delete: {
            args: Prisma.transactionclaimstatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionclaimstatusPayload>
          }
          update: {
            args: Prisma.transactionclaimstatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionclaimstatusPayload>
          }
          deleteMany: {
            args: Prisma.transactionclaimstatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.transactionclaimstatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.transactionclaimstatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionclaimstatusPayload>
          }
          aggregate: {
            args: Prisma.TransactionclaimstatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactionclaimstatus>
          }
          groupBy: {
            args: Prisma.transactionclaimstatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionclaimstatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.transactionclaimstatusCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionclaimstatusCountAggregateOutputType> | number
          }
        }
      }
      accidenttransactions: {
        payload: Prisma.$accidenttransactionsPayload<ExtArgs>
        fields: Prisma.accidenttransactionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.accidenttransactionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidenttransactionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.accidenttransactionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidenttransactionsPayload>
          }
          findFirst: {
            args: Prisma.accidenttransactionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidenttransactionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.accidenttransactionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidenttransactionsPayload>
          }
          findMany: {
            args: Prisma.accidenttransactionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidenttransactionsPayload>[]
          }
          create: {
            args: Prisma.accidenttransactionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidenttransactionsPayload>
          }
          createMany: {
            args: Prisma.accidenttransactionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.accidenttransactionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidenttransactionsPayload>[]
          }
          delete: {
            args: Prisma.accidenttransactionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidenttransactionsPayload>
          }
          update: {
            args: Prisma.accidenttransactionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidenttransactionsPayload>
          }
          deleteMany: {
            args: Prisma.accidenttransactionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.accidenttransactionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.accidenttransactionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidenttransactionsPayload>
          }
          aggregate: {
            args: Prisma.AccidenttransactionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccidenttransactions>
          }
          groupBy: {
            args: Prisma.accidenttransactionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccidenttransactionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.accidenttransactionsCountArgs<ExtArgs>
            result: $Utils.Optional<AccidenttransactionsCountAggregateOutputType> | number
          }
        }
      }
      proceduretransactions: {
        payload: Prisma.$proceduretransactionsPayload<ExtArgs>
        fields: Prisma.proceduretransactionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.proceduretransactionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proceduretransactionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.proceduretransactionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proceduretransactionsPayload>
          }
          findFirst: {
            args: Prisma.proceduretransactionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proceduretransactionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.proceduretransactionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proceduretransactionsPayload>
          }
          findMany: {
            args: Prisma.proceduretransactionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proceduretransactionsPayload>[]
          }
          create: {
            args: Prisma.proceduretransactionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proceduretransactionsPayload>
          }
          createMany: {
            args: Prisma.proceduretransactionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.proceduretransactionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proceduretransactionsPayload>[]
          }
          delete: {
            args: Prisma.proceduretransactionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proceduretransactionsPayload>
          }
          update: {
            args: Prisma.proceduretransactionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proceduretransactionsPayload>
          }
          deleteMany: {
            args: Prisma.proceduretransactionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.proceduretransactionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.proceduretransactionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proceduretransactionsPayload>
          }
          aggregate: {
            args: Prisma.ProceduretransactionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProceduretransactions>
          }
          groupBy: {
            args: Prisma.proceduretransactionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProceduretransactionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.proceduretransactionsCountArgs<ExtArgs>
            result: $Utils.Optional<ProceduretransactionsCountAggregateOutputType> | number
          }
        }
      }
      accidenttransactions22: {
        payload: Prisma.$accidenttransactions22Payload<ExtArgs>
        fields: Prisma.accidenttransactions22FieldRefs
        operations: {
          findUnique: {
            args: Prisma.accidenttransactions22FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidenttransactions22Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.accidenttransactions22FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidenttransactions22Payload>
          }
          findFirst: {
            args: Prisma.accidenttransactions22FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidenttransactions22Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.accidenttransactions22FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidenttransactions22Payload>
          }
          findMany: {
            args: Prisma.accidenttransactions22FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidenttransactions22Payload>[]
          }
          create: {
            args: Prisma.accidenttransactions22CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidenttransactions22Payload>
          }
          createMany: {
            args: Prisma.accidenttransactions22CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.accidenttransactions22CreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidenttransactions22Payload>[]
          }
          delete: {
            args: Prisma.accidenttransactions22DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidenttransactions22Payload>
          }
          update: {
            args: Prisma.accidenttransactions22UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidenttransactions22Payload>
          }
          deleteMany: {
            args: Prisma.accidenttransactions22DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.accidenttransactions22UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.accidenttransactions22UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accidenttransactions22Payload>
          }
          aggregate: {
            args: Prisma.Accidenttransactions22AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccidenttransactions22>
          }
          groupBy: {
            args: Prisma.accidenttransactions22GroupByArgs<ExtArgs>
            result: $Utils.Optional<Accidenttransactions22GroupByOutputType>[]
          }
          count: {
            args: Prisma.accidenttransactions22CountArgs<ExtArgs>
            result: $Utils.Optional<Accidenttransactions22CountAggregateOutputType> | number
          }
        }
      }
      causeofinjurydetail: {
        payload: Prisma.$causeofinjurydetailPayload<ExtArgs>
        fields: Prisma.causeofinjurydetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.causeofinjurydetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$causeofinjurydetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.causeofinjurydetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$causeofinjurydetailPayload>
          }
          findFirst: {
            args: Prisma.causeofinjurydetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$causeofinjurydetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.causeofinjurydetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$causeofinjurydetailPayload>
          }
          findMany: {
            args: Prisma.causeofinjurydetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$causeofinjurydetailPayload>[]
          }
          create: {
            args: Prisma.causeofinjurydetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$causeofinjurydetailPayload>
          }
          createMany: {
            args: Prisma.causeofinjurydetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.causeofinjurydetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$causeofinjurydetailPayload>[]
          }
          delete: {
            args: Prisma.causeofinjurydetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$causeofinjurydetailPayload>
          }
          update: {
            args: Prisma.causeofinjurydetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$causeofinjurydetailPayload>
          }
          deleteMany: {
            args: Prisma.causeofinjurydetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.causeofinjurydetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.causeofinjurydetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$causeofinjurydetailPayload>
          }
          aggregate: {
            args: Prisma.CauseofinjurydetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCauseofinjurydetail>
          }
          groupBy: {
            args: Prisma.causeofinjurydetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<CauseofinjurydetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.causeofinjurydetailCountArgs<ExtArgs>
            result: $Utils.Optional<CauseofinjurydetailCountAggregateOutputType> | number
          }
        }
      }
      injurydetail: {
        payload: Prisma.$injurydetailPayload<ExtArgs>
        fields: Prisma.injurydetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.injurydetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$injurydetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.injurydetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$injurydetailPayload>
          }
          findFirst: {
            args: Prisma.injurydetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$injurydetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.injurydetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$injurydetailPayload>
          }
          findMany: {
            args: Prisma.injurydetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$injurydetailPayload>[]
          }
          create: {
            args: Prisma.injurydetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$injurydetailPayload>
          }
          createMany: {
            args: Prisma.injurydetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.injurydetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$injurydetailPayload>[]
          }
          delete: {
            args: Prisma.injurydetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$injurydetailPayload>
          }
          update: {
            args: Prisma.injurydetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$injurydetailPayload>
          }
          deleteMany: {
            args: Prisma.injurydetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.injurydetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.injurydetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$injurydetailPayload>
          }
          aggregate: {
            args: Prisma.InjurydetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInjurydetail>
          }
          groupBy: {
            args: Prisma.injurydetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<InjurydetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.injurydetailCountArgs<ExtArgs>
            result: $Utils.Optional<InjurydetailCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ClaimstatusCountOutputType
   */

  export type ClaimstatusCountOutputType = {
    transactionclaimstatus: number
  }

  export type ClaimstatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactionclaimstatus?: boolean | ClaimstatusCountOutputTypeCountTransactionclaimstatusArgs
  }

  // Custom InputTypes
  /**
   * ClaimstatusCountOutputType without action
   */
  export type ClaimstatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimstatusCountOutputType
     */
    select?: ClaimstatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClaimstatusCountOutputType without action
   */
  export type ClaimstatusCountOutputTypeCountTransactionclaimstatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionclaimstatusWhereInput
  }


  /**
   * Count Type InsurersCountOutputType
   */

  export type InsurersCountOutputType = {
    accidentcauseover45days: number
    accidentplace: number
    accidenttransactions: number
    accidenttransactions22: number
    causeofinjuryside: number
    causeofinjurywoundtype: number
    claimants: number
    claimdocuments: number
    claimstatus: number
    diagnosistypemapping: number
    documenttype: number
    illnesssurgery: number
    illnesstype: number
    policytype: number
    proceduretransactions: number
    servicesetting: number
  }

  export type InsurersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accidentcauseover45days?: boolean | InsurersCountOutputTypeCountAccidentcauseover45daysArgs
    accidentplace?: boolean | InsurersCountOutputTypeCountAccidentplaceArgs
    accidenttransactions?: boolean | InsurersCountOutputTypeCountAccidenttransactionsArgs
    accidenttransactions22?: boolean | InsurersCountOutputTypeCountAccidenttransactions22Args
    causeofinjuryside?: boolean | InsurersCountOutputTypeCountCauseofinjurysideArgs
    causeofinjurywoundtype?: boolean | InsurersCountOutputTypeCountCauseofinjurywoundtypeArgs
    claimants?: boolean | InsurersCountOutputTypeCountClaimantsArgs
    claimdocuments?: boolean | InsurersCountOutputTypeCountClaimdocumentsArgs
    claimstatus?: boolean | InsurersCountOutputTypeCountClaimstatusArgs
    diagnosistypemapping?: boolean | InsurersCountOutputTypeCountDiagnosistypemappingArgs
    documenttype?: boolean | InsurersCountOutputTypeCountDocumenttypeArgs
    illnesssurgery?: boolean | InsurersCountOutputTypeCountIllnesssurgeryArgs
    illnesstype?: boolean | InsurersCountOutputTypeCountIllnesstypeArgs
    policytype?: boolean | InsurersCountOutputTypeCountPolicytypeArgs
    proceduretransactions?: boolean | InsurersCountOutputTypeCountProceduretransactionsArgs
    servicesetting?: boolean | InsurersCountOutputTypeCountServicesettingArgs
  }

  // Custom InputTypes
  /**
   * InsurersCountOutputType without action
   */
  export type InsurersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurersCountOutputType
     */
    select?: InsurersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InsurersCountOutputType without action
   */
  export type InsurersCountOutputTypeCountAccidentcauseover45daysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: accidentcauseover45daysWhereInput
  }

  /**
   * InsurersCountOutputType without action
   */
  export type InsurersCountOutputTypeCountAccidentplaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: accidentplaceWhereInput
  }

  /**
   * InsurersCountOutputType without action
   */
  export type InsurersCountOutputTypeCountAccidenttransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: accidenttransactionsWhereInput
  }

  /**
   * InsurersCountOutputType without action
   */
  export type InsurersCountOutputTypeCountAccidenttransactions22Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: accidenttransactions22WhereInput
  }

  /**
   * InsurersCountOutputType without action
   */
  export type InsurersCountOutputTypeCountCauseofinjurysideArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: causeofinjurysideWhereInput
  }

  /**
   * InsurersCountOutputType without action
   */
  export type InsurersCountOutputTypeCountCauseofinjurywoundtypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: causeofinjurywoundtypeWhereInput
  }

  /**
   * InsurersCountOutputType without action
   */
  export type InsurersCountOutputTypeCountClaimantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: claimantsWhereInput
  }

  /**
   * InsurersCountOutputType without action
   */
  export type InsurersCountOutputTypeCountClaimdocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: claimdocumentsWhereInput
  }

  /**
   * InsurersCountOutputType without action
   */
  export type InsurersCountOutputTypeCountClaimstatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: claimstatusWhereInput
  }

  /**
   * InsurersCountOutputType without action
   */
  export type InsurersCountOutputTypeCountDiagnosistypemappingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: diagnosistypemappingWhereInput
  }

  /**
   * InsurersCountOutputType without action
   */
  export type InsurersCountOutputTypeCountDocumenttypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: documenttypeWhereInput
  }

  /**
   * InsurersCountOutputType without action
   */
  export type InsurersCountOutputTypeCountIllnesssurgeryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: illnesssurgeryWhereInput
  }

  /**
   * InsurersCountOutputType without action
   */
  export type InsurersCountOutputTypeCountIllnesstypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: illnesstypeWhereInput
  }

  /**
   * InsurersCountOutputType without action
   */
  export type InsurersCountOutputTypeCountPolicytypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: policytypeWhereInput
  }

  /**
   * InsurersCountOutputType without action
   */
  export type InsurersCountOutputTypeCountProceduretransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: proceduretransactionsWhereInput
  }

  /**
   * InsurersCountOutputType without action
   */
  export type InsurersCountOutputTypeCountServicesettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: servicesettingWhereInput
  }


  /**
   * Count Type AccidenttransactionsCountOutputType
   */

  export type AccidenttransactionsCountOutputType = {
    causeofinjurydetail: number
    injurydetail: number
  }

  export type AccidenttransactionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    causeofinjurydetail?: boolean | AccidenttransactionsCountOutputTypeCountCauseofinjurydetailArgs
    injurydetail?: boolean | AccidenttransactionsCountOutputTypeCountInjurydetailArgs
  }

  // Custom InputTypes
  /**
   * AccidenttransactionsCountOutputType without action
   */
  export type AccidenttransactionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccidenttransactionsCountOutputType
     */
    select?: AccidenttransactionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccidenttransactionsCountOutputType without action
   */
  export type AccidenttransactionsCountOutputTypeCountCauseofinjurydetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: causeofinjurydetailWhereInput
  }

  /**
   * AccidenttransactionsCountOutputType without action
   */
  export type AccidenttransactionsCountOutputTypeCountInjurydetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: injurydetailWhereInput
  }


  /**
   * Models
   */

  /**
   * Model accidentcauseover45days
   */

  export type AggregateAccidentcauseover45days = {
    _count: Accidentcauseover45daysCountAggregateOutputType | null
    _avg: Accidentcauseover45daysAvgAggregateOutputType | null
    _sum: Accidentcauseover45daysSumAggregateOutputType | null
    _min: Accidentcauseover45daysMinAggregateOutputType | null
    _max: Accidentcauseover45daysMaxAggregateOutputType | null
  }

  export type Accidentcauseover45daysAvgAggregateOutputType = {
    id: number | null
    insurerid: number | null
  }

  export type Accidentcauseover45daysSumAggregateOutputType = {
    id: number | null
    insurerid: number | null
  }

  export type Accidentcauseover45daysMinAggregateOutputType = {
    id: number | null
    causeovercode: string | null
    causeoverdesc: string | null
    insurerid: number | null
  }

  export type Accidentcauseover45daysMaxAggregateOutputType = {
    id: number | null
    causeovercode: string | null
    causeoverdesc: string | null
    insurerid: number | null
  }

  export type Accidentcauseover45daysCountAggregateOutputType = {
    id: number
    causeovercode: number
    causeoverdesc: number
    insurerid: number
    _all: number
  }


  export type Accidentcauseover45daysAvgAggregateInputType = {
    id?: true
    insurerid?: true
  }

  export type Accidentcauseover45daysSumAggregateInputType = {
    id?: true
    insurerid?: true
  }

  export type Accidentcauseover45daysMinAggregateInputType = {
    id?: true
    causeovercode?: true
    causeoverdesc?: true
    insurerid?: true
  }

  export type Accidentcauseover45daysMaxAggregateInputType = {
    id?: true
    causeovercode?: true
    causeoverdesc?: true
    insurerid?: true
  }

  export type Accidentcauseover45daysCountAggregateInputType = {
    id?: true
    causeovercode?: true
    causeoverdesc?: true
    insurerid?: true
    _all?: true
  }

  export type Accidentcauseover45daysAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accidentcauseover45days to aggregate.
     */
    where?: accidentcauseover45daysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accidentcauseover45days to fetch.
     */
    orderBy?: accidentcauseover45daysOrderByWithRelationInput | accidentcauseover45daysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: accidentcauseover45daysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accidentcauseover45days from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accidentcauseover45days.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned accidentcauseover45days
    **/
    _count?: true | Accidentcauseover45daysCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Accidentcauseover45daysAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Accidentcauseover45daysSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Accidentcauseover45daysMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Accidentcauseover45daysMaxAggregateInputType
  }

  export type GetAccidentcauseover45daysAggregateType<T extends Accidentcauseover45daysAggregateArgs> = {
        [P in keyof T & keyof AggregateAccidentcauseover45days]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccidentcauseover45days[P]>
      : GetScalarType<T[P], AggregateAccidentcauseover45days[P]>
  }




  export type accidentcauseover45daysGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: accidentcauseover45daysWhereInput
    orderBy?: accidentcauseover45daysOrderByWithAggregationInput | accidentcauseover45daysOrderByWithAggregationInput[]
    by: Accidentcauseover45daysScalarFieldEnum[] | Accidentcauseover45daysScalarFieldEnum
    having?: accidentcauseover45daysScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Accidentcauseover45daysCountAggregateInputType | true
    _avg?: Accidentcauseover45daysAvgAggregateInputType
    _sum?: Accidentcauseover45daysSumAggregateInputType
    _min?: Accidentcauseover45daysMinAggregateInputType
    _max?: Accidentcauseover45daysMaxAggregateInputType
  }

  export type Accidentcauseover45daysGroupByOutputType = {
    id: number
    causeovercode: string
    causeoverdesc: string | null
    insurerid: number | null
    _count: Accidentcauseover45daysCountAggregateOutputType | null
    _avg: Accidentcauseover45daysAvgAggregateOutputType | null
    _sum: Accidentcauseover45daysSumAggregateOutputType | null
    _min: Accidentcauseover45daysMinAggregateOutputType | null
    _max: Accidentcauseover45daysMaxAggregateOutputType | null
  }

  type GetAccidentcauseover45daysGroupByPayload<T extends accidentcauseover45daysGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Accidentcauseover45daysGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Accidentcauseover45daysGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Accidentcauseover45daysGroupByOutputType[P]>
            : GetScalarType<T[P], Accidentcauseover45daysGroupByOutputType[P]>
        }
      >
    >


  export type accidentcauseover45daysSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    causeovercode?: boolean
    causeoverdesc?: boolean
    insurerid?: boolean
    insurers?: boolean | accidentcauseover45days$insurersArgs<ExtArgs>
  }, ExtArgs["result"]["accidentcauseover45days"]>

  export type accidentcauseover45daysSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    causeovercode?: boolean
    causeoverdesc?: boolean
    insurerid?: boolean
    insurers?: boolean | accidentcauseover45days$insurersArgs<ExtArgs>
  }, ExtArgs["result"]["accidentcauseover45days"]>

  export type accidentcauseover45daysSelectScalar = {
    id?: boolean
    causeovercode?: boolean
    causeoverdesc?: boolean
    insurerid?: boolean
  }

  export type accidentcauseover45daysInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurers?: boolean | accidentcauseover45days$insurersArgs<ExtArgs>
  }
  export type accidentcauseover45daysIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurers?: boolean | accidentcauseover45days$insurersArgs<ExtArgs>
  }

  export type $accidentcauseover45daysPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "accidentcauseover45days"
    objects: {
      insurers: Prisma.$insurersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      causeovercode: string
      causeoverdesc: string | null
      insurerid: number | null
    }, ExtArgs["result"]["accidentcauseover45days"]>
    composites: {}
  }

  type accidentcauseover45daysGetPayload<S extends boolean | null | undefined | accidentcauseover45daysDefaultArgs> = $Result.GetResult<Prisma.$accidentcauseover45daysPayload, S>

  type accidentcauseover45daysCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<accidentcauseover45daysFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Accidentcauseover45daysCountAggregateInputType | true
    }

  export interface accidentcauseover45daysDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['accidentcauseover45days'], meta: { name: 'accidentcauseover45days' } }
    /**
     * Find zero or one Accidentcauseover45days that matches the filter.
     * @param {accidentcauseover45daysFindUniqueArgs} args - Arguments to find a Accidentcauseover45days
     * @example
     * // Get one Accidentcauseover45days
     * const accidentcauseover45days = await prisma.accidentcauseover45days.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends accidentcauseover45daysFindUniqueArgs>(args: SelectSubset<T, accidentcauseover45daysFindUniqueArgs<ExtArgs>>): Prisma__accidentcauseover45daysClient<$Result.GetResult<Prisma.$accidentcauseover45daysPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Accidentcauseover45days that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {accidentcauseover45daysFindUniqueOrThrowArgs} args - Arguments to find a Accidentcauseover45days
     * @example
     * // Get one Accidentcauseover45days
     * const accidentcauseover45days = await prisma.accidentcauseover45days.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends accidentcauseover45daysFindUniqueOrThrowArgs>(args: SelectSubset<T, accidentcauseover45daysFindUniqueOrThrowArgs<ExtArgs>>): Prisma__accidentcauseover45daysClient<$Result.GetResult<Prisma.$accidentcauseover45daysPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Accidentcauseover45days that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accidentcauseover45daysFindFirstArgs} args - Arguments to find a Accidentcauseover45days
     * @example
     * // Get one Accidentcauseover45days
     * const accidentcauseover45days = await prisma.accidentcauseover45days.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends accidentcauseover45daysFindFirstArgs>(args?: SelectSubset<T, accidentcauseover45daysFindFirstArgs<ExtArgs>>): Prisma__accidentcauseover45daysClient<$Result.GetResult<Prisma.$accidentcauseover45daysPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Accidentcauseover45days that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accidentcauseover45daysFindFirstOrThrowArgs} args - Arguments to find a Accidentcauseover45days
     * @example
     * // Get one Accidentcauseover45days
     * const accidentcauseover45days = await prisma.accidentcauseover45days.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends accidentcauseover45daysFindFirstOrThrowArgs>(args?: SelectSubset<T, accidentcauseover45daysFindFirstOrThrowArgs<ExtArgs>>): Prisma__accidentcauseover45daysClient<$Result.GetResult<Prisma.$accidentcauseover45daysPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Accidentcauseover45days that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accidentcauseover45daysFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accidentcauseover45days
     * const accidentcauseover45days = await prisma.accidentcauseover45days.findMany()
     * 
     * // Get first 10 Accidentcauseover45days
     * const accidentcauseover45days = await prisma.accidentcauseover45days.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accidentcauseover45daysWithIdOnly = await prisma.accidentcauseover45days.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends accidentcauseover45daysFindManyArgs>(args?: SelectSubset<T, accidentcauseover45daysFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accidentcauseover45daysPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Accidentcauseover45days.
     * @param {accidentcauseover45daysCreateArgs} args - Arguments to create a Accidentcauseover45days.
     * @example
     * // Create one Accidentcauseover45days
     * const Accidentcauseover45days = await prisma.accidentcauseover45days.create({
     *   data: {
     *     // ... data to create a Accidentcauseover45days
     *   }
     * })
     * 
     */
    create<T extends accidentcauseover45daysCreateArgs>(args: SelectSubset<T, accidentcauseover45daysCreateArgs<ExtArgs>>): Prisma__accidentcauseover45daysClient<$Result.GetResult<Prisma.$accidentcauseover45daysPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Accidentcauseover45days.
     * @param {accidentcauseover45daysCreateManyArgs} args - Arguments to create many Accidentcauseover45days.
     * @example
     * // Create many Accidentcauseover45days
     * const accidentcauseover45days = await prisma.accidentcauseover45days.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends accidentcauseover45daysCreateManyArgs>(args?: SelectSubset<T, accidentcauseover45daysCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accidentcauseover45days and returns the data saved in the database.
     * @param {accidentcauseover45daysCreateManyAndReturnArgs} args - Arguments to create many Accidentcauseover45days.
     * @example
     * // Create many Accidentcauseover45days
     * const accidentcauseover45days = await prisma.accidentcauseover45days.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accidentcauseover45days and only return the `id`
     * const accidentcauseover45daysWithIdOnly = await prisma.accidentcauseover45days.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends accidentcauseover45daysCreateManyAndReturnArgs>(args?: SelectSubset<T, accidentcauseover45daysCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accidentcauseover45daysPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Accidentcauseover45days.
     * @param {accidentcauseover45daysDeleteArgs} args - Arguments to delete one Accidentcauseover45days.
     * @example
     * // Delete one Accidentcauseover45days
     * const Accidentcauseover45days = await prisma.accidentcauseover45days.delete({
     *   where: {
     *     // ... filter to delete one Accidentcauseover45days
     *   }
     * })
     * 
     */
    delete<T extends accidentcauseover45daysDeleteArgs>(args: SelectSubset<T, accidentcauseover45daysDeleteArgs<ExtArgs>>): Prisma__accidentcauseover45daysClient<$Result.GetResult<Prisma.$accidentcauseover45daysPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Accidentcauseover45days.
     * @param {accidentcauseover45daysUpdateArgs} args - Arguments to update one Accidentcauseover45days.
     * @example
     * // Update one Accidentcauseover45days
     * const accidentcauseover45days = await prisma.accidentcauseover45days.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends accidentcauseover45daysUpdateArgs>(args: SelectSubset<T, accidentcauseover45daysUpdateArgs<ExtArgs>>): Prisma__accidentcauseover45daysClient<$Result.GetResult<Prisma.$accidentcauseover45daysPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Accidentcauseover45days.
     * @param {accidentcauseover45daysDeleteManyArgs} args - Arguments to filter Accidentcauseover45days to delete.
     * @example
     * // Delete a few Accidentcauseover45days
     * const { count } = await prisma.accidentcauseover45days.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends accidentcauseover45daysDeleteManyArgs>(args?: SelectSubset<T, accidentcauseover45daysDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accidentcauseover45days.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accidentcauseover45daysUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accidentcauseover45days
     * const accidentcauseover45days = await prisma.accidentcauseover45days.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends accidentcauseover45daysUpdateManyArgs>(args: SelectSubset<T, accidentcauseover45daysUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Accidentcauseover45days.
     * @param {accidentcauseover45daysUpsertArgs} args - Arguments to update or create a Accidentcauseover45days.
     * @example
     * // Update or create a Accidentcauseover45days
     * const accidentcauseover45days = await prisma.accidentcauseover45days.upsert({
     *   create: {
     *     // ... data to create a Accidentcauseover45days
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Accidentcauseover45days we want to update
     *   }
     * })
     */
    upsert<T extends accidentcauseover45daysUpsertArgs>(args: SelectSubset<T, accidentcauseover45daysUpsertArgs<ExtArgs>>): Prisma__accidentcauseover45daysClient<$Result.GetResult<Prisma.$accidentcauseover45daysPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Accidentcauseover45days.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accidentcauseover45daysCountArgs} args - Arguments to filter Accidentcauseover45days to count.
     * @example
     * // Count the number of Accidentcauseover45days
     * const count = await prisma.accidentcauseover45days.count({
     *   where: {
     *     // ... the filter for the Accidentcauseover45days we want to count
     *   }
     * })
    **/
    count<T extends accidentcauseover45daysCountArgs>(
      args?: Subset<T, accidentcauseover45daysCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Accidentcauseover45daysCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Accidentcauseover45days.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Accidentcauseover45daysAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Accidentcauseover45daysAggregateArgs>(args: Subset<T, Accidentcauseover45daysAggregateArgs>): Prisma.PrismaPromise<GetAccidentcauseover45daysAggregateType<T>>

    /**
     * Group by Accidentcauseover45days.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accidentcauseover45daysGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends accidentcauseover45daysGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: accidentcauseover45daysGroupByArgs['orderBy'] }
        : { orderBy?: accidentcauseover45daysGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, accidentcauseover45daysGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccidentcauseover45daysGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the accidentcauseover45days model
   */
  readonly fields: accidentcauseover45daysFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for accidentcauseover45days.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__accidentcauseover45daysClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    insurers<T extends accidentcauseover45days$insurersArgs<ExtArgs> = {}>(args?: Subset<T, accidentcauseover45days$insurersArgs<ExtArgs>>): Prisma__insurersClient<$Result.GetResult<Prisma.$insurersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the accidentcauseover45days model
   */ 
  interface accidentcauseover45daysFieldRefs {
    readonly id: FieldRef<"accidentcauseover45days", 'Int'>
    readonly causeovercode: FieldRef<"accidentcauseover45days", 'String'>
    readonly causeoverdesc: FieldRef<"accidentcauseover45days", 'String'>
    readonly insurerid: FieldRef<"accidentcauseover45days", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * accidentcauseover45days findUnique
   */
  export type accidentcauseover45daysFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidentcauseover45days
     */
    select?: accidentcauseover45daysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidentcauseover45daysInclude<ExtArgs> | null
    /**
     * Filter, which accidentcauseover45days to fetch.
     */
    where: accidentcauseover45daysWhereUniqueInput
  }

  /**
   * accidentcauseover45days findUniqueOrThrow
   */
  export type accidentcauseover45daysFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidentcauseover45days
     */
    select?: accidentcauseover45daysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidentcauseover45daysInclude<ExtArgs> | null
    /**
     * Filter, which accidentcauseover45days to fetch.
     */
    where: accidentcauseover45daysWhereUniqueInput
  }

  /**
   * accidentcauseover45days findFirst
   */
  export type accidentcauseover45daysFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidentcauseover45days
     */
    select?: accidentcauseover45daysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidentcauseover45daysInclude<ExtArgs> | null
    /**
     * Filter, which accidentcauseover45days to fetch.
     */
    where?: accidentcauseover45daysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accidentcauseover45days to fetch.
     */
    orderBy?: accidentcauseover45daysOrderByWithRelationInput | accidentcauseover45daysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accidentcauseover45days.
     */
    cursor?: accidentcauseover45daysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accidentcauseover45days from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accidentcauseover45days.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accidentcauseover45days.
     */
    distinct?: Accidentcauseover45daysScalarFieldEnum | Accidentcauseover45daysScalarFieldEnum[]
  }

  /**
   * accidentcauseover45days findFirstOrThrow
   */
  export type accidentcauseover45daysFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidentcauseover45days
     */
    select?: accidentcauseover45daysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidentcauseover45daysInclude<ExtArgs> | null
    /**
     * Filter, which accidentcauseover45days to fetch.
     */
    where?: accidentcauseover45daysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accidentcauseover45days to fetch.
     */
    orderBy?: accidentcauseover45daysOrderByWithRelationInput | accidentcauseover45daysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accidentcauseover45days.
     */
    cursor?: accidentcauseover45daysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accidentcauseover45days from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accidentcauseover45days.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accidentcauseover45days.
     */
    distinct?: Accidentcauseover45daysScalarFieldEnum | Accidentcauseover45daysScalarFieldEnum[]
  }

  /**
   * accidentcauseover45days findMany
   */
  export type accidentcauseover45daysFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidentcauseover45days
     */
    select?: accidentcauseover45daysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidentcauseover45daysInclude<ExtArgs> | null
    /**
     * Filter, which accidentcauseover45days to fetch.
     */
    where?: accidentcauseover45daysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accidentcauseover45days to fetch.
     */
    orderBy?: accidentcauseover45daysOrderByWithRelationInput | accidentcauseover45daysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing accidentcauseover45days.
     */
    cursor?: accidentcauseover45daysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accidentcauseover45days from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accidentcauseover45days.
     */
    skip?: number
    distinct?: Accidentcauseover45daysScalarFieldEnum | Accidentcauseover45daysScalarFieldEnum[]
  }

  /**
   * accidentcauseover45days create
   */
  export type accidentcauseover45daysCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidentcauseover45days
     */
    select?: accidentcauseover45daysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidentcauseover45daysInclude<ExtArgs> | null
    /**
     * The data needed to create a accidentcauseover45days.
     */
    data: XOR<accidentcauseover45daysCreateInput, accidentcauseover45daysUncheckedCreateInput>
  }

  /**
   * accidentcauseover45days createMany
   */
  export type accidentcauseover45daysCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many accidentcauseover45days.
     */
    data: accidentcauseover45daysCreateManyInput | accidentcauseover45daysCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * accidentcauseover45days createManyAndReturn
   */
  export type accidentcauseover45daysCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidentcauseover45days
     */
    select?: accidentcauseover45daysSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many accidentcauseover45days.
     */
    data: accidentcauseover45daysCreateManyInput | accidentcauseover45daysCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidentcauseover45daysIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * accidentcauseover45days update
   */
  export type accidentcauseover45daysUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidentcauseover45days
     */
    select?: accidentcauseover45daysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidentcauseover45daysInclude<ExtArgs> | null
    /**
     * The data needed to update a accidentcauseover45days.
     */
    data: XOR<accidentcauseover45daysUpdateInput, accidentcauseover45daysUncheckedUpdateInput>
    /**
     * Choose, which accidentcauseover45days to update.
     */
    where: accidentcauseover45daysWhereUniqueInput
  }

  /**
   * accidentcauseover45days updateMany
   */
  export type accidentcauseover45daysUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update accidentcauseover45days.
     */
    data: XOR<accidentcauseover45daysUpdateManyMutationInput, accidentcauseover45daysUncheckedUpdateManyInput>
    /**
     * Filter which accidentcauseover45days to update
     */
    where?: accidentcauseover45daysWhereInput
  }

  /**
   * accidentcauseover45days upsert
   */
  export type accidentcauseover45daysUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidentcauseover45days
     */
    select?: accidentcauseover45daysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidentcauseover45daysInclude<ExtArgs> | null
    /**
     * The filter to search for the accidentcauseover45days to update in case it exists.
     */
    where: accidentcauseover45daysWhereUniqueInput
    /**
     * In case the accidentcauseover45days found by the `where` argument doesn't exist, create a new accidentcauseover45days with this data.
     */
    create: XOR<accidentcauseover45daysCreateInput, accidentcauseover45daysUncheckedCreateInput>
    /**
     * In case the accidentcauseover45days was found with the provided `where` argument, update it with this data.
     */
    update: XOR<accidentcauseover45daysUpdateInput, accidentcauseover45daysUncheckedUpdateInput>
  }

  /**
   * accidentcauseover45days delete
   */
  export type accidentcauseover45daysDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidentcauseover45days
     */
    select?: accidentcauseover45daysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidentcauseover45daysInclude<ExtArgs> | null
    /**
     * Filter which accidentcauseover45days to delete.
     */
    where: accidentcauseover45daysWhereUniqueInput
  }

  /**
   * accidentcauseover45days deleteMany
   */
  export type accidentcauseover45daysDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accidentcauseover45days to delete
     */
    where?: accidentcauseover45daysWhereInput
  }

  /**
   * accidentcauseover45days.insurers
   */
  export type accidentcauseover45days$insurersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insurers
     */
    select?: insurersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: insurersInclude<ExtArgs> | null
    where?: insurersWhereInput
  }

  /**
   * accidentcauseover45days without action
   */
  export type accidentcauseover45daysDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidentcauseover45days
     */
    select?: accidentcauseover45daysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidentcauseover45daysInclude<ExtArgs> | null
  }


  /**
   * Model accidentplace
   */

  export type AggregateAccidentplace = {
    _count: AccidentplaceCountAggregateOutputType | null
    _avg: AccidentplaceAvgAggregateOutputType | null
    _sum: AccidentplaceSumAggregateOutputType | null
    _min: AccidentplaceMinAggregateOutputType | null
    _max: AccidentplaceMaxAggregateOutputType | null
  }

  export type AccidentplaceAvgAggregateOutputType = {
    id: number | null
    insurerid: number | null
  }

  export type AccidentplaceSumAggregateOutputType = {
    id: number | null
    insurerid: number | null
  }

  export type AccidentplaceMinAggregateOutputType = {
    id: number | null
    accidentplacecode: string | null
    accidentplacename: string | null
    insurerid: number | null
  }

  export type AccidentplaceMaxAggregateOutputType = {
    id: number | null
    accidentplacecode: string | null
    accidentplacename: string | null
    insurerid: number | null
  }

  export type AccidentplaceCountAggregateOutputType = {
    id: number
    accidentplacecode: number
    accidentplacename: number
    insurerid: number
    _all: number
  }


  export type AccidentplaceAvgAggregateInputType = {
    id?: true
    insurerid?: true
  }

  export type AccidentplaceSumAggregateInputType = {
    id?: true
    insurerid?: true
  }

  export type AccidentplaceMinAggregateInputType = {
    id?: true
    accidentplacecode?: true
    accidentplacename?: true
    insurerid?: true
  }

  export type AccidentplaceMaxAggregateInputType = {
    id?: true
    accidentplacecode?: true
    accidentplacename?: true
    insurerid?: true
  }

  export type AccidentplaceCountAggregateInputType = {
    id?: true
    accidentplacecode?: true
    accidentplacename?: true
    insurerid?: true
    _all?: true
  }

  export type AccidentplaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accidentplace to aggregate.
     */
    where?: accidentplaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accidentplaces to fetch.
     */
    orderBy?: accidentplaceOrderByWithRelationInput | accidentplaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: accidentplaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accidentplaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accidentplaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned accidentplaces
    **/
    _count?: true | AccidentplaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccidentplaceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccidentplaceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccidentplaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccidentplaceMaxAggregateInputType
  }

  export type GetAccidentplaceAggregateType<T extends AccidentplaceAggregateArgs> = {
        [P in keyof T & keyof AggregateAccidentplace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccidentplace[P]>
      : GetScalarType<T[P], AggregateAccidentplace[P]>
  }




  export type accidentplaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: accidentplaceWhereInput
    orderBy?: accidentplaceOrderByWithAggregationInput | accidentplaceOrderByWithAggregationInput[]
    by: AccidentplaceScalarFieldEnum[] | AccidentplaceScalarFieldEnum
    having?: accidentplaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccidentplaceCountAggregateInputType | true
    _avg?: AccidentplaceAvgAggregateInputType
    _sum?: AccidentplaceSumAggregateInputType
    _min?: AccidentplaceMinAggregateInputType
    _max?: AccidentplaceMaxAggregateInputType
  }

  export type AccidentplaceGroupByOutputType = {
    id: number
    accidentplacecode: string
    accidentplacename: string | null
    insurerid: number | null
    _count: AccidentplaceCountAggregateOutputType | null
    _avg: AccidentplaceAvgAggregateOutputType | null
    _sum: AccidentplaceSumAggregateOutputType | null
    _min: AccidentplaceMinAggregateOutputType | null
    _max: AccidentplaceMaxAggregateOutputType | null
  }

  type GetAccidentplaceGroupByPayload<T extends accidentplaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccidentplaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccidentplaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccidentplaceGroupByOutputType[P]>
            : GetScalarType<T[P], AccidentplaceGroupByOutputType[P]>
        }
      >
    >


  export type accidentplaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accidentplacecode?: boolean
    accidentplacename?: boolean
    insurerid?: boolean
    insurers?: boolean | accidentplace$insurersArgs<ExtArgs>
  }, ExtArgs["result"]["accidentplace"]>

  export type accidentplaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accidentplacecode?: boolean
    accidentplacename?: boolean
    insurerid?: boolean
    insurers?: boolean | accidentplace$insurersArgs<ExtArgs>
  }, ExtArgs["result"]["accidentplace"]>

  export type accidentplaceSelectScalar = {
    id?: boolean
    accidentplacecode?: boolean
    accidentplacename?: boolean
    insurerid?: boolean
  }

  export type accidentplaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurers?: boolean | accidentplace$insurersArgs<ExtArgs>
  }
  export type accidentplaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurers?: boolean | accidentplace$insurersArgs<ExtArgs>
  }

  export type $accidentplacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "accidentplace"
    objects: {
      insurers: Prisma.$insurersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      accidentplacecode: string
      accidentplacename: string | null
      insurerid: number | null
    }, ExtArgs["result"]["accidentplace"]>
    composites: {}
  }

  type accidentplaceGetPayload<S extends boolean | null | undefined | accidentplaceDefaultArgs> = $Result.GetResult<Prisma.$accidentplacePayload, S>

  type accidentplaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<accidentplaceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccidentplaceCountAggregateInputType | true
    }

  export interface accidentplaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['accidentplace'], meta: { name: 'accidentplace' } }
    /**
     * Find zero or one Accidentplace that matches the filter.
     * @param {accidentplaceFindUniqueArgs} args - Arguments to find a Accidentplace
     * @example
     * // Get one Accidentplace
     * const accidentplace = await prisma.accidentplace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends accidentplaceFindUniqueArgs>(args: SelectSubset<T, accidentplaceFindUniqueArgs<ExtArgs>>): Prisma__accidentplaceClient<$Result.GetResult<Prisma.$accidentplacePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Accidentplace that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {accidentplaceFindUniqueOrThrowArgs} args - Arguments to find a Accidentplace
     * @example
     * // Get one Accidentplace
     * const accidentplace = await prisma.accidentplace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends accidentplaceFindUniqueOrThrowArgs>(args: SelectSubset<T, accidentplaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__accidentplaceClient<$Result.GetResult<Prisma.$accidentplacePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Accidentplace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accidentplaceFindFirstArgs} args - Arguments to find a Accidentplace
     * @example
     * // Get one Accidentplace
     * const accidentplace = await prisma.accidentplace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends accidentplaceFindFirstArgs>(args?: SelectSubset<T, accidentplaceFindFirstArgs<ExtArgs>>): Prisma__accidentplaceClient<$Result.GetResult<Prisma.$accidentplacePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Accidentplace that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accidentplaceFindFirstOrThrowArgs} args - Arguments to find a Accidentplace
     * @example
     * // Get one Accidentplace
     * const accidentplace = await prisma.accidentplace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends accidentplaceFindFirstOrThrowArgs>(args?: SelectSubset<T, accidentplaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__accidentplaceClient<$Result.GetResult<Prisma.$accidentplacePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Accidentplaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accidentplaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accidentplaces
     * const accidentplaces = await prisma.accidentplace.findMany()
     * 
     * // Get first 10 Accidentplaces
     * const accidentplaces = await prisma.accidentplace.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accidentplaceWithIdOnly = await prisma.accidentplace.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends accidentplaceFindManyArgs>(args?: SelectSubset<T, accidentplaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accidentplacePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Accidentplace.
     * @param {accidentplaceCreateArgs} args - Arguments to create a Accidentplace.
     * @example
     * // Create one Accidentplace
     * const Accidentplace = await prisma.accidentplace.create({
     *   data: {
     *     // ... data to create a Accidentplace
     *   }
     * })
     * 
     */
    create<T extends accidentplaceCreateArgs>(args: SelectSubset<T, accidentplaceCreateArgs<ExtArgs>>): Prisma__accidentplaceClient<$Result.GetResult<Prisma.$accidentplacePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Accidentplaces.
     * @param {accidentplaceCreateManyArgs} args - Arguments to create many Accidentplaces.
     * @example
     * // Create many Accidentplaces
     * const accidentplace = await prisma.accidentplace.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends accidentplaceCreateManyArgs>(args?: SelectSubset<T, accidentplaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accidentplaces and returns the data saved in the database.
     * @param {accidentplaceCreateManyAndReturnArgs} args - Arguments to create many Accidentplaces.
     * @example
     * // Create many Accidentplaces
     * const accidentplace = await prisma.accidentplace.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accidentplaces and only return the `id`
     * const accidentplaceWithIdOnly = await prisma.accidentplace.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends accidentplaceCreateManyAndReturnArgs>(args?: SelectSubset<T, accidentplaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accidentplacePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Accidentplace.
     * @param {accidentplaceDeleteArgs} args - Arguments to delete one Accidentplace.
     * @example
     * // Delete one Accidentplace
     * const Accidentplace = await prisma.accidentplace.delete({
     *   where: {
     *     // ... filter to delete one Accidentplace
     *   }
     * })
     * 
     */
    delete<T extends accidentplaceDeleteArgs>(args: SelectSubset<T, accidentplaceDeleteArgs<ExtArgs>>): Prisma__accidentplaceClient<$Result.GetResult<Prisma.$accidentplacePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Accidentplace.
     * @param {accidentplaceUpdateArgs} args - Arguments to update one Accidentplace.
     * @example
     * // Update one Accidentplace
     * const accidentplace = await prisma.accidentplace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends accidentplaceUpdateArgs>(args: SelectSubset<T, accidentplaceUpdateArgs<ExtArgs>>): Prisma__accidentplaceClient<$Result.GetResult<Prisma.$accidentplacePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Accidentplaces.
     * @param {accidentplaceDeleteManyArgs} args - Arguments to filter Accidentplaces to delete.
     * @example
     * // Delete a few Accidentplaces
     * const { count } = await prisma.accidentplace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends accidentplaceDeleteManyArgs>(args?: SelectSubset<T, accidentplaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accidentplaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accidentplaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accidentplaces
     * const accidentplace = await prisma.accidentplace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends accidentplaceUpdateManyArgs>(args: SelectSubset<T, accidentplaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Accidentplace.
     * @param {accidentplaceUpsertArgs} args - Arguments to update or create a Accidentplace.
     * @example
     * // Update or create a Accidentplace
     * const accidentplace = await prisma.accidentplace.upsert({
     *   create: {
     *     // ... data to create a Accidentplace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Accidentplace we want to update
     *   }
     * })
     */
    upsert<T extends accidentplaceUpsertArgs>(args: SelectSubset<T, accidentplaceUpsertArgs<ExtArgs>>): Prisma__accidentplaceClient<$Result.GetResult<Prisma.$accidentplacePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Accidentplaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accidentplaceCountArgs} args - Arguments to filter Accidentplaces to count.
     * @example
     * // Count the number of Accidentplaces
     * const count = await prisma.accidentplace.count({
     *   where: {
     *     // ... the filter for the Accidentplaces we want to count
     *   }
     * })
    **/
    count<T extends accidentplaceCountArgs>(
      args?: Subset<T, accidentplaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccidentplaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Accidentplace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccidentplaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccidentplaceAggregateArgs>(args: Subset<T, AccidentplaceAggregateArgs>): Prisma.PrismaPromise<GetAccidentplaceAggregateType<T>>

    /**
     * Group by Accidentplace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accidentplaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends accidentplaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: accidentplaceGroupByArgs['orderBy'] }
        : { orderBy?: accidentplaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, accidentplaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccidentplaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the accidentplace model
   */
  readonly fields: accidentplaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for accidentplace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__accidentplaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    insurers<T extends accidentplace$insurersArgs<ExtArgs> = {}>(args?: Subset<T, accidentplace$insurersArgs<ExtArgs>>): Prisma__insurersClient<$Result.GetResult<Prisma.$insurersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the accidentplace model
   */ 
  interface accidentplaceFieldRefs {
    readonly id: FieldRef<"accidentplace", 'Int'>
    readonly accidentplacecode: FieldRef<"accidentplace", 'String'>
    readonly accidentplacename: FieldRef<"accidentplace", 'String'>
    readonly insurerid: FieldRef<"accidentplace", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * accidentplace findUnique
   */
  export type accidentplaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidentplace
     */
    select?: accidentplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidentplaceInclude<ExtArgs> | null
    /**
     * Filter, which accidentplace to fetch.
     */
    where: accidentplaceWhereUniqueInput
  }

  /**
   * accidentplace findUniqueOrThrow
   */
  export type accidentplaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidentplace
     */
    select?: accidentplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidentplaceInclude<ExtArgs> | null
    /**
     * Filter, which accidentplace to fetch.
     */
    where: accidentplaceWhereUniqueInput
  }

  /**
   * accidentplace findFirst
   */
  export type accidentplaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidentplace
     */
    select?: accidentplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidentplaceInclude<ExtArgs> | null
    /**
     * Filter, which accidentplace to fetch.
     */
    where?: accidentplaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accidentplaces to fetch.
     */
    orderBy?: accidentplaceOrderByWithRelationInput | accidentplaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accidentplaces.
     */
    cursor?: accidentplaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accidentplaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accidentplaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accidentplaces.
     */
    distinct?: AccidentplaceScalarFieldEnum | AccidentplaceScalarFieldEnum[]
  }

  /**
   * accidentplace findFirstOrThrow
   */
  export type accidentplaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidentplace
     */
    select?: accidentplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidentplaceInclude<ExtArgs> | null
    /**
     * Filter, which accidentplace to fetch.
     */
    where?: accidentplaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accidentplaces to fetch.
     */
    orderBy?: accidentplaceOrderByWithRelationInput | accidentplaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accidentplaces.
     */
    cursor?: accidentplaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accidentplaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accidentplaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accidentplaces.
     */
    distinct?: AccidentplaceScalarFieldEnum | AccidentplaceScalarFieldEnum[]
  }

  /**
   * accidentplace findMany
   */
  export type accidentplaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidentplace
     */
    select?: accidentplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidentplaceInclude<ExtArgs> | null
    /**
     * Filter, which accidentplaces to fetch.
     */
    where?: accidentplaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accidentplaces to fetch.
     */
    orderBy?: accidentplaceOrderByWithRelationInput | accidentplaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing accidentplaces.
     */
    cursor?: accidentplaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accidentplaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accidentplaces.
     */
    skip?: number
    distinct?: AccidentplaceScalarFieldEnum | AccidentplaceScalarFieldEnum[]
  }

  /**
   * accidentplace create
   */
  export type accidentplaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidentplace
     */
    select?: accidentplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidentplaceInclude<ExtArgs> | null
    /**
     * The data needed to create a accidentplace.
     */
    data: XOR<accidentplaceCreateInput, accidentplaceUncheckedCreateInput>
  }

  /**
   * accidentplace createMany
   */
  export type accidentplaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many accidentplaces.
     */
    data: accidentplaceCreateManyInput | accidentplaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * accidentplace createManyAndReturn
   */
  export type accidentplaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidentplace
     */
    select?: accidentplaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many accidentplaces.
     */
    data: accidentplaceCreateManyInput | accidentplaceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidentplaceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * accidentplace update
   */
  export type accidentplaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidentplace
     */
    select?: accidentplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidentplaceInclude<ExtArgs> | null
    /**
     * The data needed to update a accidentplace.
     */
    data: XOR<accidentplaceUpdateInput, accidentplaceUncheckedUpdateInput>
    /**
     * Choose, which accidentplace to update.
     */
    where: accidentplaceWhereUniqueInput
  }

  /**
   * accidentplace updateMany
   */
  export type accidentplaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update accidentplaces.
     */
    data: XOR<accidentplaceUpdateManyMutationInput, accidentplaceUncheckedUpdateManyInput>
    /**
     * Filter which accidentplaces to update
     */
    where?: accidentplaceWhereInput
  }

  /**
   * accidentplace upsert
   */
  export type accidentplaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidentplace
     */
    select?: accidentplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidentplaceInclude<ExtArgs> | null
    /**
     * The filter to search for the accidentplace to update in case it exists.
     */
    where: accidentplaceWhereUniqueInput
    /**
     * In case the accidentplace found by the `where` argument doesn't exist, create a new accidentplace with this data.
     */
    create: XOR<accidentplaceCreateInput, accidentplaceUncheckedCreateInput>
    /**
     * In case the accidentplace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<accidentplaceUpdateInput, accidentplaceUncheckedUpdateInput>
  }

  /**
   * accidentplace delete
   */
  export type accidentplaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidentplace
     */
    select?: accidentplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidentplaceInclude<ExtArgs> | null
    /**
     * Filter which accidentplace to delete.
     */
    where: accidentplaceWhereUniqueInput
  }

  /**
   * accidentplace deleteMany
   */
  export type accidentplaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accidentplaces to delete
     */
    where?: accidentplaceWhereInput
  }

  /**
   * accidentplace.insurers
   */
  export type accidentplace$insurersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insurers
     */
    select?: insurersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: insurersInclude<ExtArgs> | null
    where?: insurersWhereInput
  }

  /**
   * accidentplace without action
   */
  export type accidentplaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidentplace
     */
    select?: accidentplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidentplaceInclude<ExtArgs> | null
  }


  /**
   * Model causeofinjuryside
   */

  export type AggregateCauseofinjuryside = {
    _count: CauseofinjurysideCountAggregateOutputType | null
    _avg: CauseofinjurysideAvgAggregateOutputType | null
    _sum: CauseofinjurysideSumAggregateOutputType | null
    _min: CauseofinjurysideMinAggregateOutputType | null
    _max: CauseofinjurysideMaxAggregateOutputType | null
  }

  export type CauseofinjurysideAvgAggregateOutputType = {
    id: number | null
    insurerid: number | null
  }

  export type CauseofinjurysideSumAggregateOutputType = {
    id: number | null
    insurerid: number | null
  }

  export type CauseofinjurysideMinAggregateOutputType = {
    id: number | null
    injurysidename: string | null
    injurysidecode: string | null
    insurerid: number | null
  }

  export type CauseofinjurysideMaxAggregateOutputType = {
    id: number | null
    injurysidename: string | null
    injurysidecode: string | null
    insurerid: number | null
  }

  export type CauseofinjurysideCountAggregateOutputType = {
    id: number
    injurysidename: number
    injurysidecode: number
    insurerid: number
    _all: number
  }


  export type CauseofinjurysideAvgAggregateInputType = {
    id?: true
    insurerid?: true
  }

  export type CauseofinjurysideSumAggregateInputType = {
    id?: true
    insurerid?: true
  }

  export type CauseofinjurysideMinAggregateInputType = {
    id?: true
    injurysidename?: true
    injurysidecode?: true
    insurerid?: true
  }

  export type CauseofinjurysideMaxAggregateInputType = {
    id?: true
    injurysidename?: true
    injurysidecode?: true
    insurerid?: true
  }

  export type CauseofinjurysideCountAggregateInputType = {
    id?: true
    injurysidename?: true
    injurysidecode?: true
    insurerid?: true
    _all?: true
  }

  export type CauseofinjurysideAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which causeofinjuryside to aggregate.
     */
    where?: causeofinjurysideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of causeofinjurysides to fetch.
     */
    orderBy?: causeofinjurysideOrderByWithRelationInput | causeofinjurysideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: causeofinjurysideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` causeofinjurysides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` causeofinjurysides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned causeofinjurysides
    **/
    _count?: true | CauseofinjurysideCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CauseofinjurysideAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CauseofinjurysideSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CauseofinjurysideMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CauseofinjurysideMaxAggregateInputType
  }

  export type GetCauseofinjurysideAggregateType<T extends CauseofinjurysideAggregateArgs> = {
        [P in keyof T & keyof AggregateCauseofinjuryside]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCauseofinjuryside[P]>
      : GetScalarType<T[P], AggregateCauseofinjuryside[P]>
  }




  export type causeofinjurysideGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: causeofinjurysideWhereInput
    orderBy?: causeofinjurysideOrderByWithAggregationInput | causeofinjurysideOrderByWithAggregationInput[]
    by: CauseofinjurysideScalarFieldEnum[] | CauseofinjurysideScalarFieldEnum
    having?: causeofinjurysideScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CauseofinjurysideCountAggregateInputType | true
    _avg?: CauseofinjurysideAvgAggregateInputType
    _sum?: CauseofinjurysideSumAggregateInputType
    _min?: CauseofinjurysideMinAggregateInputType
    _max?: CauseofinjurysideMaxAggregateInputType
  }

  export type CauseofinjurysideGroupByOutputType = {
    id: number
    injurysidename: string
    injurysidecode: string | null
    insurerid: number | null
    _count: CauseofinjurysideCountAggregateOutputType | null
    _avg: CauseofinjurysideAvgAggregateOutputType | null
    _sum: CauseofinjurysideSumAggregateOutputType | null
    _min: CauseofinjurysideMinAggregateOutputType | null
    _max: CauseofinjurysideMaxAggregateOutputType | null
  }

  type GetCauseofinjurysideGroupByPayload<T extends causeofinjurysideGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CauseofinjurysideGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CauseofinjurysideGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CauseofinjurysideGroupByOutputType[P]>
            : GetScalarType<T[P], CauseofinjurysideGroupByOutputType[P]>
        }
      >
    >


  export type causeofinjurysideSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    injurysidename?: boolean
    injurysidecode?: boolean
    insurerid?: boolean
    insurers?: boolean | causeofinjuryside$insurersArgs<ExtArgs>
  }, ExtArgs["result"]["causeofinjuryside"]>

  export type causeofinjurysideSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    injurysidename?: boolean
    injurysidecode?: boolean
    insurerid?: boolean
    insurers?: boolean | causeofinjuryside$insurersArgs<ExtArgs>
  }, ExtArgs["result"]["causeofinjuryside"]>

  export type causeofinjurysideSelectScalar = {
    id?: boolean
    injurysidename?: boolean
    injurysidecode?: boolean
    insurerid?: boolean
  }

  export type causeofinjurysideInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurers?: boolean | causeofinjuryside$insurersArgs<ExtArgs>
  }
  export type causeofinjurysideIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurers?: boolean | causeofinjuryside$insurersArgs<ExtArgs>
  }

  export type $causeofinjurysidePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "causeofinjuryside"
    objects: {
      insurers: Prisma.$insurersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      injurysidename: string
      injurysidecode: string | null
      insurerid: number | null
    }, ExtArgs["result"]["causeofinjuryside"]>
    composites: {}
  }

  type causeofinjurysideGetPayload<S extends boolean | null | undefined | causeofinjurysideDefaultArgs> = $Result.GetResult<Prisma.$causeofinjurysidePayload, S>

  type causeofinjurysideCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<causeofinjurysideFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CauseofinjurysideCountAggregateInputType | true
    }

  export interface causeofinjurysideDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['causeofinjuryside'], meta: { name: 'causeofinjuryside' } }
    /**
     * Find zero or one Causeofinjuryside that matches the filter.
     * @param {causeofinjurysideFindUniqueArgs} args - Arguments to find a Causeofinjuryside
     * @example
     * // Get one Causeofinjuryside
     * const causeofinjuryside = await prisma.causeofinjuryside.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends causeofinjurysideFindUniqueArgs>(args: SelectSubset<T, causeofinjurysideFindUniqueArgs<ExtArgs>>): Prisma__causeofinjurysideClient<$Result.GetResult<Prisma.$causeofinjurysidePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Causeofinjuryside that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {causeofinjurysideFindUniqueOrThrowArgs} args - Arguments to find a Causeofinjuryside
     * @example
     * // Get one Causeofinjuryside
     * const causeofinjuryside = await prisma.causeofinjuryside.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends causeofinjurysideFindUniqueOrThrowArgs>(args: SelectSubset<T, causeofinjurysideFindUniqueOrThrowArgs<ExtArgs>>): Prisma__causeofinjurysideClient<$Result.GetResult<Prisma.$causeofinjurysidePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Causeofinjuryside that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {causeofinjurysideFindFirstArgs} args - Arguments to find a Causeofinjuryside
     * @example
     * // Get one Causeofinjuryside
     * const causeofinjuryside = await prisma.causeofinjuryside.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends causeofinjurysideFindFirstArgs>(args?: SelectSubset<T, causeofinjurysideFindFirstArgs<ExtArgs>>): Prisma__causeofinjurysideClient<$Result.GetResult<Prisma.$causeofinjurysidePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Causeofinjuryside that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {causeofinjurysideFindFirstOrThrowArgs} args - Arguments to find a Causeofinjuryside
     * @example
     * // Get one Causeofinjuryside
     * const causeofinjuryside = await prisma.causeofinjuryside.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends causeofinjurysideFindFirstOrThrowArgs>(args?: SelectSubset<T, causeofinjurysideFindFirstOrThrowArgs<ExtArgs>>): Prisma__causeofinjurysideClient<$Result.GetResult<Prisma.$causeofinjurysidePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Causeofinjurysides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {causeofinjurysideFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Causeofinjurysides
     * const causeofinjurysides = await prisma.causeofinjuryside.findMany()
     * 
     * // Get first 10 Causeofinjurysides
     * const causeofinjurysides = await prisma.causeofinjuryside.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const causeofinjurysideWithIdOnly = await prisma.causeofinjuryside.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends causeofinjurysideFindManyArgs>(args?: SelectSubset<T, causeofinjurysideFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$causeofinjurysidePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Causeofinjuryside.
     * @param {causeofinjurysideCreateArgs} args - Arguments to create a Causeofinjuryside.
     * @example
     * // Create one Causeofinjuryside
     * const Causeofinjuryside = await prisma.causeofinjuryside.create({
     *   data: {
     *     // ... data to create a Causeofinjuryside
     *   }
     * })
     * 
     */
    create<T extends causeofinjurysideCreateArgs>(args: SelectSubset<T, causeofinjurysideCreateArgs<ExtArgs>>): Prisma__causeofinjurysideClient<$Result.GetResult<Prisma.$causeofinjurysidePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Causeofinjurysides.
     * @param {causeofinjurysideCreateManyArgs} args - Arguments to create many Causeofinjurysides.
     * @example
     * // Create many Causeofinjurysides
     * const causeofinjuryside = await prisma.causeofinjuryside.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends causeofinjurysideCreateManyArgs>(args?: SelectSubset<T, causeofinjurysideCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Causeofinjurysides and returns the data saved in the database.
     * @param {causeofinjurysideCreateManyAndReturnArgs} args - Arguments to create many Causeofinjurysides.
     * @example
     * // Create many Causeofinjurysides
     * const causeofinjuryside = await prisma.causeofinjuryside.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Causeofinjurysides and only return the `id`
     * const causeofinjurysideWithIdOnly = await prisma.causeofinjuryside.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends causeofinjurysideCreateManyAndReturnArgs>(args?: SelectSubset<T, causeofinjurysideCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$causeofinjurysidePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Causeofinjuryside.
     * @param {causeofinjurysideDeleteArgs} args - Arguments to delete one Causeofinjuryside.
     * @example
     * // Delete one Causeofinjuryside
     * const Causeofinjuryside = await prisma.causeofinjuryside.delete({
     *   where: {
     *     // ... filter to delete one Causeofinjuryside
     *   }
     * })
     * 
     */
    delete<T extends causeofinjurysideDeleteArgs>(args: SelectSubset<T, causeofinjurysideDeleteArgs<ExtArgs>>): Prisma__causeofinjurysideClient<$Result.GetResult<Prisma.$causeofinjurysidePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Causeofinjuryside.
     * @param {causeofinjurysideUpdateArgs} args - Arguments to update one Causeofinjuryside.
     * @example
     * // Update one Causeofinjuryside
     * const causeofinjuryside = await prisma.causeofinjuryside.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends causeofinjurysideUpdateArgs>(args: SelectSubset<T, causeofinjurysideUpdateArgs<ExtArgs>>): Prisma__causeofinjurysideClient<$Result.GetResult<Prisma.$causeofinjurysidePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Causeofinjurysides.
     * @param {causeofinjurysideDeleteManyArgs} args - Arguments to filter Causeofinjurysides to delete.
     * @example
     * // Delete a few Causeofinjurysides
     * const { count } = await prisma.causeofinjuryside.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends causeofinjurysideDeleteManyArgs>(args?: SelectSubset<T, causeofinjurysideDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Causeofinjurysides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {causeofinjurysideUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Causeofinjurysides
     * const causeofinjuryside = await prisma.causeofinjuryside.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends causeofinjurysideUpdateManyArgs>(args: SelectSubset<T, causeofinjurysideUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Causeofinjuryside.
     * @param {causeofinjurysideUpsertArgs} args - Arguments to update or create a Causeofinjuryside.
     * @example
     * // Update or create a Causeofinjuryside
     * const causeofinjuryside = await prisma.causeofinjuryside.upsert({
     *   create: {
     *     // ... data to create a Causeofinjuryside
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Causeofinjuryside we want to update
     *   }
     * })
     */
    upsert<T extends causeofinjurysideUpsertArgs>(args: SelectSubset<T, causeofinjurysideUpsertArgs<ExtArgs>>): Prisma__causeofinjurysideClient<$Result.GetResult<Prisma.$causeofinjurysidePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Causeofinjurysides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {causeofinjurysideCountArgs} args - Arguments to filter Causeofinjurysides to count.
     * @example
     * // Count the number of Causeofinjurysides
     * const count = await prisma.causeofinjuryside.count({
     *   where: {
     *     // ... the filter for the Causeofinjurysides we want to count
     *   }
     * })
    **/
    count<T extends causeofinjurysideCountArgs>(
      args?: Subset<T, causeofinjurysideCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CauseofinjurysideCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Causeofinjuryside.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CauseofinjurysideAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CauseofinjurysideAggregateArgs>(args: Subset<T, CauseofinjurysideAggregateArgs>): Prisma.PrismaPromise<GetCauseofinjurysideAggregateType<T>>

    /**
     * Group by Causeofinjuryside.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {causeofinjurysideGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends causeofinjurysideGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: causeofinjurysideGroupByArgs['orderBy'] }
        : { orderBy?: causeofinjurysideGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, causeofinjurysideGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCauseofinjurysideGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the causeofinjuryside model
   */
  readonly fields: causeofinjurysideFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for causeofinjuryside.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__causeofinjurysideClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    insurers<T extends causeofinjuryside$insurersArgs<ExtArgs> = {}>(args?: Subset<T, causeofinjuryside$insurersArgs<ExtArgs>>): Prisma__insurersClient<$Result.GetResult<Prisma.$insurersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the causeofinjuryside model
   */ 
  interface causeofinjurysideFieldRefs {
    readonly id: FieldRef<"causeofinjuryside", 'Int'>
    readonly injurysidename: FieldRef<"causeofinjuryside", 'String'>
    readonly injurysidecode: FieldRef<"causeofinjuryside", 'String'>
    readonly insurerid: FieldRef<"causeofinjuryside", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * causeofinjuryside findUnique
   */
  export type causeofinjurysideFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjuryside
     */
    select?: causeofinjurysideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurysideInclude<ExtArgs> | null
    /**
     * Filter, which causeofinjuryside to fetch.
     */
    where: causeofinjurysideWhereUniqueInput
  }

  /**
   * causeofinjuryside findUniqueOrThrow
   */
  export type causeofinjurysideFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjuryside
     */
    select?: causeofinjurysideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurysideInclude<ExtArgs> | null
    /**
     * Filter, which causeofinjuryside to fetch.
     */
    where: causeofinjurysideWhereUniqueInput
  }

  /**
   * causeofinjuryside findFirst
   */
  export type causeofinjurysideFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjuryside
     */
    select?: causeofinjurysideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurysideInclude<ExtArgs> | null
    /**
     * Filter, which causeofinjuryside to fetch.
     */
    where?: causeofinjurysideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of causeofinjurysides to fetch.
     */
    orderBy?: causeofinjurysideOrderByWithRelationInput | causeofinjurysideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for causeofinjurysides.
     */
    cursor?: causeofinjurysideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` causeofinjurysides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` causeofinjurysides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of causeofinjurysides.
     */
    distinct?: CauseofinjurysideScalarFieldEnum | CauseofinjurysideScalarFieldEnum[]
  }

  /**
   * causeofinjuryside findFirstOrThrow
   */
  export type causeofinjurysideFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjuryside
     */
    select?: causeofinjurysideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurysideInclude<ExtArgs> | null
    /**
     * Filter, which causeofinjuryside to fetch.
     */
    where?: causeofinjurysideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of causeofinjurysides to fetch.
     */
    orderBy?: causeofinjurysideOrderByWithRelationInput | causeofinjurysideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for causeofinjurysides.
     */
    cursor?: causeofinjurysideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` causeofinjurysides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` causeofinjurysides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of causeofinjurysides.
     */
    distinct?: CauseofinjurysideScalarFieldEnum | CauseofinjurysideScalarFieldEnum[]
  }

  /**
   * causeofinjuryside findMany
   */
  export type causeofinjurysideFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjuryside
     */
    select?: causeofinjurysideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurysideInclude<ExtArgs> | null
    /**
     * Filter, which causeofinjurysides to fetch.
     */
    where?: causeofinjurysideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of causeofinjurysides to fetch.
     */
    orderBy?: causeofinjurysideOrderByWithRelationInput | causeofinjurysideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing causeofinjurysides.
     */
    cursor?: causeofinjurysideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` causeofinjurysides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` causeofinjurysides.
     */
    skip?: number
    distinct?: CauseofinjurysideScalarFieldEnum | CauseofinjurysideScalarFieldEnum[]
  }

  /**
   * causeofinjuryside create
   */
  export type causeofinjurysideCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjuryside
     */
    select?: causeofinjurysideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurysideInclude<ExtArgs> | null
    /**
     * The data needed to create a causeofinjuryside.
     */
    data: XOR<causeofinjurysideCreateInput, causeofinjurysideUncheckedCreateInput>
  }

  /**
   * causeofinjuryside createMany
   */
  export type causeofinjurysideCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many causeofinjurysides.
     */
    data: causeofinjurysideCreateManyInput | causeofinjurysideCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * causeofinjuryside createManyAndReturn
   */
  export type causeofinjurysideCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjuryside
     */
    select?: causeofinjurysideSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many causeofinjurysides.
     */
    data: causeofinjurysideCreateManyInput | causeofinjurysideCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurysideIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * causeofinjuryside update
   */
  export type causeofinjurysideUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjuryside
     */
    select?: causeofinjurysideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurysideInclude<ExtArgs> | null
    /**
     * The data needed to update a causeofinjuryside.
     */
    data: XOR<causeofinjurysideUpdateInput, causeofinjurysideUncheckedUpdateInput>
    /**
     * Choose, which causeofinjuryside to update.
     */
    where: causeofinjurysideWhereUniqueInput
  }

  /**
   * causeofinjuryside updateMany
   */
  export type causeofinjurysideUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update causeofinjurysides.
     */
    data: XOR<causeofinjurysideUpdateManyMutationInput, causeofinjurysideUncheckedUpdateManyInput>
    /**
     * Filter which causeofinjurysides to update
     */
    where?: causeofinjurysideWhereInput
  }

  /**
   * causeofinjuryside upsert
   */
  export type causeofinjurysideUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjuryside
     */
    select?: causeofinjurysideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurysideInclude<ExtArgs> | null
    /**
     * The filter to search for the causeofinjuryside to update in case it exists.
     */
    where: causeofinjurysideWhereUniqueInput
    /**
     * In case the causeofinjuryside found by the `where` argument doesn't exist, create a new causeofinjuryside with this data.
     */
    create: XOR<causeofinjurysideCreateInput, causeofinjurysideUncheckedCreateInput>
    /**
     * In case the causeofinjuryside was found with the provided `where` argument, update it with this data.
     */
    update: XOR<causeofinjurysideUpdateInput, causeofinjurysideUncheckedUpdateInput>
  }

  /**
   * causeofinjuryside delete
   */
  export type causeofinjurysideDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjuryside
     */
    select?: causeofinjurysideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurysideInclude<ExtArgs> | null
    /**
     * Filter which causeofinjuryside to delete.
     */
    where: causeofinjurysideWhereUniqueInput
  }

  /**
   * causeofinjuryside deleteMany
   */
  export type causeofinjurysideDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which causeofinjurysides to delete
     */
    where?: causeofinjurysideWhereInput
  }

  /**
   * causeofinjuryside.insurers
   */
  export type causeofinjuryside$insurersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insurers
     */
    select?: insurersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: insurersInclude<ExtArgs> | null
    where?: insurersWhereInput
  }

  /**
   * causeofinjuryside without action
   */
  export type causeofinjurysideDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjuryside
     */
    select?: causeofinjurysideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurysideInclude<ExtArgs> | null
  }


  /**
   * Model causeofinjurywoundtype
   */

  export type AggregateCauseofinjurywoundtype = {
    _count: CauseofinjurywoundtypeCountAggregateOutputType | null
    _avg: CauseofinjurywoundtypeAvgAggregateOutputType | null
    _sum: CauseofinjurywoundtypeSumAggregateOutputType | null
    _min: CauseofinjurywoundtypeMinAggregateOutputType | null
    _max: CauseofinjurywoundtypeMaxAggregateOutputType | null
  }

  export type CauseofinjurywoundtypeAvgAggregateOutputType = {
    id: number | null
    insurerid: number | null
  }

  export type CauseofinjurywoundtypeSumAggregateOutputType = {
    id: number | null
    insurerid: number | null
  }

  export type CauseofinjurywoundtypeMinAggregateOutputType = {
    id: number | null
    woundtypename: string | null
    woundtypecode: string | null
    insurerid: number | null
  }

  export type CauseofinjurywoundtypeMaxAggregateOutputType = {
    id: number | null
    woundtypename: string | null
    woundtypecode: string | null
    insurerid: number | null
  }

  export type CauseofinjurywoundtypeCountAggregateOutputType = {
    id: number
    woundtypename: number
    woundtypecode: number
    insurerid: number
    _all: number
  }


  export type CauseofinjurywoundtypeAvgAggregateInputType = {
    id?: true
    insurerid?: true
  }

  export type CauseofinjurywoundtypeSumAggregateInputType = {
    id?: true
    insurerid?: true
  }

  export type CauseofinjurywoundtypeMinAggregateInputType = {
    id?: true
    woundtypename?: true
    woundtypecode?: true
    insurerid?: true
  }

  export type CauseofinjurywoundtypeMaxAggregateInputType = {
    id?: true
    woundtypename?: true
    woundtypecode?: true
    insurerid?: true
  }

  export type CauseofinjurywoundtypeCountAggregateInputType = {
    id?: true
    woundtypename?: true
    woundtypecode?: true
    insurerid?: true
    _all?: true
  }

  export type CauseofinjurywoundtypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which causeofinjurywoundtype to aggregate.
     */
    where?: causeofinjurywoundtypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of causeofinjurywoundtypes to fetch.
     */
    orderBy?: causeofinjurywoundtypeOrderByWithRelationInput | causeofinjurywoundtypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: causeofinjurywoundtypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` causeofinjurywoundtypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` causeofinjurywoundtypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned causeofinjurywoundtypes
    **/
    _count?: true | CauseofinjurywoundtypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CauseofinjurywoundtypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CauseofinjurywoundtypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CauseofinjurywoundtypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CauseofinjurywoundtypeMaxAggregateInputType
  }

  export type GetCauseofinjurywoundtypeAggregateType<T extends CauseofinjurywoundtypeAggregateArgs> = {
        [P in keyof T & keyof AggregateCauseofinjurywoundtype]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCauseofinjurywoundtype[P]>
      : GetScalarType<T[P], AggregateCauseofinjurywoundtype[P]>
  }




  export type causeofinjurywoundtypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: causeofinjurywoundtypeWhereInput
    orderBy?: causeofinjurywoundtypeOrderByWithAggregationInput | causeofinjurywoundtypeOrderByWithAggregationInput[]
    by: CauseofinjurywoundtypeScalarFieldEnum[] | CauseofinjurywoundtypeScalarFieldEnum
    having?: causeofinjurywoundtypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CauseofinjurywoundtypeCountAggregateInputType | true
    _avg?: CauseofinjurywoundtypeAvgAggregateInputType
    _sum?: CauseofinjurywoundtypeSumAggregateInputType
    _min?: CauseofinjurywoundtypeMinAggregateInputType
    _max?: CauseofinjurywoundtypeMaxAggregateInputType
  }

  export type CauseofinjurywoundtypeGroupByOutputType = {
    id: number
    woundtypename: string
    woundtypecode: string | null
    insurerid: number | null
    _count: CauseofinjurywoundtypeCountAggregateOutputType | null
    _avg: CauseofinjurywoundtypeAvgAggregateOutputType | null
    _sum: CauseofinjurywoundtypeSumAggregateOutputType | null
    _min: CauseofinjurywoundtypeMinAggregateOutputType | null
    _max: CauseofinjurywoundtypeMaxAggregateOutputType | null
  }

  type GetCauseofinjurywoundtypeGroupByPayload<T extends causeofinjurywoundtypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CauseofinjurywoundtypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CauseofinjurywoundtypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CauseofinjurywoundtypeGroupByOutputType[P]>
            : GetScalarType<T[P], CauseofinjurywoundtypeGroupByOutputType[P]>
        }
      >
    >


  export type causeofinjurywoundtypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    woundtypename?: boolean
    woundtypecode?: boolean
    insurerid?: boolean
    insurers?: boolean | causeofinjurywoundtype$insurersArgs<ExtArgs>
  }, ExtArgs["result"]["causeofinjurywoundtype"]>

  export type causeofinjurywoundtypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    woundtypename?: boolean
    woundtypecode?: boolean
    insurerid?: boolean
    insurers?: boolean | causeofinjurywoundtype$insurersArgs<ExtArgs>
  }, ExtArgs["result"]["causeofinjurywoundtype"]>

  export type causeofinjurywoundtypeSelectScalar = {
    id?: boolean
    woundtypename?: boolean
    woundtypecode?: boolean
    insurerid?: boolean
  }

  export type causeofinjurywoundtypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurers?: boolean | causeofinjurywoundtype$insurersArgs<ExtArgs>
  }
  export type causeofinjurywoundtypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurers?: boolean | causeofinjurywoundtype$insurersArgs<ExtArgs>
  }

  export type $causeofinjurywoundtypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "causeofinjurywoundtype"
    objects: {
      insurers: Prisma.$insurersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      woundtypename: string
      woundtypecode: string | null
      insurerid: number | null
    }, ExtArgs["result"]["causeofinjurywoundtype"]>
    composites: {}
  }

  type causeofinjurywoundtypeGetPayload<S extends boolean | null | undefined | causeofinjurywoundtypeDefaultArgs> = $Result.GetResult<Prisma.$causeofinjurywoundtypePayload, S>

  type causeofinjurywoundtypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<causeofinjurywoundtypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CauseofinjurywoundtypeCountAggregateInputType | true
    }

  export interface causeofinjurywoundtypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['causeofinjurywoundtype'], meta: { name: 'causeofinjurywoundtype' } }
    /**
     * Find zero or one Causeofinjurywoundtype that matches the filter.
     * @param {causeofinjurywoundtypeFindUniqueArgs} args - Arguments to find a Causeofinjurywoundtype
     * @example
     * // Get one Causeofinjurywoundtype
     * const causeofinjurywoundtype = await prisma.causeofinjurywoundtype.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends causeofinjurywoundtypeFindUniqueArgs>(args: SelectSubset<T, causeofinjurywoundtypeFindUniqueArgs<ExtArgs>>): Prisma__causeofinjurywoundtypeClient<$Result.GetResult<Prisma.$causeofinjurywoundtypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Causeofinjurywoundtype that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {causeofinjurywoundtypeFindUniqueOrThrowArgs} args - Arguments to find a Causeofinjurywoundtype
     * @example
     * // Get one Causeofinjurywoundtype
     * const causeofinjurywoundtype = await prisma.causeofinjurywoundtype.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends causeofinjurywoundtypeFindUniqueOrThrowArgs>(args: SelectSubset<T, causeofinjurywoundtypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__causeofinjurywoundtypeClient<$Result.GetResult<Prisma.$causeofinjurywoundtypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Causeofinjurywoundtype that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {causeofinjurywoundtypeFindFirstArgs} args - Arguments to find a Causeofinjurywoundtype
     * @example
     * // Get one Causeofinjurywoundtype
     * const causeofinjurywoundtype = await prisma.causeofinjurywoundtype.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends causeofinjurywoundtypeFindFirstArgs>(args?: SelectSubset<T, causeofinjurywoundtypeFindFirstArgs<ExtArgs>>): Prisma__causeofinjurywoundtypeClient<$Result.GetResult<Prisma.$causeofinjurywoundtypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Causeofinjurywoundtype that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {causeofinjurywoundtypeFindFirstOrThrowArgs} args - Arguments to find a Causeofinjurywoundtype
     * @example
     * // Get one Causeofinjurywoundtype
     * const causeofinjurywoundtype = await prisma.causeofinjurywoundtype.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends causeofinjurywoundtypeFindFirstOrThrowArgs>(args?: SelectSubset<T, causeofinjurywoundtypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__causeofinjurywoundtypeClient<$Result.GetResult<Prisma.$causeofinjurywoundtypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Causeofinjurywoundtypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {causeofinjurywoundtypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Causeofinjurywoundtypes
     * const causeofinjurywoundtypes = await prisma.causeofinjurywoundtype.findMany()
     * 
     * // Get first 10 Causeofinjurywoundtypes
     * const causeofinjurywoundtypes = await prisma.causeofinjurywoundtype.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const causeofinjurywoundtypeWithIdOnly = await prisma.causeofinjurywoundtype.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends causeofinjurywoundtypeFindManyArgs>(args?: SelectSubset<T, causeofinjurywoundtypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$causeofinjurywoundtypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Causeofinjurywoundtype.
     * @param {causeofinjurywoundtypeCreateArgs} args - Arguments to create a Causeofinjurywoundtype.
     * @example
     * // Create one Causeofinjurywoundtype
     * const Causeofinjurywoundtype = await prisma.causeofinjurywoundtype.create({
     *   data: {
     *     // ... data to create a Causeofinjurywoundtype
     *   }
     * })
     * 
     */
    create<T extends causeofinjurywoundtypeCreateArgs>(args: SelectSubset<T, causeofinjurywoundtypeCreateArgs<ExtArgs>>): Prisma__causeofinjurywoundtypeClient<$Result.GetResult<Prisma.$causeofinjurywoundtypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Causeofinjurywoundtypes.
     * @param {causeofinjurywoundtypeCreateManyArgs} args - Arguments to create many Causeofinjurywoundtypes.
     * @example
     * // Create many Causeofinjurywoundtypes
     * const causeofinjurywoundtype = await prisma.causeofinjurywoundtype.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends causeofinjurywoundtypeCreateManyArgs>(args?: SelectSubset<T, causeofinjurywoundtypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Causeofinjurywoundtypes and returns the data saved in the database.
     * @param {causeofinjurywoundtypeCreateManyAndReturnArgs} args - Arguments to create many Causeofinjurywoundtypes.
     * @example
     * // Create many Causeofinjurywoundtypes
     * const causeofinjurywoundtype = await prisma.causeofinjurywoundtype.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Causeofinjurywoundtypes and only return the `id`
     * const causeofinjurywoundtypeWithIdOnly = await prisma.causeofinjurywoundtype.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends causeofinjurywoundtypeCreateManyAndReturnArgs>(args?: SelectSubset<T, causeofinjurywoundtypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$causeofinjurywoundtypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Causeofinjurywoundtype.
     * @param {causeofinjurywoundtypeDeleteArgs} args - Arguments to delete one Causeofinjurywoundtype.
     * @example
     * // Delete one Causeofinjurywoundtype
     * const Causeofinjurywoundtype = await prisma.causeofinjurywoundtype.delete({
     *   where: {
     *     // ... filter to delete one Causeofinjurywoundtype
     *   }
     * })
     * 
     */
    delete<T extends causeofinjurywoundtypeDeleteArgs>(args: SelectSubset<T, causeofinjurywoundtypeDeleteArgs<ExtArgs>>): Prisma__causeofinjurywoundtypeClient<$Result.GetResult<Prisma.$causeofinjurywoundtypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Causeofinjurywoundtype.
     * @param {causeofinjurywoundtypeUpdateArgs} args - Arguments to update one Causeofinjurywoundtype.
     * @example
     * // Update one Causeofinjurywoundtype
     * const causeofinjurywoundtype = await prisma.causeofinjurywoundtype.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends causeofinjurywoundtypeUpdateArgs>(args: SelectSubset<T, causeofinjurywoundtypeUpdateArgs<ExtArgs>>): Prisma__causeofinjurywoundtypeClient<$Result.GetResult<Prisma.$causeofinjurywoundtypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Causeofinjurywoundtypes.
     * @param {causeofinjurywoundtypeDeleteManyArgs} args - Arguments to filter Causeofinjurywoundtypes to delete.
     * @example
     * // Delete a few Causeofinjurywoundtypes
     * const { count } = await prisma.causeofinjurywoundtype.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends causeofinjurywoundtypeDeleteManyArgs>(args?: SelectSubset<T, causeofinjurywoundtypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Causeofinjurywoundtypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {causeofinjurywoundtypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Causeofinjurywoundtypes
     * const causeofinjurywoundtype = await prisma.causeofinjurywoundtype.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends causeofinjurywoundtypeUpdateManyArgs>(args: SelectSubset<T, causeofinjurywoundtypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Causeofinjurywoundtype.
     * @param {causeofinjurywoundtypeUpsertArgs} args - Arguments to update or create a Causeofinjurywoundtype.
     * @example
     * // Update or create a Causeofinjurywoundtype
     * const causeofinjurywoundtype = await prisma.causeofinjurywoundtype.upsert({
     *   create: {
     *     // ... data to create a Causeofinjurywoundtype
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Causeofinjurywoundtype we want to update
     *   }
     * })
     */
    upsert<T extends causeofinjurywoundtypeUpsertArgs>(args: SelectSubset<T, causeofinjurywoundtypeUpsertArgs<ExtArgs>>): Prisma__causeofinjurywoundtypeClient<$Result.GetResult<Prisma.$causeofinjurywoundtypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Causeofinjurywoundtypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {causeofinjurywoundtypeCountArgs} args - Arguments to filter Causeofinjurywoundtypes to count.
     * @example
     * // Count the number of Causeofinjurywoundtypes
     * const count = await prisma.causeofinjurywoundtype.count({
     *   where: {
     *     // ... the filter for the Causeofinjurywoundtypes we want to count
     *   }
     * })
    **/
    count<T extends causeofinjurywoundtypeCountArgs>(
      args?: Subset<T, causeofinjurywoundtypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CauseofinjurywoundtypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Causeofinjurywoundtype.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CauseofinjurywoundtypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CauseofinjurywoundtypeAggregateArgs>(args: Subset<T, CauseofinjurywoundtypeAggregateArgs>): Prisma.PrismaPromise<GetCauseofinjurywoundtypeAggregateType<T>>

    /**
     * Group by Causeofinjurywoundtype.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {causeofinjurywoundtypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends causeofinjurywoundtypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: causeofinjurywoundtypeGroupByArgs['orderBy'] }
        : { orderBy?: causeofinjurywoundtypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, causeofinjurywoundtypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCauseofinjurywoundtypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the causeofinjurywoundtype model
   */
  readonly fields: causeofinjurywoundtypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for causeofinjurywoundtype.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__causeofinjurywoundtypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    insurers<T extends causeofinjurywoundtype$insurersArgs<ExtArgs> = {}>(args?: Subset<T, causeofinjurywoundtype$insurersArgs<ExtArgs>>): Prisma__insurersClient<$Result.GetResult<Prisma.$insurersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the causeofinjurywoundtype model
   */ 
  interface causeofinjurywoundtypeFieldRefs {
    readonly id: FieldRef<"causeofinjurywoundtype", 'Int'>
    readonly woundtypename: FieldRef<"causeofinjurywoundtype", 'String'>
    readonly woundtypecode: FieldRef<"causeofinjurywoundtype", 'String'>
    readonly insurerid: FieldRef<"causeofinjurywoundtype", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * causeofinjurywoundtype findUnique
   */
  export type causeofinjurywoundtypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjurywoundtype
     */
    select?: causeofinjurywoundtypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurywoundtypeInclude<ExtArgs> | null
    /**
     * Filter, which causeofinjurywoundtype to fetch.
     */
    where: causeofinjurywoundtypeWhereUniqueInput
  }

  /**
   * causeofinjurywoundtype findUniqueOrThrow
   */
  export type causeofinjurywoundtypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjurywoundtype
     */
    select?: causeofinjurywoundtypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurywoundtypeInclude<ExtArgs> | null
    /**
     * Filter, which causeofinjurywoundtype to fetch.
     */
    where: causeofinjurywoundtypeWhereUniqueInput
  }

  /**
   * causeofinjurywoundtype findFirst
   */
  export type causeofinjurywoundtypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjurywoundtype
     */
    select?: causeofinjurywoundtypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurywoundtypeInclude<ExtArgs> | null
    /**
     * Filter, which causeofinjurywoundtype to fetch.
     */
    where?: causeofinjurywoundtypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of causeofinjurywoundtypes to fetch.
     */
    orderBy?: causeofinjurywoundtypeOrderByWithRelationInput | causeofinjurywoundtypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for causeofinjurywoundtypes.
     */
    cursor?: causeofinjurywoundtypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` causeofinjurywoundtypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` causeofinjurywoundtypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of causeofinjurywoundtypes.
     */
    distinct?: CauseofinjurywoundtypeScalarFieldEnum | CauseofinjurywoundtypeScalarFieldEnum[]
  }

  /**
   * causeofinjurywoundtype findFirstOrThrow
   */
  export type causeofinjurywoundtypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjurywoundtype
     */
    select?: causeofinjurywoundtypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurywoundtypeInclude<ExtArgs> | null
    /**
     * Filter, which causeofinjurywoundtype to fetch.
     */
    where?: causeofinjurywoundtypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of causeofinjurywoundtypes to fetch.
     */
    orderBy?: causeofinjurywoundtypeOrderByWithRelationInput | causeofinjurywoundtypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for causeofinjurywoundtypes.
     */
    cursor?: causeofinjurywoundtypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` causeofinjurywoundtypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` causeofinjurywoundtypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of causeofinjurywoundtypes.
     */
    distinct?: CauseofinjurywoundtypeScalarFieldEnum | CauseofinjurywoundtypeScalarFieldEnum[]
  }

  /**
   * causeofinjurywoundtype findMany
   */
  export type causeofinjurywoundtypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjurywoundtype
     */
    select?: causeofinjurywoundtypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurywoundtypeInclude<ExtArgs> | null
    /**
     * Filter, which causeofinjurywoundtypes to fetch.
     */
    where?: causeofinjurywoundtypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of causeofinjurywoundtypes to fetch.
     */
    orderBy?: causeofinjurywoundtypeOrderByWithRelationInput | causeofinjurywoundtypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing causeofinjurywoundtypes.
     */
    cursor?: causeofinjurywoundtypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` causeofinjurywoundtypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` causeofinjurywoundtypes.
     */
    skip?: number
    distinct?: CauseofinjurywoundtypeScalarFieldEnum | CauseofinjurywoundtypeScalarFieldEnum[]
  }

  /**
   * causeofinjurywoundtype create
   */
  export type causeofinjurywoundtypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjurywoundtype
     */
    select?: causeofinjurywoundtypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurywoundtypeInclude<ExtArgs> | null
    /**
     * The data needed to create a causeofinjurywoundtype.
     */
    data: XOR<causeofinjurywoundtypeCreateInput, causeofinjurywoundtypeUncheckedCreateInput>
  }

  /**
   * causeofinjurywoundtype createMany
   */
  export type causeofinjurywoundtypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many causeofinjurywoundtypes.
     */
    data: causeofinjurywoundtypeCreateManyInput | causeofinjurywoundtypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * causeofinjurywoundtype createManyAndReturn
   */
  export type causeofinjurywoundtypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjurywoundtype
     */
    select?: causeofinjurywoundtypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many causeofinjurywoundtypes.
     */
    data: causeofinjurywoundtypeCreateManyInput | causeofinjurywoundtypeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurywoundtypeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * causeofinjurywoundtype update
   */
  export type causeofinjurywoundtypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjurywoundtype
     */
    select?: causeofinjurywoundtypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurywoundtypeInclude<ExtArgs> | null
    /**
     * The data needed to update a causeofinjurywoundtype.
     */
    data: XOR<causeofinjurywoundtypeUpdateInput, causeofinjurywoundtypeUncheckedUpdateInput>
    /**
     * Choose, which causeofinjurywoundtype to update.
     */
    where: causeofinjurywoundtypeWhereUniqueInput
  }

  /**
   * causeofinjurywoundtype updateMany
   */
  export type causeofinjurywoundtypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update causeofinjurywoundtypes.
     */
    data: XOR<causeofinjurywoundtypeUpdateManyMutationInput, causeofinjurywoundtypeUncheckedUpdateManyInput>
    /**
     * Filter which causeofinjurywoundtypes to update
     */
    where?: causeofinjurywoundtypeWhereInput
  }

  /**
   * causeofinjurywoundtype upsert
   */
  export type causeofinjurywoundtypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjurywoundtype
     */
    select?: causeofinjurywoundtypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurywoundtypeInclude<ExtArgs> | null
    /**
     * The filter to search for the causeofinjurywoundtype to update in case it exists.
     */
    where: causeofinjurywoundtypeWhereUniqueInput
    /**
     * In case the causeofinjurywoundtype found by the `where` argument doesn't exist, create a new causeofinjurywoundtype with this data.
     */
    create: XOR<causeofinjurywoundtypeCreateInput, causeofinjurywoundtypeUncheckedCreateInput>
    /**
     * In case the causeofinjurywoundtype was found with the provided `where` argument, update it with this data.
     */
    update: XOR<causeofinjurywoundtypeUpdateInput, causeofinjurywoundtypeUncheckedUpdateInput>
  }

  /**
   * causeofinjurywoundtype delete
   */
  export type causeofinjurywoundtypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjurywoundtype
     */
    select?: causeofinjurywoundtypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurywoundtypeInclude<ExtArgs> | null
    /**
     * Filter which causeofinjurywoundtype to delete.
     */
    where: causeofinjurywoundtypeWhereUniqueInput
  }

  /**
   * causeofinjurywoundtype deleteMany
   */
  export type causeofinjurywoundtypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which causeofinjurywoundtypes to delete
     */
    where?: causeofinjurywoundtypeWhereInput
  }

  /**
   * causeofinjurywoundtype.insurers
   */
  export type causeofinjurywoundtype$insurersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insurers
     */
    select?: insurersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: insurersInclude<ExtArgs> | null
    where?: insurersWhereInput
  }

  /**
   * causeofinjurywoundtype without action
   */
  export type causeofinjurywoundtypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjurywoundtype
     */
    select?: causeofinjurywoundtypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurywoundtypeInclude<ExtArgs> | null
  }


  /**
   * Model claimants
   */

  export type AggregateClaimants = {
    _count: ClaimantsCountAggregateOutputType | null
    _avg: ClaimantsAvgAggregateOutputType | null
    _sum: ClaimantsSumAggregateOutputType | null
    _min: ClaimantsMinAggregateOutputType | null
    _max: ClaimantsMaxAggregateOutputType | null
  }

  export type ClaimantsAvgAggregateOutputType = {
    id: number | null
    patientid: number | null
    insurerid: number | null
  }

  export type ClaimantsSumAggregateOutputType = {
    id: number | null
    patientid: number | null
    insurerid: number | null
  }

  export type ClaimantsMinAggregateOutputType = {
    id: number | null
    national_id: string | null
    passportnumber: string | null
    hn: string | null
    patientid: number | null
    title_th: string | null
    givenname_th: string | null
    surname_th: string | null
    title_en: string | null
    givenname_en: string | null
    surname_en: string | null
    mobilephone: string | null
    statusactive: boolean | null
    dateofbirth: string | null
    gender: string | null
    registrationdate: Date | null
    insurerid: number | null
  }

  export type ClaimantsMaxAggregateOutputType = {
    id: number | null
    national_id: string | null
    passportnumber: string | null
    hn: string | null
    patientid: number | null
    title_th: string | null
    givenname_th: string | null
    surname_th: string | null
    title_en: string | null
    givenname_en: string | null
    surname_en: string | null
    mobilephone: string | null
    statusactive: boolean | null
    dateofbirth: string | null
    gender: string | null
    registrationdate: Date | null
    insurerid: number | null
  }

  export type ClaimantsCountAggregateOutputType = {
    id: number
    national_id: number
    passportnumber: number
    hn: number
    patientid: number
    title_th: number
    givenname_th: number
    surname_th: number
    title_en: number
    givenname_en: number
    surname_en: number
    mobilephone: number
    statusactive: number
    dateofbirth: number
    gender: number
    registrationdate: number
    insurerid: number
    _all: number
  }


  export type ClaimantsAvgAggregateInputType = {
    id?: true
    patientid?: true
    insurerid?: true
  }

  export type ClaimantsSumAggregateInputType = {
    id?: true
    patientid?: true
    insurerid?: true
  }

  export type ClaimantsMinAggregateInputType = {
    id?: true
    national_id?: true
    passportnumber?: true
    hn?: true
    patientid?: true
    title_th?: true
    givenname_th?: true
    surname_th?: true
    title_en?: true
    givenname_en?: true
    surname_en?: true
    mobilephone?: true
    statusactive?: true
    dateofbirth?: true
    gender?: true
    registrationdate?: true
    insurerid?: true
  }

  export type ClaimantsMaxAggregateInputType = {
    id?: true
    national_id?: true
    passportnumber?: true
    hn?: true
    patientid?: true
    title_th?: true
    givenname_th?: true
    surname_th?: true
    title_en?: true
    givenname_en?: true
    surname_en?: true
    mobilephone?: true
    statusactive?: true
    dateofbirth?: true
    gender?: true
    registrationdate?: true
    insurerid?: true
  }

  export type ClaimantsCountAggregateInputType = {
    id?: true
    national_id?: true
    passportnumber?: true
    hn?: true
    patientid?: true
    title_th?: true
    givenname_th?: true
    surname_th?: true
    title_en?: true
    givenname_en?: true
    surname_en?: true
    mobilephone?: true
    statusactive?: true
    dateofbirth?: true
    gender?: true
    registrationdate?: true
    insurerid?: true
    _all?: true
  }

  export type ClaimantsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which claimants to aggregate.
     */
    where?: claimantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of claimants to fetch.
     */
    orderBy?: claimantsOrderByWithRelationInput | claimantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: claimantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` claimants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` claimants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned claimants
    **/
    _count?: true | ClaimantsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClaimantsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClaimantsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClaimantsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClaimantsMaxAggregateInputType
  }

  export type GetClaimantsAggregateType<T extends ClaimantsAggregateArgs> = {
        [P in keyof T & keyof AggregateClaimants]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClaimants[P]>
      : GetScalarType<T[P], AggregateClaimants[P]>
  }




  export type claimantsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: claimantsWhereInput
    orderBy?: claimantsOrderByWithAggregationInput | claimantsOrderByWithAggregationInput[]
    by: ClaimantsScalarFieldEnum[] | ClaimantsScalarFieldEnum
    having?: claimantsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClaimantsCountAggregateInputType | true
    _avg?: ClaimantsAvgAggregateInputType
    _sum?: ClaimantsSumAggregateInputType
    _min?: ClaimantsMinAggregateInputType
    _max?: ClaimantsMaxAggregateInputType
  }

  export type ClaimantsGroupByOutputType = {
    id: number
    national_id: string | null
    passportnumber: string | null
    hn: string | null
    patientid: number | null
    title_th: string | null
    givenname_th: string | null
    surname_th: string | null
    title_en: string | null
    givenname_en: string | null
    surname_en: string | null
    mobilephone: string | null
    statusactive: boolean | null
    dateofbirth: string | null
    gender: string | null
    registrationdate: Date | null
    insurerid: number | null
    _count: ClaimantsCountAggregateOutputType | null
    _avg: ClaimantsAvgAggregateOutputType | null
    _sum: ClaimantsSumAggregateOutputType | null
    _min: ClaimantsMinAggregateOutputType | null
    _max: ClaimantsMaxAggregateOutputType | null
  }

  type GetClaimantsGroupByPayload<T extends claimantsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClaimantsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClaimantsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClaimantsGroupByOutputType[P]>
            : GetScalarType<T[P], ClaimantsGroupByOutputType[P]>
        }
      >
    >


  export type claimantsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    national_id?: boolean
    passportnumber?: boolean
    hn?: boolean
    patientid?: boolean
    title_th?: boolean
    givenname_th?: boolean
    surname_th?: boolean
    title_en?: boolean
    givenname_en?: boolean
    surname_en?: boolean
    mobilephone?: boolean
    statusactive?: boolean
    dateofbirth?: boolean
    gender?: boolean
    registrationdate?: boolean
    insurerid?: boolean
    insurers?: boolean | claimants$insurersArgs<ExtArgs>
  }, ExtArgs["result"]["claimants"]>

  export type claimantsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    national_id?: boolean
    passportnumber?: boolean
    hn?: boolean
    patientid?: boolean
    title_th?: boolean
    givenname_th?: boolean
    surname_th?: boolean
    title_en?: boolean
    givenname_en?: boolean
    surname_en?: boolean
    mobilephone?: boolean
    statusactive?: boolean
    dateofbirth?: boolean
    gender?: boolean
    registrationdate?: boolean
    insurerid?: boolean
    insurers?: boolean | claimants$insurersArgs<ExtArgs>
  }, ExtArgs["result"]["claimants"]>

  export type claimantsSelectScalar = {
    id?: boolean
    national_id?: boolean
    passportnumber?: boolean
    hn?: boolean
    patientid?: boolean
    title_th?: boolean
    givenname_th?: boolean
    surname_th?: boolean
    title_en?: boolean
    givenname_en?: boolean
    surname_en?: boolean
    mobilephone?: boolean
    statusactive?: boolean
    dateofbirth?: boolean
    gender?: boolean
    registrationdate?: boolean
    insurerid?: boolean
  }

  export type claimantsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurers?: boolean | claimants$insurersArgs<ExtArgs>
  }
  export type claimantsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurers?: boolean | claimants$insurersArgs<ExtArgs>
  }

  export type $claimantsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "claimants"
    objects: {
      insurers: Prisma.$insurersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      national_id: string | null
      passportnumber: string | null
      hn: string | null
      patientid: number | null
      title_th: string | null
      givenname_th: string | null
      surname_th: string | null
      title_en: string | null
      givenname_en: string | null
      surname_en: string | null
      mobilephone: string | null
      statusactive: boolean | null
      dateofbirth: string | null
      gender: string | null
      registrationdate: Date | null
      insurerid: number | null
    }, ExtArgs["result"]["claimants"]>
    composites: {}
  }

  type claimantsGetPayload<S extends boolean | null | undefined | claimantsDefaultArgs> = $Result.GetResult<Prisma.$claimantsPayload, S>

  type claimantsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<claimantsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClaimantsCountAggregateInputType | true
    }

  export interface claimantsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['claimants'], meta: { name: 'claimants' } }
    /**
     * Find zero or one Claimants that matches the filter.
     * @param {claimantsFindUniqueArgs} args - Arguments to find a Claimants
     * @example
     * // Get one Claimants
     * const claimants = await prisma.claimants.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends claimantsFindUniqueArgs>(args: SelectSubset<T, claimantsFindUniqueArgs<ExtArgs>>): Prisma__claimantsClient<$Result.GetResult<Prisma.$claimantsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Claimants that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {claimantsFindUniqueOrThrowArgs} args - Arguments to find a Claimants
     * @example
     * // Get one Claimants
     * const claimants = await prisma.claimants.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends claimantsFindUniqueOrThrowArgs>(args: SelectSubset<T, claimantsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__claimantsClient<$Result.GetResult<Prisma.$claimantsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Claimants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {claimantsFindFirstArgs} args - Arguments to find a Claimants
     * @example
     * // Get one Claimants
     * const claimants = await prisma.claimants.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends claimantsFindFirstArgs>(args?: SelectSubset<T, claimantsFindFirstArgs<ExtArgs>>): Prisma__claimantsClient<$Result.GetResult<Prisma.$claimantsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Claimants that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {claimantsFindFirstOrThrowArgs} args - Arguments to find a Claimants
     * @example
     * // Get one Claimants
     * const claimants = await prisma.claimants.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends claimantsFindFirstOrThrowArgs>(args?: SelectSubset<T, claimantsFindFirstOrThrowArgs<ExtArgs>>): Prisma__claimantsClient<$Result.GetResult<Prisma.$claimantsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Claimants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {claimantsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Claimants
     * const claimants = await prisma.claimants.findMany()
     * 
     * // Get first 10 Claimants
     * const claimants = await prisma.claimants.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const claimantsWithIdOnly = await prisma.claimants.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends claimantsFindManyArgs>(args?: SelectSubset<T, claimantsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$claimantsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Claimants.
     * @param {claimantsCreateArgs} args - Arguments to create a Claimants.
     * @example
     * // Create one Claimants
     * const Claimants = await prisma.claimants.create({
     *   data: {
     *     // ... data to create a Claimants
     *   }
     * })
     * 
     */
    create<T extends claimantsCreateArgs>(args: SelectSubset<T, claimantsCreateArgs<ExtArgs>>): Prisma__claimantsClient<$Result.GetResult<Prisma.$claimantsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Claimants.
     * @param {claimantsCreateManyArgs} args - Arguments to create many Claimants.
     * @example
     * // Create many Claimants
     * const claimants = await prisma.claimants.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends claimantsCreateManyArgs>(args?: SelectSubset<T, claimantsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Claimants and returns the data saved in the database.
     * @param {claimantsCreateManyAndReturnArgs} args - Arguments to create many Claimants.
     * @example
     * // Create many Claimants
     * const claimants = await prisma.claimants.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Claimants and only return the `id`
     * const claimantsWithIdOnly = await prisma.claimants.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends claimantsCreateManyAndReturnArgs>(args?: SelectSubset<T, claimantsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$claimantsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Claimants.
     * @param {claimantsDeleteArgs} args - Arguments to delete one Claimants.
     * @example
     * // Delete one Claimants
     * const Claimants = await prisma.claimants.delete({
     *   where: {
     *     // ... filter to delete one Claimants
     *   }
     * })
     * 
     */
    delete<T extends claimantsDeleteArgs>(args: SelectSubset<T, claimantsDeleteArgs<ExtArgs>>): Prisma__claimantsClient<$Result.GetResult<Prisma.$claimantsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Claimants.
     * @param {claimantsUpdateArgs} args - Arguments to update one Claimants.
     * @example
     * // Update one Claimants
     * const claimants = await prisma.claimants.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends claimantsUpdateArgs>(args: SelectSubset<T, claimantsUpdateArgs<ExtArgs>>): Prisma__claimantsClient<$Result.GetResult<Prisma.$claimantsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Claimants.
     * @param {claimantsDeleteManyArgs} args - Arguments to filter Claimants to delete.
     * @example
     * // Delete a few Claimants
     * const { count } = await prisma.claimants.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends claimantsDeleteManyArgs>(args?: SelectSubset<T, claimantsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Claimants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {claimantsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Claimants
     * const claimants = await prisma.claimants.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends claimantsUpdateManyArgs>(args: SelectSubset<T, claimantsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Claimants.
     * @param {claimantsUpsertArgs} args - Arguments to update or create a Claimants.
     * @example
     * // Update or create a Claimants
     * const claimants = await prisma.claimants.upsert({
     *   create: {
     *     // ... data to create a Claimants
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Claimants we want to update
     *   }
     * })
     */
    upsert<T extends claimantsUpsertArgs>(args: SelectSubset<T, claimantsUpsertArgs<ExtArgs>>): Prisma__claimantsClient<$Result.GetResult<Prisma.$claimantsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Claimants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {claimantsCountArgs} args - Arguments to filter Claimants to count.
     * @example
     * // Count the number of Claimants
     * const count = await prisma.claimants.count({
     *   where: {
     *     // ... the filter for the Claimants we want to count
     *   }
     * })
    **/
    count<T extends claimantsCountArgs>(
      args?: Subset<T, claimantsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClaimantsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Claimants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimantsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClaimantsAggregateArgs>(args: Subset<T, ClaimantsAggregateArgs>): Prisma.PrismaPromise<GetClaimantsAggregateType<T>>

    /**
     * Group by Claimants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {claimantsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends claimantsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: claimantsGroupByArgs['orderBy'] }
        : { orderBy?: claimantsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, claimantsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClaimantsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the claimants model
   */
  readonly fields: claimantsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for claimants.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__claimantsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    insurers<T extends claimants$insurersArgs<ExtArgs> = {}>(args?: Subset<T, claimants$insurersArgs<ExtArgs>>): Prisma__insurersClient<$Result.GetResult<Prisma.$insurersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the claimants model
   */ 
  interface claimantsFieldRefs {
    readonly id: FieldRef<"claimants", 'Int'>
    readonly national_id: FieldRef<"claimants", 'String'>
    readonly passportnumber: FieldRef<"claimants", 'String'>
    readonly hn: FieldRef<"claimants", 'String'>
    readonly patientid: FieldRef<"claimants", 'Int'>
    readonly title_th: FieldRef<"claimants", 'String'>
    readonly givenname_th: FieldRef<"claimants", 'String'>
    readonly surname_th: FieldRef<"claimants", 'String'>
    readonly title_en: FieldRef<"claimants", 'String'>
    readonly givenname_en: FieldRef<"claimants", 'String'>
    readonly surname_en: FieldRef<"claimants", 'String'>
    readonly mobilephone: FieldRef<"claimants", 'String'>
    readonly statusactive: FieldRef<"claimants", 'Boolean'>
    readonly dateofbirth: FieldRef<"claimants", 'String'>
    readonly gender: FieldRef<"claimants", 'String'>
    readonly registrationdate: FieldRef<"claimants", 'DateTime'>
    readonly insurerid: FieldRef<"claimants", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * claimants findUnique
   */
  export type claimantsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimants
     */
    select?: claimantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimantsInclude<ExtArgs> | null
    /**
     * Filter, which claimants to fetch.
     */
    where: claimantsWhereUniqueInput
  }

  /**
   * claimants findUniqueOrThrow
   */
  export type claimantsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimants
     */
    select?: claimantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimantsInclude<ExtArgs> | null
    /**
     * Filter, which claimants to fetch.
     */
    where: claimantsWhereUniqueInput
  }

  /**
   * claimants findFirst
   */
  export type claimantsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimants
     */
    select?: claimantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimantsInclude<ExtArgs> | null
    /**
     * Filter, which claimants to fetch.
     */
    where?: claimantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of claimants to fetch.
     */
    orderBy?: claimantsOrderByWithRelationInput | claimantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for claimants.
     */
    cursor?: claimantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` claimants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` claimants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of claimants.
     */
    distinct?: ClaimantsScalarFieldEnum | ClaimantsScalarFieldEnum[]
  }

  /**
   * claimants findFirstOrThrow
   */
  export type claimantsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimants
     */
    select?: claimantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimantsInclude<ExtArgs> | null
    /**
     * Filter, which claimants to fetch.
     */
    where?: claimantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of claimants to fetch.
     */
    orderBy?: claimantsOrderByWithRelationInput | claimantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for claimants.
     */
    cursor?: claimantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` claimants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` claimants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of claimants.
     */
    distinct?: ClaimantsScalarFieldEnum | ClaimantsScalarFieldEnum[]
  }

  /**
   * claimants findMany
   */
  export type claimantsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimants
     */
    select?: claimantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimantsInclude<ExtArgs> | null
    /**
     * Filter, which claimants to fetch.
     */
    where?: claimantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of claimants to fetch.
     */
    orderBy?: claimantsOrderByWithRelationInput | claimantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing claimants.
     */
    cursor?: claimantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` claimants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` claimants.
     */
    skip?: number
    distinct?: ClaimantsScalarFieldEnum | ClaimantsScalarFieldEnum[]
  }

  /**
   * claimants create
   */
  export type claimantsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimants
     */
    select?: claimantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimantsInclude<ExtArgs> | null
    /**
     * The data needed to create a claimants.
     */
    data?: XOR<claimantsCreateInput, claimantsUncheckedCreateInput>
  }

  /**
   * claimants createMany
   */
  export type claimantsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many claimants.
     */
    data: claimantsCreateManyInput | claimantsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * claimants createManyAndReturn
   */
  export type claimantsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimants
     */
    select?: claimantsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many claimants.
     */
    data: claimantsCreateManyInput | claimantsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimantsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * claimants update
   */
  export type claimantsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimants
     */
    select?: claimantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimantsInclude<ExtArgs> | null
    /**
     * The data needed to update a claimants.
     */
    data: XOR<claimantsUpdateInput, claimantsUncheckedUpdateInput>
    /**
     * Choose, which claimants to update.
     */
    where: claimantsWhereUniqueInput
  }

  /**
   * claimants updateMany
   */
  export type claimantsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update claimants.
     */
    data: XOR<claimantsUpdateManyMutationInput, claimantsUncheckedUpdateManyInput>
    /**
     * Filter which claimants to update
     */
    where?: claimantsWhereInput
  }

  /**
   * claimants upsert
   */
  export type claimantsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimants
     */
    select?: claimantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimantsInclude<ExtArgs> | null
    /**
     * The filter to search for the claimants to update in case it exists.
     */
    where: claimantsWhereUniqueInput
    /**
     * In case the claimants found by the `where` argument doesn't exist, create a new claimants with this data.
     */
    create: XOR<claimantsCreateInput, claimantsUncheckedCreateInput>
    /**
     * In case the claimants was found with the provided `where` argument, update it with this data.
     */
    update: XOR<claimantsUpdateInput, claimantsUncheckedUpdateInput>
  }

  /**
   * claimants delete
   */
  export type claimantsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimants
     */
    select?: claimantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimantsInclude<ExtArgs> | null
    /**
     * Filter which claimants to delete.
     */
    where: claimantsWhereUniqueInput
  }

  /**
   * claimants deleteMany
   */
  export type claimantsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which claimants to delete
     */
    where?: claimantsWhereInput
  }

  /**
   * claimants.insurers
   */
  export type claimants$insurersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insurers
     */
    select?: insurersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: insurersInclude<ExtArgs> | null
    where?: insurersWhereInput
  }

  /**
   * claimants without action
   */
  export type claimantsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimants
     */
    select?: claimantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimantsInclude<ExtArgs> | null
  }


  /**
   * Model claimdocuments
   */

  export type AggregateClaimdocuments = {
    _count: ClaimdocumentsCountAggregateOutputType | null
    _avg: ClaimdocumentsAvgAggregateOutputType | null
    _sum: ClaimdocumentsSumAggregateOutputType | null
    _min: ClaimdocumentsMinAggregateOutputType | null
    _max: ClaimdocumentsMaxAggregateOutputType | null
  }

  export type ClaimdocumentsAvgAggregateOutputType = {
    id: number | null
    insurerid: number | null
    filesize: number | null
  }

  export type ClaimdocumentsSumAggregateOutputType = {
    id: number | null
    insurerid: number | null
    filesize: bigint | null
  }

  export type ClaimdocumentsMinAggregateOutputType = {
    id: number | null
    insurerid: number | null
    refid: string | null
    transactionno: string | null
    hn: string | null
    vn: string | null
    documentname: string | null
    documenttypecode: string | null
    documenttypename: string | null
    serverpath: string | null
    filepath: string | null
    filesize: bigint | null
    filemimetype: string | null
    uploaddate: Date | null
    uploadedby: string | null
  }

  export type ClaimdocumentsMaxAggregateOutputType = {
    id: number | null
    insurerid: number | null
    refid: string | null
    transactionno: string | null
    hn: string | null
    vn: string | null
    documentname: string | null
    documenttypecode: string | null
    documenttypename: string | null
    serverpath: string | null
    filepath: string | null
    filesize: bigint | null
    filemimetype: string | null
    uploaddate: Date | null
    uploadedby: string | null
  }

  export type ClaimdocumentsCountAggregateOutputType = {
    id: number
    insurerid: number
    refid: number
    transactionno: number
    hn: number
    vn: number
    documentname: number
    documenttypecode: number
    documenttypename: number
    serverpath: number
    filepath: number
    filesize: number
    filemimetype: number
    uploaddate: number
    uploadedby: number
    _all: number
  }


  export type ClaimdocumentsAvgAggregateInputType = {
    id?: true
    insurerid?: true
    filesize?: true
  }

  export type ClaimdocumentsSumAggregateInputType = {
    id?: true
    insurerid?: true
    filesize?: true
  }

  export type ClaimdocumentsMinAggregateInputType = {
    id?: true
    insurerid?: true
    refid?: true
    transactionno?: true
    hn?: true
    vn?: true
    documentname?: true
    documenttypecode?: true
    documenttypename?: true
    serverpath?: true
    filepath?: true
    filesize?: true
    filemimetype?: true
    uploaddate?: true
    uploadedby?: true
  }

  export type ClaimdocumentsMaxAggregateInputType = {
    id?: true
    insurerid?: true
    refid?: true
    transactionno?: true
    hn?: true
    vn?: true
    documentname?: true
    documenttypecode?: true
    documenttypename?: true
    serverpath?: true
    filepath?: true
    filesize?: true
    filemimetype?: true
    uploaddate?: true
    uploadedby?: true
  }

  export type ClaimdocumentsCountAggregateInputType = {
    id?: true
    insurerid?: true
    refid?: true
    transactionno?: true
    hn?: true
    vn?: true
    documentname?: true
    documenttypecode?: true
    documenttypename?: true
    serverpath?: true
    filepath?: true
    filesize?: true
    filemimetype?: true
    uploaddate?: true
    uploadedby?: true
    _all?: true
  }

  export type ClaimdocumentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which claimdocuments to aggregate.
     */
    where?: claimdocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of claimdocuments to fetch.
     */
    orderBy?: claimdocumentsOrderByWithRelationInput | claimdocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: claimdocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` claimdocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` claimdocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned claimdocuments
    **/
    _count?: true | ClaimdocumentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClaimdocumentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClaimdocumentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClaimdocumentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClaimdocumentsMaxAggregateInputType
  }

  export type GetClaimdocumentsAggregateType<T extends ClaimdocumentsAggregateArgs> = {
        [P in keyof T & keyof AggregateClaimdocuments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClaimdocuments[P]>
      : GetScalarType<T[P], AggregateClaimdocuments[P]>
  }




  export type claimdocumentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: claimdocumentsWhereInput
    orderBy?: claimdocumentsOrderByWithAggregationInput | claimdocumentsOrderByWithAggregationInput[]
    by: ClaimdocumentsScalarFieldEnum[] | ClaimdocumentsScalarFieldEnum
    having?: claimdocumentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClaimdocumentsCountAggregateInputType | true
    _avg?: ClaimdocumentsAvgAggregateInputType
    _sum?: ClaimdocumentsSumAggregateInputType
    _min?: ClaimdocumentsMinAggregateInputType
    _max?: ClaimdocumentsMaxAggregateInputType
  }

  export type ClaimdocumentsGroupByOutputType = {
    id: number
    insurerid: number | null
    refid: string | null
    transactionno: string | null
    hn: string | null
    vn: string | null
    documentname: string | null
    documenttypecode: string | null
    documenttypename: string | null
    serverpath: string | null
    filepath: string
    filesize: bigint | null
    filemimetype: string | null
    uploaddate: Date | null
    uploadedby: string | null
    _count: ClaimdocumentsCountAggregateOutputType | null
    _avg: ClaimdocumentsAvgAggregateOutputType | null
    _sum: ClaimdocumentsSumAggregateOutputType | null
    _min: ClaimdocumentsMinAggregateOutputType | null
    _max: ClaimdocumentsMaxAggregateOutputType | null
  }

  type GetClaimdocumentsGroupByPayload<T extends claimdocumentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClaimdocumentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClaimdocumentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClaimdocumentsGroupByOutputType[P]>
            : GetScalarType<T[P], ClaimdocumentsGroupByOutputType[P]>
        }
      >
    >


  export type claimdocumentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insurerid?: boolean
    refid?: boolean
    transactionno?: boolean
    hn?: boolean
    vn?: boolean
    documentname?: boolean
    documenttypecode?: boolean
    documenttypename?: boolean
    serverpath?: boolean
    filepath?: boolean
    filesize?: boolean
    filemimetype?: boolean
    uploaddate?: boolean
    uploadedby?: boolean
    insurers?: boolean | claimdocuments$insurersArgs<ExtArgs>
  }, ExtArgs["result"]["claimdocuments"]>

  export type claimdocumentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insurerid?: boolean
    refid?: boolean
    transactionno?: boolean
    hn?: boolean
    vn?: boolean
    documentname?: boolean
    documenttypecode?: boolean
    documenttypename?: boolean
    serverpath?: boolean
    filepath?: boolean
    filesize?: boolean
    filemimetype?: boolean
    uploaddate?: boolean
    uploadedby?: boolean
    insurers?: boolean | claimdocuments$insurersArgs<ExtArgs>
  }, ExtArgs["result"]["claimdocuments"]>

  export type claimdocumentsSelectScalar = {
    id?: boolean
    insurerid?: boolean
    refid?: boolean
    transactionno?: boolean
    hn?: boolean
    vn?: boolean
    documentname?: boolean
    documenttypecode?: boolean
    documenttypename?: boolean
    serverpath?: boolean
    filepath?: boolean
    filesize?: boolean
    filemimetype?: boolean
    uploaddate?: boolean
    uploadedby?: boolean
  }

  export type claimdocumentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurers?: boolean | claimdocuments$insurersArgs<ExtArgs>
  }
  export type claimdocumentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurers?: boolean | claimdocuments$insurersArgs<ExtArgs>
  }

  export type $claimdocumentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "claimdocuments"
    objects: {
      insurers: Prisma.$insurersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      insurerid: number | null
      refid: string | null
      transactionno: string | null
      hn: string | null
      vn: string | null
      documentname: string | null
      documenttypecode: string | null
      documenttypename: string | null
      serverpath: string | null
      filepath: string
      filesize: bigint | null
      filemimetype: string | null
      uploaddate: Date | null
      uploadedby: string | null
    }, ExtArgs["result"]["claimdocuments"]>
    composites: {}
  }

  type claimdocumentsGetPayload<S extends boolean | null | undefined | claimdocumentsDefaultArgs> = $Result.GetResult<Prisma.$claimdocumentsPayload, S>

  type claimdocumentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<claimdocumentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClaimdocumentsCountAggregateInputType | true
    }

  export interface claimdocumentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['claimdocuments'], meta: { name: 'claimdocuments' } }
    /**
     * Find zero or one Claimdocuments that matches the filter.
     * @param {claimdocumentsFindUniqueArgs} args - Arguments to find a Claimdocuments
     * @example
     * // Get one Claimdocuments
     * const claimdocuments = await prisma.claimdocuments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends claimdocumentsFindUniqueArgs>(args: SelectSubset<T, claimdocumentsFindUniqueArgs<ExtArgs>>): Prisma__claimdocumentsClient<$Result.GetResult<Prisma.$claimdocumentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Claimdocuments that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {claimdocumentsFindUniqueOrThrowArgs} args - Arguments to find a Claimdocuments
     * @example
     * // Get one Claimdocuments
     * const claimdocuments = await prisma.claimdocuments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends claimdocumentsFindUniqueOrThrowArgs>(args: SelectSubset<T, claimdocumentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__claimdocumentsClient<$Result.GetResult<Prisma.$claimdocumentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Claimdocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {claimdocumentsFindFirstArgs} args - Arguments to find a Claimdocuments
     * @example
     * // Get one Claimdocuments
     * const claimdocuments = await prisma.claimdocuments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends claimdocumentsFindFirstArgs>(args?: SelectSubset<T, claimdocumentsFindFirstArgs<ExtArgs>>): Prisma__claimdocumentsClient<$Result.GetResult<Prisma.$claimdocumentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Claimdocuments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {claimdocumentsFindFirstOrThrowArgs} args - Arguments to find a Claimdocuments
     * @example
     * // Get one Claimdocuments
     * const claimdocuments = await prisma.claimdocuments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends claimdocumentsFindFirstOrThrowArgs>(args?: SelectSubset<T, claimdocumentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__claimdocumentsClient<$Result.GetResult<Prisma.$claimdocumentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Claimdocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {claimdocumentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Claimdocuments
     * const claimdocuments = await prisma.claimdocuments.findMany()
     * 
     * // Get first 10 Claimdocuments
     * const claimdocuments = await prisma.claimdocuments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const claimdocumentsWithIdOnly = await prisma.claimdocuments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends claimdocumentsFindManyArgs>(args?: SelectSubset<T, claimdocumentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$claimdocumentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Claimdocuments.
     * @param {claimdocumentsCreateArgs} args - Arguments to create a Claimdocuments.
     * @example
     * // Create one Claimdocuments
     * const Claimdocuments = await prisma.claimdocuments.create({
     *   data: {
     *     // ... data to create a Claimdocuments
     *   }
     * })
     * 
     */
    create<T extends claimdocumentsCreateArgs>(args: SelectSubset<T, claimdocumentsCreateArgs<ExtArgs>>): Prisma__claimdocumentsClient<$Result.GetResult<Prisma.$claimdocumentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Claimdocuments.
     * @param {claimdocumentsCreateManyArgs} args - Arguments to create many Claimdocuments.
     * @example
     * // Create many Claimdocuments
     * const claimdocuments = await prisma.claimdocuments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends claimdocumentsCreateManyArgs>(args?: SelectSubset<T, claimdocumentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Claimdocuments and returns the data saved in the database.
     * @param {claimdocumentsCreateManyAndReturnArgs} args - Arguments to create many Claimdocuments.
     * @example
     * // Create many Claimdocuments
     * const claimdocuments = await prisma.claimdocuments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Claimdocuments and only return the `id`
     * const claimdocumentsWithIdOnly = await prisma.claimdocuments.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends claimdocumentsCreateManyAndReturnArgs>(args?: SelectSubset<T, claimdocumentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$claimdocumentsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Claimdocuments.
     * @param {claimdocumentsDeleteArgs} args - Arguments to delete one Claimdocuments.
     * @example
     * // Delete one Claimdocuments
     * const Claimdocuments = await prisma.claimdocuments.delete({
     *   where: {
     *     // ... filter to delete one Claimdocuments
     *   }
     * })
     * 
     */
    delete<T extends claimdocumentsDeleteArgs>(args: SelectSubset<T, claimdocumentsDeleteArgs<ExtArgs>>): Prisma__claimdocumentsClient<$Result.GetResult<Prisma.$claimdocumentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Claimdocuments.
     * @param {claimdocumentsUpdateArgs} args - Arguments to update one Claimdocuments.
     * @example
     * // Update one Claimdocuments
     * const claimdocuments = await prisma.claimdocuments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends claimdocumentsUpdateArgs>(args: SelectSubset<T, claimdocumentsUpdateArgs<ExtArgs>>): Prisma__claimdocumentsClient<$Result.GetResult<Prisma.$claimdocumentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Claimdocuments.
     * @param {claimdocumentsDeleteManyArgs} args - Arguments to filter Claimdocuments to delete.
     * @example
     * // Delete a few Claimdocuments
     * const { count } = await prisma.claimdocuments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends claimdocumentsDeleteManyArgs>(args?: SelectSubset<T, claimdocumentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Claimdocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {claimdocumentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Claimdocuments
     * const claimdocuments = await prisma.claimdocuments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends claimdocumentsUpdateManyArgs>(args: SelectSubset<T, claimdocumentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Claimdocuments.
     * @param {claimdocumentsUpsertArgs} args - Arguments to update or create a Claimdocuments.
     * @example
     * // Update or create a Claimdocuments
     * const claimdocuments = await prisma.claimdocuments.upsert({
     *   create: {
     *     // ... data to create a Claimdocuments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Claimdocuments we want to update
     *   }
     * })
     */
    upsert<T extends claimdocumentsUpsertArgs>(args: SelectSubset<T, claimdocumentsUpsertArgs<ExtArgs>>): Prisma__claimdocumentsClient<$Result.GetResult<Prisma.$claimdocumentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Claimdocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {claimdocumentsCountArgs} args - Arguments to filter Claimdocuments to count.
     * @example
     * // Count the number of Claimdocuments
     * const count = await prisma.claimdocuments.count({
     *   where: {
     *     // ... the filter for the Claimdocuments we want to count
     *   }
     * })
    **/
    count<T extends claimdocumentsCountArgs>(
      args?: Subset<T, claimdocumentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClaimdocumentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Claimdocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimdocumentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClaimdocumentsAggregateArgs>(args: Subset<T, ClaimdocumentsAggregateArgs>): Prisma.PrismaPromise<GetClaimdocumentsAggregateType<T>>

    /**
     * Group by Claimdocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {claimdocumentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends claimdocumentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: claimdocumentsGroupByArgs['orderBy'] }
        : { orderBy?: claimdocumentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, claimdocumentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClaimdocumentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the claimdocuments model
   */
  readonly fields: claimdocumentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for claimdocuments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__claimdocumentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    insurers<T extends claimdocuments$insurersArgs<ExtArgs> = {}>(args?: Subset<T, claimdocuments$insurersArgs<ExtArgs>>): Prisma__insurersClient<$Result.GetResult<Prisma.$insurersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the claimdocuments model
   */ 
  interface claimdocumentsFieldRefs {
    readonly id: FieldRef<"claimdocuments", 'Int'>
    readonly insurerid: FieldRef<"claimdocuments", 'Int'>
    readonly refid: FieldRef<"claimdocuments", 'String'>
    readonly transactionno: FieldRef<"claimdocuments", 'String'>
    readonly hn: FieldRef<"claimdocuments", 'String'>
    readonly vn: FieldRef<"claimdocuments", 'String'>
    readonly documentname: FieldRef<"claimdocuments", 'String'>
    readonly documenttypecode: FieldRef<"claimdocuments", 'String'>
    readonly documenttypename: FieldRef<"claimdocuments", 'String'>
    readonly serverpath: FieldRef<"claimdocuments", 'String'>
    readonly filepath: FieldRef<"claimdocuments", 'String'>
    readonly filesize: FieldRef<"claimdocuments", 'BigInt'>
    readonly filemimetype: FieldRef<"claimdocuments", 'String'>
    readonly uploaddate: FieldRef<"claimdocuments", 'DateTime'>
    readonly uploadedby: FieldRef<"claimdocuments", 'String'>
  }
    

  // Custom InputTypes
  /**
   * claimdocuments findUnique
   */
  export type claimdocumentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimdocuments
     */
    select?: claimdocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimdocumentsInclude<ExtArgs> | null
    /**
     * Filter, which claimdocuments to fetch.
     */
    where: claimdocumentsWhereUniqueInput
  }

  /**
   * claimdocuments findUniqueOrThrow
   */
  export type claimdocumentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimdocuments
     */
    select?: claimdocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimdocumentsInclude<ExtArgs> | null
    /**
     * Filter, which claimdocuments to fetch.
     */
    where: claimdocumentsWhereUniqueInput
  }

  /**
   * claimdocuments findFirst
   */
  export type claimdocumentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimdocuments
     */
    select?: claimdocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimdocumentsInclude<ExtArgs> | null
    /**
     * Filter, which claimdocuments to fetch.
     */
    where?: claimdocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of claimdocuments to fetch.
     */
    orderBy?: claimdocumentsOrderByWithRelationInput | claimdocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for claimdocuments.
     */
    cursor?: claimdocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` claimdocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` claimdocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of claimdocuments.
     */
    distinct?: ClaimdocumentsScalarFieldEnum | ClaimdocumentsScalarFieldEnum[]
  }

  /**
   * claimdocuments findFirstOrThrow
   */
  export type claimdocumentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimdocuments
     */
    select?: claimdocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimdocumentsInclude<ExtArgs> | null
    /**
     * Filter, which claimdocuments to fetch.
     */
    where?: claimdocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of claimdocuments to fetch.
     */
    orderBy?: claimdocumentsOrderByWithRelationInput | claimdocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for claimdocuments.
     */
    cursor?: claimdocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` claimdocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` claimdocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of claimdocuments.
     */
    distinct?: ClaimdocumentsScalarFieldEnum | ClaimdocumentsScalarFieldEnum[]
  }

  /**
   * claimdocuments findMany
   */
  export type claimdocumentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimdocuments
     */
    select?: claimdocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimdocumentsInclude<ExtArgs> | null
    /**
     * Filter, which claimdocuments to fetch.
     */
    where?: claimdocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of claimdocuments to fetch.
     */
    orderBy?: claimdocumentsOrderByWithRelationInput | claimdocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing claimdocuments.
     */
    cursor?: claimdocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` claimdocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` claimdocuments.
     */
    skip?: number
    distinct?: ClaimdocumentsScalarFieldEnum | ClaimdocumentsScalarFieldEnum[]
  }

  /**
   * claimdocuments create
   */
  export type claimdocumentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimdocuments
     */
    select?: claimdocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimdocumentsInclude<ExtArgs> | null
    /**
     * The data needed to create a claimdocuments.
     */
    data: XOR<claimdocumentsCreateInput, claimdocumentsUncheckedCreateInput>
  }

  /**
   * claimdocuments createMany
   */
  export type claimdocumentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many claimdocuments.
     */
    data: claimdocumentsCreateManyInput | claimdocumentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * claimdocuments createManyAndReturn
   */
  export type claimdocumentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimdocuments
     */
    select?: claimdocumentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many claimdocuments.
     */
    data: claimdocumentsCreateManyInput | claimdocumentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimdocumentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * claimdocuments update
   */
  export type claimdocumentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimdocuments
     */
    select?: claimdocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimdocumentsInclude<ExtArgs> | null
    /**
     * The data needed to update a claimdocuments.
     */
    data: XOR<claimdocumentsUpdateInput, claimdocumentsUncheckedUpdateInput>
    /**
     * Choose, which claimdocuments to update.
     */
    where: claimdocumentsWhereUniqueInput
  }

  /**
   * claimdocuments updateMany
   */
  export type claimdocumentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update claimdocuments.
     */
    data: XOR<claimdocumentsUpdateManyMutationInput, claimdocumentsUncheckedUpdateManyInput>
    /**
     * Filter which claimdocuments to update
     */
    where?: claimdocumentsWhereInput
  }

  /**
   * claimdocuments upsert
   */
  export type claimdocumentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimdocuments
     */
    select?: claimdocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimdocumentsInclude<ExtArgs> | null
    /**
     * The filter to search for the claimdocuments to update in case it exists.
     */
    where: claimdocumentsWhereUniqueInput
    /**
     * In case the claimdocuments found by the `where` argument doesn't exist, create a new claimdocuments with this data.
     */
    create: XOR<claimdocumentsCreateInput, claimdocumentsUncheckedCreateInput>
    /**
     * In case the claimdocuments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<claimdocumentsUpdateInput, claimdocumentsUncheckedUpdateInput>
  }

  /**
   * claimdocuments delete
   */
  export type claimdocumentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimdocuments
     */
    select?: claimdocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimdocumentsInclude<ExtArgs> | null
    /**
     * Filter which claimdocuments to delete.
     */
    where: claimdocumentsWhereUniqueInput
  }

  /**
   * claimdocuments deleteMany
   */
  export type claimdocumentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which claimdocuments to delete
     */
    where?: claimdocumentsWhereInput
  }

  /**
   * claimdocuments.insurers
   */
  export type claimdocuments$insurersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insurers
     */
    select?: insurersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: insurersInclude<ExtArgs> | null
    where?: insurersWhereInput
  }

  /**
   * claimdocuments without action
   */
  export type claimdocumentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimdocuments
     */
    select?: claimdocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimdocumentsInclude<ExtArgs> | null
  }


  /**
   * Model claimstatus
   */

  export type AggregateClaimstatus = {
    _count: ClaimstatusCountAggregateOutputType | null
    _avg: ClaimstatusAvgAggregateOutputType | null
    _sum: ClaimstatusSumAggregateOutputType | null
    _min: ClaimstatusMinAggregateOutputType | null
    _max: ClaimstatusMaxAggregateOutputType | null
  }

  export type ClaimstatusAvgAggregateOutputType = {
    id: number | null
    insurerid: number | null
  }

  export type ClaimstatusSumAggregateOutputType = {
    id: number | null
    insurerid: number | null
  }

  export type ClaimstatusMinAggregateOutputType = {
    id: number | null
    claimstatuscode: string | null
    claimstatusdesc_th: string | null
    claimstatusdesc_en: string | null
    insurerid: number | null
  }

  export type ClaimstatusMaxAggregateOutputType = {
    id: number | null
    claimstatuscode: string | null
    claimstatusdesc_th: string | null
    claimstatusdesc_en: string | null
    insurerid: number | null
  }

  export type ClaimstatusCountAggregateOutputType = {
    id: number
    claimstatuscode: number
    claimstatusdesc_th: number
    claimstatusdesc_en: number
    insurerid: number
    _all: number
  }


  export type ClaimstatusAvgAggregateInputType = {
    id?: true
    insurerid?: true
  }

  export type ClaimstatusSumAggregateInputType = {
    id?: true
    insurerid?: true
  }

  export type ClaimstatusMinAggregateInputType = {
    id?: true
    claimstatuscode?: true
    claimstatusdesc_th?: true
    claimstatusdesc_en?: true
    insurerid?: true
  }

  export type ClaimstatusMaxAggregateInputType = {
    id?: true
    claimstatuscode?: true
    claimstatusdesc_th?: true
    claimstatusdesc_en?: true
    insurerid?: true
  }

  export type ClaimstatusCountAggregateInputType = {
    id?: true
    claimstatuscode?: true
    claimstatusdesc_th?: true
    claimstatusdesc_en?: true
    insurerid?: true
    _all?: true
  }

  export type ClaimstatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which claimstatus to aggregate.
     */
    where?: claimstatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of claimstatuses to fetch.
     */
    orderBy?: claimstatusOrderByWithRelationInput | claimstatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: claimstatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` claimstatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` claimstatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned claimstatuses
    **/
    _count?: true | ClaimstatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClaimstatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClaimstatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClaimstatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClaimstatusMaxAggregateInputType
  }

  export type GetClaimstatusAggregateType<T extends ClaimstatusAggregateArgs> = {
        [P in keyof T & keyof AggregateClaimstatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClaimstatus[P]>
      : GetScalarType<T[P], AggregateClaimstatus[P]>
  }




  export type claimstatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: claimstatusWhereInput
    orderBy?: claimstatusOrderByWithAggregationInput | claimstatusOrderByWithAggregationInput[]
    by: ClaimstatusScalarFieldEnum[] | ClaimstatusScalarFieldEnum
    having?: claimstatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClaimstatusCountAggregateInputType | true
    _avg?: ClaimstatusAvgAggregateInputType
    _sum?: ClaimstatusSumAggregateInputType
    _min?: ClaimstatusMinAggregateInputType
    _max?: ClaimstatusMaxAggregateInputType
  }

  export type ClaimstatusGroupByOutputType = {
    id: number
    claimstatuscode: string
    claimstatusdesc_th: string | null
    claimstatusdesc_en: string | null
    insurerid: number | null
    _count: ClaimstatusCountAggregateOutputType | null
    _avg: ClaimstatusAvgAggregateOutputType | null
    _sum: ClaimstatusSumAggregateOutputType | null
    _min: ClaimstatusMinAggregateOutputType | null
    _max: ClaimstatusMaxAggregateOutputType | null
  }

  type GetClaimstatusGroupByPayload<T extends claimstatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClaimstatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClaimstatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClaimstatusGroupByOutputType[P]>
            : GetScalarType<T[P], ClaimstatusGroupByOutputType[P]>
        }
      >
    >


  export type claimstatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claimstatuscode?: boolean
    claimstatusdesc_th?: boolean
    claimstatusdesc_en?: boolean
    insurerid?: boolean
    insurers?: boolean | claimstatus$insurersArgs<ExtArgs>
    transactionclaimstatus?: boolean | claimstatus$transactionclaimstatusArgs<ExtArgs>
    _count?: boolean | ClaimstatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["claimstatus"]>

  export type claimstatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claimstatuscode?: boolean
    claimstatusdesc_th?: boolean
    claimstatusdesc_en?: boolean
    insurerid?: boolean
    insurers?: boolean | claimstatus$insurersArgs<ExtArgs>
  }, ExtArgs["result"]["claimstatus"]>

  export type claimstatusSelectScalar = {
    id?: boolean
    claimstatuscode?: boolean
    claimstatusdesc_th?: boolean
    claimstatusdesc_en?: boolean
    insurerid?: boolean
  }

  export type claimstatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurers?: boolean | claimstatus$insurersArgs<ExtArgs>
    transactionclaimstatus?: boolean | claimstatus$transactionclaimstatusArgs<ExtArgs>
    _count?: boolean | ClaimstatusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type claimstatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurers?: boolean | claimstatus$insurersArgs<ExtArgs>
  }

  export type $claimstatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "claimstatus"
    objects: {
      insurers: Prisma.$insurersPayload<ExtArgs> | null
      transactionclaimstatus: Prisma.$transactionclaimstatusPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      claimstatuscode: string
      claimstatusdesc_th: string | null
      claimstatusdesc_en: string | null
      insurerid: number | null
    }, ExtArgs["result"]["claimstatus"]>
    composites: {}
  }

  type claimstatusGetPayload<S extends boolean | null | undefined | claimstatusDefaultArgs> = $Result.GetResult<Prisma.$claimstatusPayload, S>

  type claimstatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<claimstatusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClaimstatusCountAggregateInputType | true
    }

  export interface claimstatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['claimstatus'], meta: { name: 'claimstatus' } }
    /**
     * Find zero or one Claimstatus that matches the filter.
     * @param {claimstatusFindUniqueArgs} args - Arguments to find a Claimstatus
     * @example
     * // Get one Claimstatus
     * const claimstatus = await prisma.claimstatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends claimstatusFindUniqueArgs>(args: SelectSubset<T, claimstatusFindUniqueArgs<ExtArgs>>): Prisma__claimstatusClient<$Result.GetResult<Prisma.$claimstatusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Claimstatus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {claimstatusFindUniqueOrThrowArgs} args - Arguments to find a Claimstatus
     * @example
     * // Get one Claimstatus
     * const claimstatus = await prisma.claimstatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends claimstatusFindUniqueOrThrowArgs>(args: SelectSubset<T, claimstatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__claimstatusClient<$Result.GetResult<Prisma.$claimstatusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Claimstatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {claimstatusFindFirstArgs} args - Arguments to find a Claimstatus
     * @example
     * // Get one Claimstatus
     * const claimstatus = await prisma.claimstatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends claimstatusFindFirstArgs>(args?: SelectSubset<T, claimstatusFindFirstArgs<ExtArgs>>): Prisma__claimstatusClient<$Result.GetResult<Prisma.$claimstatusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Claimstatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {claimstatusFindFirstOrThrowArgs} args - Arguments to find a Claimstatus
     * @example
     * // Get one Claimstatus
     * const claimstatus = await prisma.claimstatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends claimstatusFindFirstOrThrowArgs>(args?: SelectSubset<T, claimstatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__claimstatusClient<$Result.GetResult<Prisma.$claimstatusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Claimstatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {claimstatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Claimstatuses
     * const claimstatuses = await prisma.claimstatus.findMany()
     * 
     * // Get first 10 Claimstatuses
     * const claimstatuses = await prisma.claimstatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const claimstatusWithIdOnly = await prisma.claimstatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends claimstatusFindManyArgs>(args?: SelectSubset<T, claimstatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$claimstatusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Claimstatus.
     * @param {claimstatusCreateArgs} args - Arguments to create a Claimstatus.
     * @example
     * // Create one Claimstatus
     * const Claimstatus = await prisma.claimstatus.create({
     *   data: {
     *     // ... data to create a Claimstatus
     *   }
     * })
     * 
     */
    create<T extends claimstatusCreateArgs>(args: SelectSubset<T, claimstatusCreateArgs<ExtArgs>>): Prisma__claimstatusClient<$Result.GetResult<Prisma.$claimstatusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Claimstatuses.
     * @param {claimstatusCreateManyArgs} args - Arguments to create many Claimstatuses.
     * @example
     * // Create many Claimstatuses
     * const claimstatus = await prisma.claimstatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends claimstatusCreateManyArgs>(args?: SelectSubset<T, claimstatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Claimstatuses and returns the data saved in the database.
     * @param {claimstatusCreateManyAndReturnArgs} args - Arguments to create many Claimstatuses.
     * @example
     * // Create many Claimstatuses
     * const claimstatus = await prisma.claimstatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Claimstatuses and only return the `id`
     * const claimstatusWithIdOnly = await prisma.claimstatus.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends claimstatusCreateManyAndReturnArgs>(args?: SelectSubset<T, claimstatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$claimstatusPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Claimstatus.
     * @param {claimstatusDeleteArgs} args - Arguments to delete one Claimstatus.
     * @example
     * // Delete one Claimstatus
     * const Claimstatus = await prisma.claimstatus.delete({
     *   where: {
     *     // ... filter to delete one Claimstatus
     *   }
     * })
     * 
     */
    delete<T extends claimstatusDeleteArgs>(args: SelectSubset<T, claimstatusDeleteArgs<ExtArgs>>): Prisma__claimstatusClient<$Result.GetResult<Prisma.$claimstatusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Claimstatus.
     * @param {claimstatusUpdateArgs} args - Arguments to update one Claimstatus.
     * @example
     * // Update one Claimstatus
     * const claimstatus = await prisma.claimstatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends claimstatusUpdateArgs>(args: SelectSubset<T, claimstatusUpdateArgs<ExtArgs>>): Prisma__claimstatusClient<$Result.GetResult<Prisma.$claimstatusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Claimstatuses.
     * @param {claimstatusDeleteManyArgs} args - Arguments to filter Claimstatuses to delete.
     * @example
     * // Delete a few Claimstatuses
     * const { count } = await prisma.claimstatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends claimstatusDeleteManyArgs>(args?: SelectSubset<T, claimstatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Claimstatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {claimstatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Claimstatuses
     * const claimstatus = await prisma.claimstatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends claimstatusUpdateManyArgs>(args: SelectSubset<T, claimstatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Claimstatus.
     * @param {claimstatusUpsertArgs} args - Arguments to update or create a Claimstatus.
     * @example
     * // Update or create a Claimstatus
     * const claimstatus = await prisma.claimstatus.upsert({
     *   create: {
     *     // ... data to create a Claimstatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Claimstatus we want to update
     *   }
     * })
     */
    upsert<T extends claimstatusUpsertArgs>(args: SelectSubset<T, claimstatusUpsertArgs<ExtArgs>>): Prisma__claimstatusClient<$Result.GetResult<Prisma.$claimstatusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Claimstatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {claimstatusCountArgs} args - Arguments to filter Claimstatuses to count.
     * @example
     * // Count the number of Claimstatuses
     * const count = await prisma.claimstatus.count({
     *   where: {
     *     // ... the filter for the Claimstatuses we want to count
     *   }
     * })
    **/
    count<T extends claimstatusCountArgs>(
      args?: Subset<T, claimstatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClaimstatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Claimstatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimstatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClaimstatusAggregateArgs>(args: Subset<T, ClaimstatusAggregateArgs>): Prisma.PrismaPromise<GetClaimstatusAggregateType<T>>

    /**
     * Group by Claimstatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {claimstatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends claimstatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: claimstatusGroupByArgs['orderBy'] }
        : { orderBy?: claimstatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, claimstatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClaimstatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the claimstatus model
   */
  readonly fields: claimstatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for claimstatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__claimstatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    insurers<T extends claimstatus$insurersArgs<ExtArgs> = {}>(args?: Subset<T, claimstatus$insurersArgs<ExtArgs>>): Prisma__insurersClient<$Result.GetResult<Prisma.$insurersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    transactionclaimstatus<T extends claimstatus$transactionclaimstatusArgs<ExtArgs> = {}>(args?: Subset<T, claimstatus$transactionclaimstatusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionclaimstatusPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the claimstatus model
   */ 
  interface claimstatusFieldRefs {
    readonly id: FieldRef<"claimstatus", 'Int'>
    readonly claimstatuscode: FieldRef<"claimstatus", 'String'>
    readonly claimstatusdesc_th: FieldRef<"claimstatus", 'String'>
    readonly claimstatusdesc_en: FieldRef<"claimstatus", 'String'>
    readonly insurerid: FieldRef<"claimstatus", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * claimstatus findUnique
   */
  export type claimstatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimstatus
     */
    select?: claimstatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimstatusInclude<ExtArgs> | null
    /**
     * Filter, which claimstatus to fetch.
     */
    where: claimstatusWhereUniqueInput
  }

  /**
   * claimstatus findUniqueOrThrow
   */
  export type claimstatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimstatus
     */
    select?: claimstatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimstatusInclude<ExtArgs> | null
    /**
     * Filter, which claimstatus to fetch.
     */
    where: claimstatusWhereUniqueInput
  }

  /**
   * claimstatus findFirst
   */
  export type claimstatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimstatus
     */
    select?: claimstatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimstatusInclude<ExtArgs> | null
    /**
     * Filter, which claimstatus to fetch.
     */
    where?: claimstatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of claimstatuses to fetch.
     */
    orderBy?: claimstatusOrderByWithRelationInput | claimstatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for claimstatuses.
     */
    cursor?: claimstatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` claimstatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` claimstatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of claimstatuses.
     */
    distinct?: ClaimstatusScalarFieldEnum | ClaimstatusScalarFieldEnum[]
  }

  /**
   * claimstatus findFirstOrThrow
   */
  export type claimstatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimstatus
     */
    select?: claimstatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimstatusInclude<ExtArgs> | null
    /**
     * Filter, which claimstatus to fetch.
     */
    where?: claimstatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of claimstatuses to fetch.
     */
    orderBy?: claimstatusOrderByWithRelationInput | claimstatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for claimstatuses.
     */
    cursor?: claimstatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` claimstatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` claimstatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of claimstatuses.
     */
    distinct?: ClaimstatusScalarFieldEnum | ClaimstatusScalarFieldEnum[]
  }

  /**
   * claimstatus findMany
   */
  export type claimstatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimstatus
     */
    select?: claimstatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimstatusInclude<ExtArgs> | null
    /**
     * Filter, which claimstatuses to fetch.
     */
    where?: claimstatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of claimstatuses to fetch.
     */
    orderBy?: claimstatusOrderByWithRelationInput | claimstatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing claimstatuses.
     */
    cursor?: claimstatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` claimstatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` claimstatuses.
     */
    skip?: number
    distinct?: ClaimstatusScalarFieldEnum | ClaimstatusScalarFieldEnum[]
  }

  /**
   * claimstatus create
   */
  export type claimstatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimstatus
     */
    select?: claimstatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimstatusInclude<ExtArgs> | null
    /**
     * The data needed to create a claimstatus.
     */
    data: XOR<claimstatusCreateInput, claimstatusUncheckedCreateInput>
  }

  /**
   * claimstatus createMany
   */
  export type claimstatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many claimstatuses.
     */
    data: claimstatusCreateManyInput | claimstatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * claimstatus createManyAndReturn
   */
  export type claimstatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimstatus
     */
    select?: claimstatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many claimstatuses.
     */
    data: claimstatusCreateManyInput | claimstatusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimstatusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * claimstatus update
   */
  export type claimstatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimstatus
     */
    select?: claimstatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimstatusInclude<ExtArgs> | null
    /**
     * The data needed to update a claimstatus.
     */
    data: XOR<claimstatusUpdateInput, claimstatusUncheckedUpdateInput>
    /**
     * Choose, which claimstatus to update.
     */
    where: claimstatusWhereUniqueInput
  }

  /**
   * claimstatus updateMany
   */
  export type claimstatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update claimstatuses.
     */
    data: XOR<claimstatusUpdateManyMutationInput, claimstatusUncheckedUpdateManyInput>
    /**
     * Filter which claimstatuses to update
     */
    where?: claimstatusWhereInput
  }

  /**
   * claimstatus upsert
   */
  export type claimstatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimstatus
     */
    select?: claimstatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimstatusInclude<ExtArgs> | null
    /**
     * The filter to search for the claimstatus to update in case it exists.
     */
    where: claimstatusWhereUniqueInput
    /**
     * In case the claimstatus found by the `where` argument doesn't exist, create a new claimstatus with this data.
     */
    create: XOR<claimstatusCreateInput, claimstatusUncheckedCreateInput>
    /**
     * In case the claimstatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<claimstatusUpdateInput, claimstatusUncheckedUpdateInput>
  }

  /**
   * claimstatus delete
   */
  export type claimstatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimstatus
     */
    select?: claimstatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimstatusInclude<ExtArgs> | null
    /**
     * Filter which claimstatus to delete.
     */
    where: claimstatusWhereUniqueInput
  }

  /**
   * claimstatus deleteMany
   */
  export type claimstatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which claimstatuses to delete
     */
    where?: claimstatusWhereInput
  }

  /**
   * claimstatus.insurers
   */
  export type claimstatus$insurersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insurers
     */
    select?: insurersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: insurersInclude<ExtArgs> | null
    where?: insurersWhereInput
  }

  /**
   * claimstatus.transactionclaimstatus
   */
  export type claimstatus$transactionclaimstatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionclaimstatus
     */
    select?: transactionclaimstatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionclaimstatusInclude<ExtArgs> | null
    where?: transactionclaimstatusWhereInput
    orderBy?: transactionclaimstatusOrderByWithRelationInput | transactionclaimstatusOrderByWithRelationInput[]
    cursor?: transactionclaimstatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionclaimstatusScalarFieldEnum | TransactionclaimstatusScalarFieldEnum[]
  }

  /**
   * claimstatus without action
   */
  export type claimstatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimstatus
     */
    select?: claimstatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimstatusInclude<ExtArgs> | null
  }


  /**
   * Model diagnosistypemapping
   */

  export type AggregateDiagnosistypemapping = {
    _count: DiagnosistypemappingCountAggregateOutputType | null
    _avg: DiagnosistypemappingAvgAggregateOutputType | null
    _sum: DiagnosistypemappingSumAggregateOutputType | null
    _min: DiagnosistypemappingMinAggregateOutputType | null
    _max: DiagnosistypemappingMaxAggregateOutputType | null
  }

  export type DiagnosistypemappingAvgAggregateOutputType = {
    id: number | null
    insurerid: number | null
  }

  export type DiagnosistypemappingSumAggregateOutputType = {
    id: number | null
    insurerid: number | null
  }

  export type DiagnosistypemappingMinAggregateOutputType = {
    id: number | null
    dxtypecodetrakcare: string | null
    dxtypenametrakcare: string | null
    dxtypecodeinsurance: string | null
    dxtypenameinsurance: string | null
    insurerid: number | null
  }

  export type DiagnosistypemappingMaxAggregateOutputType = {
    id: number | null
    dxtypecodetrakcare: string | null
    dxtypenametrakcare: string | null
    dxtypecodeinsurance: string | null
    dxtypenameinsurance: string | null
    insurerid: number | null
  }

  export type DiagnosistypemappingCountAggregateOutputType = {
    id: number
    dxtypecodetrakcare: number
    dxtypenametrakcare: number
    dxtypecodeinsurance: number
    dxtypenameinsurance: number
    insurerid: number
    _all: number
  }


  export type DiagnosistypemappingAvgAggregateInputType = {
    id?: true
    insurerid?: true
  }

  export type DiagnosistypemappingSumAggregateInputType = {
    id?: true
    insurerid?: true
  }

  export type DiagnosistypemappingMinAggregateInputType = {
    id?: true
    dxtypecodetrakcare?: true
    dxtypenametrakcare?: true
    dxtypecodeinsurance?: true
    dxtypenameinsurance?: true
    insurerid?: true
  }

  export type DiagnosistypemappingMaxAggregateInputType = {
    id?: true
    dxtypecodetrakcare?: true
    dxtypenametrakcare?: true
    dxtypecodeinsurance?: true
    dxtypenameinsurance?: true
    insurerid?: true
  }

  export type DiagnosistypemappingCountAggregateInputType = {
    id?: true
    dxtypecodetrakcare?: true
    dxtypenametrakcare?: true
    dxtypecodeinsurance?: true
    dxtypenameinsurance?: true
    insurerid?: true
    _all?: true
  }

  export type DiagnosistypemappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which diagnosistypemapping to aggregate.
     */
    where?: diagnosistypemappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diagnosistypemappings to fetch.
     */
    orderBy?: diagnosistypemappingOrderByWithRelationInput | diagnosistypemappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: diagnosistypemappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diagnosistypemappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diagnosistypemappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned diagnosistypemappings
    **/
    _count?: true | DiagnosistypemappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiagnosistypemappingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiagnosistypemappingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiagnosistypemappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiagnosistypemappingMaxAggregateInputType
  }

  export type GetDiagnosistypemappingAggregateType<T extends DiagnosistypemappingAggregateArgs> = {
        [P in keyof T & keyof AggregateDiagnosistypemapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiagnosistypemapping[P]>
      : GetScalarType<T[P], AggregateDiagnosistypemapping[P]>
  }




  export type diagnosistypemappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: diagnosistypemappingWhereInput
    orderBy?: diagnosistypemappingOrderByWithAggregationInput | diagnosistypemappingOrderByWithAggregationInput[]
    by: DiagnosistypemappingScalarFieldEnum[] | DiagnosistypemappingScalarFieldEnum
    having?: diagnosistypemappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiagnosistypemappingCountAggregateInputType | true
    _avg?: DiagnosistypemappingAvgAggregateInputType
    _sum?: DiagnosistypemappingSumAggregateInputType
    _min?: DiagnosistypemappingMinAggregateInputType
    _max?: DiagnosistypemappingMaxAggregateInputType
  }

  export type DiagnosistypemappingGroupByOutputType = {
    id: number
    dxtypecodetrakcare: string
    dxtypenametrakcare: string | null
    dxtypecodeinsurance: string | null
    dxtypenameinsurance: string | null
    insurerid: number | null
    _count: DiagnosistypemappingCountAggregateOutputType | null
    _avg: DiagnosistypemappingAvgAggregateOutputType | null
    _sum: DiagnosistypemappingSumAggregateOutputType | null
    _min: DiagnosistypemappingMinAggregateOutputType | null
    _max: DiagnosistypemappingMaxAggregateOutputType | null
  }

  type GetDiagnosistypemappingGroupByPayload<T extends diagnosistypemappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiagnosistypemappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiagnosistypemappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiagnosistypemappingGroupByOutputType[P]>
            : GetScalarType<T[P], DiagnosistypemappingGroupByOutputType[P]>
        }
      >
    >


  export type diagnosistypemappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dxtypecodetrakcare?: boolean
    dxtypenametrakcare?: boolean
    dxtypecodeinsurance?: boolean
    dxtypenameinsurance?: boolean
    insurerid?: boolean
    insurers?: boolean | diagnosistypemapping$insurersArgs<ExtArgs>
  }, ExtArgs["result"]["diagnosistypemapping"]>

  export type diagnosistypemappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dxtypecodetrakcare?: boolean
    dxtypenametrakcare?: boolean
    dxtypecodeinsurance?: boolean
    dxtypenameinsurance?: boolean
    insurerid?: boolean
    insurers?: boolean | diagnosistypemapping$insurersArgs<ExtArgs>
  }, ExtArgs["result"]["diagnosistypemapping"]>

  export type diagnosistypemappingSelectScalar = {
    id?: boolean
    dxtypecodetrakcare?: boolean
    dxtypenametrakcare?: boolean
    dxtypecodeinsurance?: boolean
    dxtypenameinsurance?: boolean
    insurerid?: boolean
  }

  export type diagnosistypemappingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurers?: boolean | diagnosistypemapping$insurersArgs<ExtArgs>
  }
  export type diagnosistypemappingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurers?: boolean | diagnosistypemapping$insurersArgs<ExtArgs>
  }

  export type $diagnosistypemappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "diagnosistypemapping"
    objects: {
      insurers: Prisma.$insurersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dxtypecodetrakcare: string
      dxtypenametrakcare: string | null
      dxtypecodeinsurance: string | null
      dxtypenameinsurance: string | null
      insurerid: number | null
    }, ExtArgs["result"]["diagnosistypemapping"]>
    composites: {}
  }

  type diagnosistypemappingGetPayload<S extends boolean | null | undefined | diagnosistypemappingDefaultArgs> = $Result.GetResult<Prisma.$diagnosistypemappingPayload, S>

  type diagnosistypemappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<diagnosistypemappingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DiagnosistypemappingCountAggregateInputType | true
    }

  export interface diagnosistypemappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['diagnosistypemapping'], meta: { name: 'diagnosistypemapping' } }
    /**
     * Find zero or one Diagnosistypemapping that matches the filter.
     * @param {diagnosistypemappingFindUniqueArgs} args - Arguments to find a Diagnosistypemapping
     * @example
     * // Get one Diagnosistypemapping
     * const diagnosistypemapping = await prisma.diagnosistypemapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends diagnosistypemappingFindUniqueArgs>(args: SelectSubset<T, diagnosistypemappingFindUniqueArgs<ExtArgs>>): Prisma__diagnosistypemappingClient<$Result.GetResult<Prisma.$diagnosistypemappingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Diagnosistypemapping that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {diagnosistypemappingFindUniqueOrThrowArgs} args - Arguments to find a Diagnosistypemapping
     * @example
     * // Get one Diagnosistypemapping
     * const diagnosistypemapping = await prisma.diagnosistypemapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends diagnosistypemappingFindUniqueOrThrowArgs>(args: SelectSubset<T, diagnosistypemappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__diagnosistypemappingClient<$Result.GetResult<Prisma.$diagnosistypemappingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Diagnosistypemapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diagnosistypemappingFindFirstArgs} args - Arguments to find a Diagnosistypemapping
     * @example
     * // Get one Diagnosistypemapping
     * const diagnosistypemapping = await prisma.diagnosistypemapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends diagnosistypemappingFindFirstArgs>(args?: SelectSubset<T, diagnosistypemappingFindFirstArgs<ExtArgs>>): Prisma__diagnosistypemappingClient<$Result.GetResult<Prisma.$diagnosistypemappingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Diagnosistypemapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diagnosistypemappingFindFirstOrThrowArgs} args - Arguments to find a Diagnosistypemapping
     * @example
     * // Get one Diagnosistypemapping
     * const diagnosistypemapping = await prisma.diagnosistypemapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends diagnosistypemappingFindFirstOrThrowArgs>(args?: SelectSubset<T, diagnosistypemappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__diagnosistypemappingClient<$Result.GetResult<Prisma.$diagnosistypemappingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Diagnosistypemappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diagnosistypemappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Diagnosistypemappings
     * const diagnosistypemappings = await prisma.diagnosistypemapping.findMany()
     * 
     * // Get first 10 Diagnosistypemappings
     * const diagnosistypemappings = await prisma.diagnosistypemapping.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const diagnosistypemappingWithIdOnly = await prisma.diagnosistypemapping.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends diagnosistypemappingFindManyArgs>(args?: SelectSubset<T, diagnosistypemappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$diagnosistypemappingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Diagnosistypemapping.
     * @param {diagnosistypemappingCreateArgs} args - Arguments to create a Diagnosistypemapping.
     * @example
     * // Create one Diagnosistypemapping
     * const Diagnosistypemapping = await prisma.diagnosistypemapping.create({
     *   data: {
     *     // ... data to create a Diagnosistypemapping
     *   }
     * })
     * 
     */
    create<T extends diagnosistypemappingCreateArgs>(args: SelectSubset<T, diagnosistypemappingCreateArgs<ExtArgs>>): Prisma__diagnosistypemappingClient<$Result.GetResult<Prisma.$diagnosistypemappingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Diagnosistypemappings.
     * @param {diagnosistypemappingCreateManyArgs} args - Arguments to create many Diagnosistypemappings.
     * @example
     * // Create many Diagnosistypemappings
     * const diagnosistypemapping = await prisma.diagnosistypemapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends diagnosistypemappingCreateManyArgs>(args?: SelectSubset<T, diagnosistypemappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Diagnosistypemappings and returns the data saved in the database.
     * @param {diagnosistypemappingCreateManyAndReturnArgs} args - Arguments to create many Diagnosistypemappings.
     * @example
     * // Create many Diagnosistypemappings
     * const diagnosistypemapping = await prisma.diagnosistypemapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Diagnosistypemappings and only return the `id`
     * const diagnosistypemappingWithIdOnly = await prisma.diagnosistypemapping.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends diagnosistypemappingCreateManyAndReturnArgs>(args?: SelectSubset<T, diagnosistypemappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$diagnosistypemappingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Diagnosistypemapping.
     * @param {diagnosistypemappingDeleteArgs} args - Arguments to delete one Diagnosistypemapping.
     * @example
     * // Delete one Diagnosistypemapping
     * const Diagnosistypemapping = await prisma.diagnosistypemapping.delete({
     *   where: {
     *     // ... filter to delete one Diagnosistypemapping
     *   }
     * })
     * 
     */
    delete<T extends diagnosistypemappingDeleteArgs>(args: SelectSubset<T, diagnosistypemappingDeleteArgs<ExtArgs>>): Prisma__diagnosistypemappingClient<$Result.GetResult<Prisma.$diagnosistypemappingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Diagnosistypemapping.
     * @param {diagnosistypemappingUpdateArgs} args - Arguments to update one Diagnosistypemapping.
     * @example
     * // Update one Diagnosistypemapping
     * const diagnosistypemapping = await prisma.diagnosistypemapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends diagnosistypemappingUpdateArgs>(args: SelectSubset<T, diagnosistypemappingUpdateArgs<ExtArgs>>): Prisma__diagnosistypemappingClient<$Result.GetResult<Prisma.$diagnosistypemappingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Diagnosistypemappings.
     * @param {diagnosistypemappingDeleteManyArgs} args - Arguments to filter Diagnosistypemappings to delete.
     * @example
     * // Delete a few Diagnosistypemappings
     * const { count } = await prisma.diagnosistypemapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends diagnosistypemappingDeleteManyArgs>(args?: SelectSubset<T, diagnosistypemappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diagnosistypemappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diagnosistypemappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Diagnosistypemappings
     * const diagnosistypemapping = await prisma.diagnosistypemapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends diagnosistypemappingUpdateManyArgs>(args: SelectSubset<T, diagnosistypemappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Diagnosistypemapping.
     * @param {diagnosistypemappingUpsertArgs} args - Arguments to update or create a Diagnosistypemapping.
     * @example
     * // Update or create a Diagnosistypemapping
     * const diagnosistypemapping = await prisma.diagnosistypemapping.upsert({
     *   create: {
     *     // ... data to create a Diagnosistypemapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Diagnosistypemapping we want to update
     *   }
     * })
     */
    upsert<T extends diagnosistypemappingUpsertArgs>(args: SelectSubset<T, diagnosistypemappingUpsertArgs<ExtArgs>>): Prisma__diagnosistypemappingClient<$Result.GetResult<Prisma.$diagnosistypemappingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Diagnosistypemappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diagnosistypemappingCountArgs} args - Arguments to filter Diagnosistypemappings to count.
     * @example
     * // Count the number of Diagnosistypemappings
     * const count = await prisma.diagnosistypemapping.count({
     *   where: {
     *     // ... the filter for the Diagnosistypemappings we want to count
     *   }
     * })
    **/
    count<T extends diagnosistypemappingCountArgs>(
      args?: Subset<T, diagnosistypemappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiagnosistypemappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Diagnosistypemapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosistypemappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiagnosistypemappingAggregateArgs>(args: Subset<T, DiagnosistypemappingAggregateArgs>): Prisma.PrismaPromise<GetDiagnosistypemappingAggregateType<T>>

    /**
     * Group by Diagnosistypemapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diagnosistypemappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends diagnosistypemappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: diagnosistypemappingGroupByArgs['orderBy'] }
        : { orderBy?: diagnosistypemappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, diagnosistypemappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiagnosistypemappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the diagnosistypemapping model
   */
  readonly fields: diagnosistypemappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for diagnosistypemapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__diagnosistypemappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    insurers<T extends diagnosistypemapping$insurersArgs<ExtArgs> = {}>(args?: Subset<T, diagnosistypemapping$insurersArgs<ExtArgs>>): Prisma__insurersClient<$Result.GetResult<Prisma.$insurersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the diagnosistypemapping model
   */ 
  interface diagnosistypemappingFieldRefs {
    readonly id: FieldRef<"diagnosistypemapping", 'Int'>
    readonly dxtypecodetrakcare: FieldRef<"diagnosistypemapping", 'String'>
    readonly dxtypenametrakcare: FieldRef<"diagnosistypemapping", 'String'>
    readonly dxtypecodeinsurance: FieldRef<"diagnosistypemapping", 'String'>
    readonly dxtypenameinsurance: FieldRef<"diagnosistypemapping", 'String'>
    readonly insurerid: FieldRef<"diagnosistypemapping", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * diagnosistypemapping findUnique
   */
  export type diagnosistypemappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnosistypemapping
     */
    select?: diagnosistypemappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosistypemappingInclude<ExtArgs> | null
    /**
     * Filter, which diagnosistypemapping to fetch.
     */
    where: diagnosistypemappingWhereUniqueInput
  }

  /**
   * diagnosistypemapping findUniqueOrThrow
   */
  export type diagnosistypemappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnosistypemapping
     */
    select?: diagnosistypemappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosistypemappingInclude<ExtArgs> | null
    /**
     * Filter, which diagnosistypemapping to fetch.
     */
    where: diagnosistypemappingWhereUniqueInput
  }

  /**
   * diagnosistypemapping findFirst
   */
  export type diagnosistypemappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnosistypemapping
     */
    select?: diagnosistypemappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosistypemappingInclude<ExtArgs> | null
    /**
     * Filter, which diagnosistypemapping to fetch.
     */
    where?: diagnosistypemappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diagnosistypemappings to fetch.
     */
    orderBy?: diagnosistypemappingOrderByWithRelationInput | diagnosistypemappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for diagnosistypemappings.
     */
    cursor?: diagnosistypemappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diagnosistypemappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diagnosistypemappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of diagnosistypemappings.
     */
    distinct?: DiagnosistypemappingScalarFieldEnum | DiagnosistypemappingScalarFieldEnum[]
  }

  /**
   * diagnosistypemapping findFirstOrThrow
   */
  export type diagnosistypemappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnosistypemapping
     */
    select?: diagnosistypemappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosistypemappingInclude<ExtArgs> | null
    /**
     * Filter, which diagnosistypemapping to fetch.
     */
    where?: diagnosistypemappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diagnosistypemappings to fetch.
     */
    orderBy?: diagnosistypemappingOrderByWithRelationInput | diagnosistypemappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for diagnosistypemappings.
     */
    cursor?: diagnosistypemappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diagnosistypemappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diagnosistypemappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of diagnosistypemappings.
     */
    distinct?: DiagnosistypemappingScalarFieldEnum | DiagnosistypemappingScalarFieldEnum[]
  }

  /**
   * diagnosistypemapping findMany
   */
  export type diagnosistypemappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnosistypemapping
     */
    select?: diagnosistypemappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosistypemappingInclude<ExtArgs> | null
    /**
     * Filter, which diagnosistypemappings to fetch.
     */
    where?: diagnosistypemappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diagnosistypemappings to fetch.
     */
    orderBy?: diagnosistypemappingOrderByWithRelationInput | diagnosistypemappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing diagnosistypemappings.
     */
    cursor?: diagnosistypemappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diagnosistypemappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diagnosistypemappings.
     */
    skip?: number
    distinct?: DiagnosistypemappingScalarFieldEnum | DiagnosistypemappingScalarFieldEnum[]
  }

  /**
   * diagnosistypemapping create
   */
  export type diagnosistypemappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnosistypemapping
     */
    select?: diagnosistypemappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosistypemappingInclude<ExtArgs> | null
    /**
     * The data needed to create a diagnosistypemapping.
     */
    data: XOR<diagnosistypemappingCreateInput, diagnosistypemappingUncheckedCreateInput>
  }

  /**
   * diagnosistypemapping createMany
   */
  export type diagnosistypemappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many diagnosistypemappings.
     */
    data: diagnosistypemappingCreateManyInput | diagnosistypemappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * diagnosistypemapping createManyAndReturn
   */
  export type diagnosistypemappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnosistypemapping
     */
    select?: diagnosistypemappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many diagnosistypemappings.
     */
    data: diagnosistypemappingCreateManyInput | diagnosistypemappingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosistypemappingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * diagnosistypemapping update
   */
  export type diagnosistypemappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnosistypemapping
     */
    select?: diagnosistypemappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosistypemappingInclude<ExtArgs> | null
    /**
     * The data needed to update a diagnosistypemapping.
     */
    data: XOR<diagnosistypemappingUpdateInput, diagnosistypemappingUncheckedUpdateInput>
    /**
     * Choose, which diagnosistypemapping to update.
     */
    where: diagnosistypemappingWhereUniqueInput
  }

  /**
   * diagnosistypemapping updateMany
   */
  export type diagnosistypemappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update diagnosistypemappings.
     */
    data: XOR<diagnosistypemappingUpdateManyMutationInput, diagnosistypemappingUncheckedUpdateManyInput>
    /**
     * Filter which diagnosistypemappings to update
     */
    where?: diagnosistypemappingWhereInput
  }

  /**
   * diagnosistypemapping upsert
   */
  export type diagnosistypemappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnosistypemapping
     */
    select?: diagnosistypemappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosistypemappingInclude<ExtArgs> | null
    /**
     * The filter to search for the diagnosistypemapping to update in case it exists.
     */
    where: diagnosistypemappingWhereUniqueInput
    /**
     * In case the diagnosistypemapping found by the `where` argument doesn't exist, create a new diagnosistypemapping with this data.
     */
    create: XOR<diagnosistypemappingCreateInput, diagnosistypemappingUncheckedCreateInput>
    /**
     * In case the diagnosistypemapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<diagnosistypemappingUpdateInput, diagnosistypemappingUncheckedUpdateInput>
  }

  /**
   * diagnosistypemapping delete
   */
  export type diagnosistypemappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnosistypemapping
     */
    select?: diagnosistypemappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosistypemappingInclude<ExtArgs> | null
    /**
     * Filter which diagnosistypemapping to delete.
     */
    where: diagnosistypemappingWhereUniqueInput
  }

  /**
   * diagnosistypemapping deleteMany
   */
  export type diagnosistypemappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which diagnosistypemappings to delete
     */
    where?: diagnosistypemappingWhereInput
  }

  /**
   * diagnosistypemapping.insurers
   */
  export type diagnosistypemapping$insurersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insurers
     */
    select?: insurersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: insurersInclude<ExtArgs> | null
    where?: insurersWhereInput
  }

  /**
   * diagnosistypemapping without action
   */
  export type diagnosistypemappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnosistypemapping
     */
    select?: diagnosistypemappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosistypemappingInclude<ExtArgs> | null
  }


  /**
   * Model documenttype
   */

  export type AggregateDocumenttype = {
    _count: DocumenttypeCountAggregateOutputType | null
    _avg: DocumenttypeAvgAggregateOutputType | null
    _sum: DocumenttypeSumAggregateOutputType | null
    _min: DocumenttypeMinAggregateOutputType | null
    _max: DocumenttypeMaxAggregateOutputType | null
  }

  export type DocumenttypeAvgAggregateOutputType = {
    id: number | null
    insurerid: number | null
  }

  export type DocumenttypeSumAggregateOutputType = {
    id: number | null
    insurerid: number | null
  }

  export type DocumenttypeMinAggregateOutputType = {
    id: number | null
    documenttypecode: string | null
    documenttypename: string | null
    insurerid: number | null
  }

  export type DocumenttypeMaxAggregateOutputType = {
    id: number | null
    documenttypecode: string | null
    documenttypename: string | null
    insurerid: number | null
  }

  export type DocumenttypeCountAggregateOutputType = {
    id: number
    documenttypecode: number
    documenttypename: number
    insurerid: number
    _all: number
  }


  export type DocumenttypeAvgAggregateInputType = {
    id?: true
    insurerid?: true
  }

  export type DocumenttypeSumAggregateInputType = {
    id?: true
    insurerid?: true
  }

  export type DocumenttypeMinAggregateInputType = {
    id?: true
    documenttypecode?: true
    documenttypename?: true
    insurerid?: true
  }

  export type DocumenttypeMaxAggregateInputType = {
    id?: true
    documenttypecode?: true
    documenttypename?: true
    insurerid?: true
  }

  export type DocumenttypeCountAggregateInputType = {
    id?: true
    documenttypecode?: true
    documenttypename?: true
    insurerid?: true
    _all?: true
  }

  export type DocumenttypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which documenttype to aggregate.
     */
    where?: documenttypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documenttypes to fetch.
     */
    orderBy?: documenttypeOrderByWithRelationInput | documenttypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: documenttypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documenttypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documenttypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned documenttypes
    **/
    _count?: true | DocumenttypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumenttypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumenttypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumenttypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumenttypeMaxAggregateInputType
  }

  export type GetDocumenttypeAggregateType<T extends DocumenttypeAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumenttype]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumenttype[P]>
      : GetScalarType<T[P], AggregateDocumenttype[P]>
  }




  export type documenttypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: documenttypeWhereInput
    orderBy?: documenttypeOrderByWithAggregationInput | documenttypeOrderByWithAggregationInput[]
    by: DocumenttypeScalarFieldEnum[] | DocumenttypeScalarFieldEnum
    having?: documenttypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumenttypeCountAggregateInputType | true
    _avg?: DocumenttypeAvgAggregateInputType
    _sum?: DocumenttypeSumAggregateInputType
    _min?: DocumenttypeMinAggregateInputType
    _max?: DocumenttypeMaxAggregateInputType
  }

  export type DocumenttypeGroupByOutputType = {
    id: number
    documenttypecode: string
    documenttypename: string | null
    insurerid: number | null
    _count: DocumenttypeCountAggregateOutputType | null
    _avg: DocumenttypeAvgAggregateOutputType | null
    _sum: DocumenttypeSumAggregateOutputType | null
    _min: DocumenttypeMinAggregateOutputType | null
    _max: DocumenttypeMaxAggregateOutputType | null
  }

  type GetDocumenttypeGroupByPayload<T extends documenttypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumenttypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumenttypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumenttypeGroupByOutputType[P]>
            : GetScalarType<T[P], DocumenttypeGroupByOutputType[P]>
        }
      >
    >


  export type documenttypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documenttypecode?: boolean
    documenttypename?: boolean
    insurerid?: boolean
    insurers?: boolean | documenttype$insurersArgs<ExtArgs>
  }, ExtArgs["result"]["documenttype"]>

  export type documenttypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documenttypecode?: boolean
    documenttypename?: boolean
    insurerid?: boolean
    insurers?: boolean | documenttype$insurersArgs<ExtArgs>
  }, ExtArgs["result"]["documenttype"]>

  export type documenttypeSelectScalar = {
    id?: boolean
    documenttypecode?: boolean
    documenttypename?: boolean
    insurerid?: boolean
  }

  export type documenttypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurers?: boolean | documenttype$insurersArgs<ExtArgs>
  }
  export type documenttypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurers?: boolean | documenttype$insurersArgs<ExtArgs>
  }

  export type $documenttypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "documenttype"
    objects: {
      insurers: Prisma.$insurersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      documenttypecode: string
      documenttypename: string | null
      insurerid: number | null
    }, ExtArgs["result"]["documenttype"]>
    composites: {}
  }

  type documenttypeGetPayload<S extends boolean | null | undefined | documenttypeDefaultArgs> = $Result.GetResult<Prisma.$documenttypePayload, S>

  type documenttypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<documenttypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumenttypeCountAggregateInputType | true
    }

  export interface documenttypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['documenttype'], meta: { name: 'documenttype' } }
    /**
     * Find zero or one Documenttype that matches the filter.
     * @param {documenttypeFindUniqueArgs} args - Arguments to find a Documenttype
     * @example
     * // Get one Documenttype
     * const documenttype = await prisma.documenttype.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends documenttypeFindUniqueArgs>(args: SelectSubset<T, documenttypeFindUniqueArgs<ExtArgs>>): Prisma__documenttypeClient<$Result.GetResult<Prisma.$documenttypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Documenttype that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {documenttypeFindUniqueOrThrowArgs} args - Arguments to find a Documenttype
     * @example
     * // Get one Documenttype
     * const documenttype = await prisma.documenttype.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends documenttypeFindUniqueOrThrowArgs>(args: SelectSubset<T, documenttypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__documenttypeClient<$Result.GetResult<Prisma.$documenttypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Documenttype that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documenttypeFindFirstArgs} args - Arguments to find a Documenttype
     * @example
     * // Get one Documenttype
     * const documenttype = await prisma.documenttype.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends documenttypeFindFirstArgs>(args?: SelectSubset<T, documenttypeFindFirstArgs<ExtArgs>>): Prisma__documenttypeClient<$Result.GetResult<Prisma.$documenttypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Documenttype that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documenttypeFindFirstOrThrowArgs} args - Arguments to find a Documenttype
     * @example
     * // Get one Documenttype
     * const documenttype = await prisma.documenttype.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends documenttypeFindFirstOrThrowArgs>(args?: SelectSubset<T, documenttypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__documenttypeClient<$Result.GetResult<Prisma.$documenttypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Documenttypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documenttypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documenttypes
     * const documenttypes = await prisma.documenttype.findMany()
     * 
     * // Get first 10 Documenttypes
     * const documenttypes = await prisma.documenttype.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documenttypeWithIdOnly = await prisma.documenttype.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends documenttypeFindManyArgs>(args?: SelectSubset<T, documenttypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$documenttypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Documenttype.
     * @param {documenttypeCreateArgs} args - Arguments to create a Documenttype.
     * @example
     * // Create one Documenttype
     * const Documenttype = await prisma.documenttype.create({
     *   data: {
     *     // ... data to create a Documenttype
     *   }
     * })
     * 
     */
    create<T extends documenttypeCreateArgs>(args: SelectSubset<T, documenttypeCreateArgs<ExtArgs>>): Prisma__documenttypeClient<$Result.GetResult<Prisma.$documenttypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Documenttypes.
     * @param {documenttypeCreateManyArgs} args - Arguments to create many Documenttypes.
     * @example
     * // Create many Documenttypes
     * const documenttype = await prisma.documenttype.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends documenttypeCreateManyArgs>(args?: SelectSubset<T, documenttypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documenttypes and returns the data saved in the database.
     * @param {documenttypeCreateManyAndReturnArgs} args - Arguments to create many Documenttypes.
     * @example
     * // Create many Documenttypes
     * const documenttype = await prisma.documenttype.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documenttypes and only return the `id`
     * const documenttypeWithIdOnly = await prisma.documenttype.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends documenttypeCreateManyAndReturnArgs>(args?: SelectSubset<T, documenttypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$documenttypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Documenttype.
     * @param {documenttypeDeleteArgs} args - Arguments to delete one Documenttype.
     * @example
     * // Delete one Documenttype
     * const Documenttype = await prisma.documenttype.delete({
     *   where: {
     *     // ... filter to delete one Documenttype
     *   }
     * })
     * 
     */
    delete<T extends documenttypeDeleteArgs>(args: SelectSubset<T, documenttypeDeleteArgs<ExtArgs>>): Prisma__documenttypeClient<$Result.GetResult<Prisma.$documenttypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Documenttype.
     * @param {documenttypeUpdateArgs} args - Arguments to update one Documenttype.
     * @example
     * // Update one Documenttype
     * const documenttype = await prisma.documenttype.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends documenttypeUpdateArgs>(args: SelectSubset<T, documenttypeUpdateArgs<ExtArgs>>): Prisma__documenttypeClient<$Result.GetResult<Prisma.$documenttypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Documenttypes.
     * @param {documenttypeDeleteManyArgs} args - Arguments to filter Documenttypes to delete.
     * @example
     * // Delete a few Documenttypes
     * const { count } = await prisma.documenttype.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends documenttypeDeleteManyArgs>(args?: SelectSubset<T, documenttypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documenttypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documenttypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documenttypes
     * const documenttype = await prisma.documenttype.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends documenttypeUpdateManyArgs>(args: SelectSubset<T, documenttypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Documenttype.
     * @param {documenttypeUpsertArgs} args - Arguments to update or create a Documenttype.
     * @example
     * // Update or create a Documenttype
     * const documenttype = await prisma.documenttype.upsert({
     *   create: {
     *     // ... data to create a Documenttype
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Documenttype we want to update
     *   }
     * })
     */
    upsert<T extends documenttypeUpsertArgs>(args: SelectSubset<T, documenttypeUpsertArgs<ExtArgs>>): Prisma__documenttypeClient<$Result.GetResult<Prisma.$documenttypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Documenttypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documenttypeCountArgs} args - Arguments to filter Documenttypes to count.
     * @example
     * // Count the number of Documenttypes
     * const count = await prisma.documenttype.count({
     *   where: {
     *     // ... the filter for the Documenttypes we want to count
     *   }
     * })
    **/
    count<T extends documenttypeCountArgs>(
      args?: Subset<T, documenttypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumenttypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Documenttype.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumenttypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumenttypeAggregateArgs>(args: Subset<T, DocumenttypeAggregateArgs>): Prisma.PrismaPromise<GetDocumenttypeAggregateType<T>>

    /**
     * Group by Documenttype.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documenttypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends documenttypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: documenttypeGroupByArgs['orderBy'] }
        : { orderBy?: documenttypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, documenttypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumenttypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the documenttype model
   */
  readonly fields: documenttypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for documenttype.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__documenttypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    insurers<T extends documenttype$insurersArgs<ExtArgs> = {}>(args?: Subset<T, documenttype$insurersArgs<ExtArgs>>): Prisma__insurersClient<$Result.GetResult<Prisma.$insurersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the documenttype model
   */ 
  interface documenttypeFieldRefs {
    readonly id: FieldRef<"documenttype", 'Int'>
    readonly documenttypecode: FieldRef<"documenttype", 'String'>
    readonly documenttypename: FieldRef<"documenttype", 'String'>
    readonly insurerid: FieldRef<"documenttype", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * documenttype findUnique
   */
  export type documenttypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documenttype
     */
    select?: documenttypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documenttypeInclude<ExtArgs> | null
    /**
     * Filter, which documenttype to fetch.
     */
    where: documenttypeWhereUniqueInput
  }

  /**
   * documenttype findUniqueOrThrow
   */
  export type documenttypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documenttype
     */
    select?: documenttypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documenttypeInclude<ExtArgs> | null
    /**
     * Filter, which documenttype to fetch.
     */
    where: documenttypeWhereUniqueInput
  }

  /**
   * documenttype findFirst
   */
  export type documenttypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documenttype
     */
    select?: documenttypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documenttypeInclude<ExtArgs> | null
    /**
     * Filter, which documenttype to fetch.
     */
    where?: documenttypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documenttypes to fetch.
     */
    orderBy?: documenttypeOrderByWithRelationInput | documenttypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for documenttypes.
     */
    cursor?: documenttypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documenttypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documenttypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of documenttypes.
     */
    distinct?: DocumenttypeScalarFieldEnum | DocumenttypeScalarFieldEnum[]
  }

  /**
   * documenttype findFirstOrThrow
   */
  export type documenttypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documenttype
     */
    select?: documenttypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documenttypeInclude<ExtArgs> | null
    /**
     * Filter, which documenttype to fetch.
     */
    where?: documenttypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documenttypes to fetch.
     */
    orderBy?: documenttypeOrderByWithRelationInput | documenttypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for documenttypes.
     */
    cursor?: documenttypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documenttypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documenttypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of documenttypes.
     */
    distinct?: DocumenttypeScalarFieldEnum | DocumenttypeScalarFieldEnum[]
  }

  /**
   * documenttype findMany
   */
  export type documenttypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documenttype
     */
    select?: documenttypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documenttypeInclude<ExtArgs> | null
    /**
     * Filter, which documenttypes to fetch.
     */
    where?: documenttypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documenttypes to fetch.
     */
    orderBy?: documenttypeOrderByWithRelationInput | documenttypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing documenttypes.
     */
    cursor?: documenttypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documenttypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documenttypes.
     */
    skip?: number
    distinct?: DocumenttypeScalarFieldEnum | DocumenttypeScalarFieldEnum[]
  }

  /**
   * documenttype create
   */
  export type documenttypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documenttype
     */
    select?: documenttypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documenttypeInclude<ExtArgs> | null
    /**
     * The data needed to create a documenttype.
     */
    data: XOR<documenttypeCreateInput, documenttypeUncheckedCreateInput>
  }

  /**
   * documenttype createMany
   */
  export type documenttypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many documenttypes.
     */
    data: documenttypeCreateManyInput | documenttypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * documenttype createManyAndReturn
   */
  export type documenttypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documenttype
     */
    select?: documenttypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many documenttypes.
     */
    data: documenttypeCreateManyInput | documenttypeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documenttypeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * documenttype update
   */
  export type documenttypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documenttype
     */
    select?: documenttypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documenttypeInclude<ExtArgs> | null
    /**
     * The data needed to update a documenttype.
     */
    data: XOR<documenttypeUpdateInput, documenttypeUncheckedUpdateInput>
    /**
     * Choose, which documenttype to update.
     */
    where: documenttypeWhereUniqueInput
  }

  /**
   * documenttype updateMany
   */
  export type documenttypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update documenttypes.
     */
    data: XOR<documenttypeUpdateManyMutationInput, documenttypeUncheckedUpdateManyInput>
    /**
     * Filter which documenttypes to update
     */
    where?: documenttypeWhereInput
  }

  /**
   * documenttype upsert
   */
  export type documenttypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documenttype
     */
    select?: documenttypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documenttypeInclude<ExtArgs> | null
    /**
     * The filter to search for the documenttype to update in case it exists.
     */
    where: documenttypeWhereUniqueInput
    /**
     * In case the documenttype found by the `where` argument doesn't exist, create a new documenttype with this data.
     */
    create: XOR<documenttypeCreateInput, documenttypeUncheckedCreateInput>
    /**
     * In case the documenttype was found with the provided `where` argument, update it with this data.
     */
    update: XOR<documenttypeUpdateInput, documenttypeUncheckedUpdateInput>
  }

  /**
   * documenttype delete
   */
  export type documenttypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documenttype
     */
    select?: documenttypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documenttypeInclude<ExtArgs> | null
    /**
     * Filter which documenttype to delete.
     */
    where: documenttypeWhereUniqueInput
  }

  /**
   * documenttype deleteMany
   */
  export type documenttypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which documenttypes to delete
     */
    where?: documenttypeWhereInput
  }

  /**
   * documenttype.insurers
   */
  export type documenttype$insurersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insurers
     */
    select?: insurersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: insurersInclude<ExtArgs> | null
    where?: insurersWhereInput
  }

  /**
   * documenttype without action
   */
  export type documenttypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documenttype
     */
    select?: documenttypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documenttypeInclude<ExtArgs> | null
  }


  /**
   * Model illnesssurgery
   */

  export type AggregateIllnesssurgery = {
    _count: IllnesssurgeryCountAggregateOutputType | null
    _avg: IllnesssurgeryAvgAggregateOutputType | null
    _sum: IllnesssurgerySumAggregateOutputType | null
    _min: IllnesssurgeryMinAggregateOutputType | null
    _max: IllnesssurgeryMaxAggregateOutputType | null
  }

  export type IllnesssurgeryAvgAggregateOutputType = {
    id: number | null
    insurerid: number | null
  }

  export type IllnesssurgerySumAggregateOutputType = {
    id: number | null
    insurerid: number | null
  }

  export type IllnesssurgeryMinAggregateOutputType = {
    id: number | null
    iscode: string | null
    isdesc: string | null
    insurerid: number | null
  }

  export type IllnesssurgeryMaxAggregateOutputType = {
    id: number | null
    iscode: string | null
    isdesc: string | null
    insurerid: number | null
  }

  export type IllnesssurgeryCountAggregateOutputType = {
    id: number
    iscode: number
    isdesc: number
    insurerid: number
    _all: number
  }


  export type IllnesssurgeryAvgAggregateInputType = {
    id?: true
    insurerid?: true
  }

  export type IllnesssurgerySumAggregateInputType = {
    id?: true
    insurerid?: true
  }

  export type IllnesssurgeryMinAggregateInputType = {
    id?: true
    iscode?: true
    isdesc?: true
    insurerid?: true
  }

  export type IllnesssurgeryMaxAggregateInputType = {
    id?: true
    iscode?: true
    isdesc?: true
    insurerid?: true
  }

  export type IllnesssurgeryCountAggregateInputType = {
    id?: true
    iscode?: true
    isdesc?: true
    insurerid?: true
    _all?: true
  }

  export type IllnesssurgeryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which illnesssurgery to aggregate.
     */
    where?: illnesssurgeryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of illnesssurgeries to fetch.
     */
    orderBy?: illnesssurgeryOrderByWithRelationInput | illnesssurgeryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: illnesssurgeryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` illnesssurgeries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` illnesssurgeries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned illnesssurgeries
    **/
    _count?: true | IllnesssurgeryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IllnesssurgeryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IllnesssurgerySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IllnesssurgeryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IllnesssurgeryMaxAggregateInputType
  }

  export type GetIllnesssurgeryAggregateType<T extends IllnesssurgeryAggregateArgs> = {
        [P in keyof T & keyof AggregateIllnesssurgery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIllnesssurgery[P]>
      : GetScalarType<T[P], AggregateIllnesssurgery[P]>
  }




  export type illnesssurgeryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: illnesssurgeryWhereInput
    orderBy?: illnesssurgeryOrderByWithAggregationInput | illnesssurgeryOrderByWithAggregationInput[]
    by: IllnesssurgeryScalarFieldEnum[] | IllnesssurgeryScalarFieldEnum
    having?: illnesssurgeryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IllnesssurgeryCountAggregateInputType | true
    _avg?: IllnesssurgeryAvgAggregateInputType
    _sum?: IllnesssurgerySumAggregateInputType
    _min?: IllnesssurgeryMinAggregateInputType
    _max?: IllnesssurgeryMaxAggregateInputType
  }

  export type IllnesssurgeryGroupByOutputType = {
    id: number
    iscode: string
    isdesc: string | null
    insurerid: number | null
    _count: IllnesssurgeryCountAggregateOutputType | null
    _avg: IllnesssurgeryAvgAggregateOutputType | null
    _sum: IllnesssurgerySumAggregateOutputType | null
    _min: IllnesssurgeryMinAggregateOutputType | null
    _max: IllnesssurgeryMaxAggregateOutputType | null
  }

  type GetIllnesssurgeryGroupByPayload<T extends illnesssurgeryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IllnesssurgeryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IllnesssurgeryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IllnesssurgeryGroupByOutputType[P]>
            : GetScalarType<T[P], IllnesssurgeryGroupByOutputType[P]>
        }
      >
    >


  export type illnesssurgerySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    iscode?: boolean
    isdesc?: boolean
    insurerid?: boolean
    insurers?: boolean | illnesssurgery$insurersArgs<ExtArgs>
  }, ExtArgs["result"]["illnesssurgery"]>

  export type illnesssurgerySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    iscode?: boolean
    isdesc?: boolean
    insurerid?: boolean
    insurers?: boolean | illnesssurgery$insurersArgs<ExtArgs>
  }, ExtArgs["result"]["illnesssurgery"]>

  export type illnesssurgerySelectScalar = {
    id?: boolean
    iscode?: boolean
    isdesc?: boolean
    insurerid?: boolean
  }

  export type illnesssurgeryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurers?: boolean | illnesssurgery$insurersArgs<ExtArgs>
  }
  export type illnesssurgeryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurers?: boolean | illnesssurgery$insurersArgs<ExtArgs>
  }

  export type $illnesssurgeryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "illnesssurgery"
    objects: {
      insurers: Prisma.$insurersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      iscode: string
      isdesc: string | null
      insurerid: number | null
    }, ExtArgs["result"]["illnesssurgery"]>
    composites: {}
  }

  type illnesssurgeryGetPayload<S extends boolean | null | undefined | illnesssurgeryDefaultArgs> = $Result.GetResult<Prisma.$illnesssurgeryPayload, S>

  type illnesssurgeryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<illnesssurgeryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IllnesssurgeryCountAggregateInputType | true
    }

  export interface illnesssurgeryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['illnesssurgery'], meta: { name: 'illnesssurgery' } }
    /**
     * Find zero or one Illnesssurgery that matches the filter.
     * @param {illnesssurgeryFindUniqueArgs} args - Arguments to find a Illnesssurgery
     * @example
     * // Get one Illnesssurgery
     * const illnesssurgery = await prisma.illnesssurgery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends illnesssurgeryFindUniqueArgs>(args: SelectSubset<T, illnesssurgeryFindUniqueArgs<ExtArgs>>): Prisma__illnesssurgeryClient<$Result.GetResult<Prisma.$illnesssurgeryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Illnesssurgery that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {illnesssurgeryFindUniqueOrThrowArgs} args - Arguments to find a Illnesssurgery
     * @example
     * // Get one Illnesssurgery
     * const illnesssurgery = await prisma.illnesssurgery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends illnesssurgeryFindUniqueOrThrowArgs>(args: SelectSubset<T, illnesssurgeryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__illnesssurgeryClient<$Result.GetResult<Prisma.$illnesssurgeryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Illnesssurgery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {illnesssurgeryFindFirstArgs} args - Arguments to find a Illnesssurgery
     * @example
     * // Get one Illnesssurgery
     * const illnesssurgery = await prisma.illnesssurgery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends illnesssurgeryFindFirstArgs>(args?: SelectSubset<T, illnesssurgeryFindFirstArgs<ExtArgs>>): Prisma__illnesssurgeryClient<$Result.GetResult<Prisma.$illnesssurgeryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Illnesssurgery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {illnesssurgeryFindFirstOrThrowArgs} args - Arguments to find a Illnesssurgery
     * @example
     * // Get one Illnesssurgery
     * const illnesssurgery = await prisma.illnesssurgery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends illnesssurgeryFindFirstOrThrowArgs>(args?: SelectSubset<T, illnesssurgeryFindFirstOrThrowArgs<ExtArgs>>): Prisma__illnesssurgeryClient<$Result.GetResult<Prisma.$illnesssurgeryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Illnesssurgeries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {illnesssurgeryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Illnesssurgeries
     * const illnesssurgeries = await prisma.illnesssurgery.findMany()
     * 
     * // Get first 10 Illnesssurgeries
     * const illnesssurgeries = await prisma.illnesssurgery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const illnesssurgeryWithIdOnly = await prisma.illnesssurgery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends illnesssurgeryFindManyArgs>(args?: SelectSubset<T, illnesssurgeryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$illnesssurgeryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Illnesssurgery.
     * @param {illnesssurgeryCreateArgs} args - Arguments to create a Illnesssurgery.
     * @example
     * // Create one Illnesssurgery
     * const Illnesssurgery = await prisma.illnesssurgery.create({
     *   data: {
     *     // ... data to create a Illnesssurgery
     *   }
     * })
     * 
     */
    create<T extends illnesssurgeryCreateArgs>(args: SelectSubset<T, illnesssurgeryCreateArgs<ExtArgs>>): Prisma__illnesssurgeryClient<$Result.GetResult<Prisma.$illnesssurgeryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Illnesssurgeries.
     * @param {illnesssurgeryCreateManyArgs} args - Arguments to create many Illnesssurgeries.
     * @example
     * // Create many Illnesssurgeries
     * const illnesssurgery = await prisma.illnesssurgery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends illnesssurgeryCreateManyArgs>(args?: SelectSubset<T, illnesssurgeryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Illnesssurgeries and returns the data saved in the database.
     * @param {illnesssurgeryCreateManyAndReturnArgs} args - Arguments to create many Illnesssurgeries.
     * @example
     * // Create many Illnesssurgeries
     * const illnesssurgery = await prisma.illnesssurgery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Illnesssurgeries and only return the `id`
     * const illnesssurgeryWithIdOnly = await prisma.illnesssurgery.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends illnesssurgeryCreateManyAndReturnArgs>(args?: SelectSubset<T, illnesssurgeryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$illnesssurgeryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Illnesssurgery.
     * @param {illnesssurgeryDeleteArgs} args - Arguments to delete one Illnesssurgery.
     * @example
     * // Delete one Illnesssurgery
     * const Illnesssurgery = await prisma.illnesssurgery.delete({
     *   where: {
     *     // ... filter to delete one Illnesssurgery
     *   }
     * })
     * 
     */
    delete<T extends illnesssurgeryDeleteArgs>(args: SelectSubset<T, illnesssurgeryDeleteArgs<ExtArgs>>): Prisma__illnesssurgeryClient<$Result.GetResult<Prisma.$illnesssurgeryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Illnesssurgery.
     * @param {illnesssurgeryUpdateArgs} args - Arguments to update one Illnesssurgery.
     * @example
     * // Update one Illnesssurgery
     * const illnesssurgery = await prisma.illnesssurgery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends illnesssurgeryUpdateArgs>(args: SelectSubset<T, illnesssurgeryUpdateArgs<ExtArgs>>): Prisma__illnesssurgeryClient<$Result.GetResult<Prisma.$illnesssurgeryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Illnesssurgeries.
     * @param {illnesssurgeryDeleteManyArgs} args - Arguments to filter Illnesssurgeries to delete.
     * @example
     * // Delete a few Illnesssurgeries
     * const { count } = await prisma.illnesssurgery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends illnesssurgeryDeleteManyArgs>(args?: SelectSubset<T, illnesssurgeryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Illnesssurgeries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {illnesssurgeryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Illnesssurgeries
     * const illnesssurgery = await prisma.illnesssurgery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends illnesssurgeryUpdateManyArgs>(args: SelectSubset<T, illnesssurgeryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Illnesssurgery.
     * @param {illnesssurgeryUpsertArgs} args - Arguments to update or create a Illnesssurgery.
     * @example
     * // Update or create a Illnesssurgery
     * const illnesssurgery = await prisma.illnesssurgery.upsert({
     *   create: {
     *     // ... data to create a Illnesssurgery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Illnesssurgery we want to update
     *   }
     * })
     */
    upsert<T extends illnesssurgeryUpsertArgs>(args: SelectSubset<T, illnesssurgeryUpsertArgs<ExtArgs>>): Prisma__illnesssurgeryClient<$Result.GetResult<Prisma.$illnesssurgeryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Illnesssurgeries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {illnesssurgeryCountArgs} args - Arguments to filter Illnesssurgeries to count.
     * @example
     * // Count the number of Illnesssurgeries
     * const count = await prisma.illnesssurgery.count({
     *   where: {
     *     // ... the filter for the Illnesssurgeries we want to count
     *   }
     * })
    **/
    count<T extends illnesssurgeryCountArgs>(
      args?: Subset<T, illnesssurgeryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IllnesssurgeryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Illnesssurgery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IllnesssurgeryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IllnesssurgeryAggregateArgs>(args: Subset<T, IllnesssurgeryAggregateArgs>): Prisma.PrismaPromise<GetIllnesssurgeryAggregateType<T>>

    /**
     * Group by Illnesssurgery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {illnesssurgeryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends illnesssurgeryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: illnesssurgeryGroupByArgs['orderBy'] }
        : { orderBy?: illnesssurgeryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, illnesssurgeryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIllnesssurgeryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the illnesssurgery model
   */
  readonly fields: illnesssurgeryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for illnesssurgery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__illnesssurgeryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    insurers<T extends illnesssurgery$insurersArgs<ExtArgs> = {}>(args?: Subset<T, illnesssurgery$insurersArgs<ExtArgs>>): Prisma__insurersClient<$Result.GetResult<Prisma.$insurersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the illnesssurgery model
   */ 
  interface illnesssurgeryFieldRefs {
    readonly id: FieldRef<"illnesssurgery", 'Int'>
    readonly iscode: FieldRef<"illnesssurgery", 'String'>
    readonly isdesc: FieldRef<"illnesssurgery", 'String'>
    readonly insurerid: FieldRef<"illnesssurgery", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * illnesssurgery findUnique
   */
  export type illnesssurgeryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the illnesssurgery
     */
    select?: illnesssurgerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: illnesssurgeryInclude<ExtArgs> | null
    /**
     * Filter, which illnesssurgery to fetch.
     */
    where: illnesssurgeryWhereUniqueInput
  }

  /**
   * illnesssurgery findUniqueOrThrow
   */
  export type illnesssurgeryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the illnesssurgery
     */
    select?: illnesssurgerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: illnesssurgeryInclude<ExtArgs> | null
    /**
     * Filter, which illnesssurgery to fetch.
     */
    where: illnesssurgeryWhereUniqueInput
  }

  /**
   * illnesssurgery findFirst
   */
  export type illnesssurgeryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the illnesssurgery
     */
    select?: illnesssurgerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: illnesssurgeryInclude<ExtArgs> | null
    /**
     * Filter, which illnesssurgery to fetch.
     */
    where?: illnesssurgeryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of illnesssurgeries to fetch.
     */
    orderBy?: illnesssurgeryOrderByWithRelationInput | illnesssurgeryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for illnesssurgeries.
     */
    cursor?: illnesssurgeryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` illnesssurgeries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` illnesssurgeries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of illnesssurgeries.
     */
    distinct?: IllnesssurgeryScalarFieldEnum | IllnesssurgeryScalarFieldEnum[]
  }

  /**
   * illnesssurgery findFirstOrThrow
   */
  export type illnesssurgeryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the illnesssurgery
     */
    select?: illnesssurgerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: illnesssurgeryInclude<ExtArgs> | null
    /**
     * Filter, which illnesssurgery to fetch.
     */
    where?: illnesssurgeryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of illnesssurgeries to fetch.
     */
    orderBy?: illnesssurgeryOrderByWithRelationInput | illnesssurgeryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for illnesssurgeries.
     */
    cursor?: illnesssurgeryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` illnesssurgeries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` illnesssurgeries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of illnesssurgeries.
     */
    distinct?: IllnesssurgeryScalarFieldEnum | IllnesssurgeryScalarFieldEnum[]
  }

  /**
   * illnesssurgery findMany
   */
  export type illnesssurgeryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the illnesssurgery
     */
    select?: illnesssurgerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: illnesssurgeryInclude<ExtArgs> | null
    /**
     * Filter, which illnesssurgeries to fetch.
     */
    where?: illnesssurgeryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of illnesssurgeries to fetch.
     */
    orderBy?: illnesssurgeryOrderByWithRelationInput | illnesssurgeryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing illnesssurgeries.
     */
    cursor?: illnesssurgeryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` illnesssurgeries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` illnesssurgeries.
     */
    skip?: number
    distinct?: IllnesssurgeryScalarFieldEnum | IllnesssurgeryScalarFieldEnum[]
  }

  /**
   * illnesssurgery create
   */
  export type illnesssurgeryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the illnesssurgery
     */
    select?: illnesssurgerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: illnesssurgeryInclude<ExtArgs> | null
    /**
     * The data needed to create a illnesssurgery.
     */
    data: XOR<illnesssurgeryCreateInput, illnesssurgeryUncheckedCreateInput>
  }

  /**
   * illnesssurgery createMany
   */
  export type illnesssurgeryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many illnesssurgeries.
     */
    data: illnesssurgeryCreateManyInput | illnesssurgeryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * illnesssurgery createManyAndReturn
   */
  export type illnesssurgeryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the illnesssurgery
     */
    select?: illnesssurgerySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many illnesssurgeries.
     */
    data: illnesssurgeryCreateManyInput | illnesssurgeryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: illnesssurgeryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * illnesssurgery update
   */
  export type illnesssurgeryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the illnesssurgery
     */
    select?: illnesssurgerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: illnesssurgeryInclude<ExtArgs> | null
    /**
     * The data needed to update a illnesssurgery.
     */
    data: XOR<illnesssurgeryUpdateInput, illnesssurgeryUncheckedUpdateInput>
    /**
     * Choose, which illnesssurgery to update.
     */
    where: illnesssurgeryWhereUniqueInput
  }

  /**
   * illnesssurgery updateMany
   */
  export type illnesssurgeryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update illnesssurgeries.
     */
    data: XOR<illnesssurgeryUpdateManyMutationInput, illnesssurgeryUncheckedUpdateManyInput>
    /**
     * Filter which illnesssurgeries to update
     */
    where?: illnesssurgeryWhereInput
  }

  /**
   * illnesssurgery upsert
   */
  export type illnesssurgeryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the illnesssurgery
     */
    select?: illnesssurgerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: illnesssurgeryInclude<ExtArgs> | null
    /**
     * The filter to search for the illnesssurgery to update in case it exists.
     */
    where: illnesssurgeryWhereUniqueInput
    /**
     * In case the illnesssurgery found by the `where` argument doesn't exist, create a new illnesssurgery with this data.
     */
    create: XOR<illnesssurgeryCreateInput, illnesssurgeryUncheckedCreateInput>
    /**
     * In case the illnesssurgery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<illnesssurgeryUpdateInput, illnesssurgeryUncheckedUpdateInput>
  }

  /**
   * illnesssurgery delete
   */
  export type illnesssurgeryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the illnesssurgery
     */
    select?: illnesssurgerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: illnesssurgeryInclude<ExtArgs> | null
    /**
     * Filter which illnesssurgery to delete.
     */
    where: illnesssurgeryWhereUniqueInput
  }

  /**
   * illnesssurgery deleteMany
   */
  export type illnesssurgeryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which illnesssurgeries to delete
     */
    where?: illnesssurgeryWhereInput
  }

  /**
   * illnesssurgery.insurers
   */
  export type illnesssurgery$insurersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insurers
     */
    select?: insurersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: insurersInclude<ExtArgs> | null
    where?: insurersWhereInput
  }

  /**
   * illnesssurgery without action
   */
  export type illnesssurgeryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the illnesssurgery
     */
    select?: illnesssurgerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: illnesssurgeryInclude<ExtArgs> | null
  }


  /**
   * Model illnesstype
   */

  export type AggregateIllnesstype = {
    _count: IllnesstypeCountAggregateOutputType | null
    _avg: IllnesstypeAvgAggregateOutputType | null
    _sum: IllnesstypeSumAggregateOutputType | null
    _min: IllnesstypeMinAggregateOutputType | null
    _max: IllnesstypeMaxAggregateOutputType | null
  }

  export type IllnesstypeAvgAggregateOutputType = {
    id: number | null
    insurerid: number | null
  }

  export type IllnesstypeSumAggregateOutputType = {
    id: number | null
    insurerid: number | null
  }

  export type IllnesstypeMinAggregateOutputType = {
    id: number | null
    illnesstypecode: string | null
    illnesstypedesc: string | null
    insurerid: number | null
  }

  export type IllnesstypeMaxAggregateOutputType = {
    id: number | null
    illnesstypecode: string | null
    illnesstypedesc: string | null
    insurerid: number | null
  }

  export type IllnesstypeCountAggregateOutputType = {
    id: number
    illnesstypecode: number
    illnesstypedesc: number
    insurerid: number
    _all: number
  }


  export type IllnesstypeAvgAggregateInputType = {
    id?: true
    insurerid?: true
  }

  export type IllnesstypeSumAggregateInputType = {
    id?: true
    insurerid?: true
  }

  export type IllnesstypeMinAggregateInputType = {
    id?: true
    illnesstypecode?: true
    illnesstypedesc?: true
    insurerid?: true
  }

  export type IllnesstypeMaxAggregateInputType = {
    id?: true
    illnesstypecode?: true
    illnesstypedesc?: true
    insurerid?: true
  }

  export type IllnesstypeCountAggregateInputType = {
    id?: true
    illnesstypecode?: true
    illnesstypedesc?: true
    insurerid?: true
    _all?: true
  }

  export type IllnesstypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which illnesstype to aggregate.
     */
    where?: illnesstypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of illnesstypes to fetch.
     */
    orderBy?: illnesstypeOrderByWithRelationInput | illnesstypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: illnesstypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` illnesstypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` illnesstypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned illnesstypes
    **/
    _count?: true | IllnesstypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IllnesstypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IllnesstypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IllnesstypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IllnesstypeMaxAggregateInputType
  }

  export type GetIllnesstypeAggregateType<T extends IllnesstypeAggregateArgs> = {
        [P in keyof T & keyof AggregateIllnesstype]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIllnesstype[P]>
      : GetScalarType<T[P], AggregateIllnesstype[P]>
  }




  export type illnesstypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: illnesstypeWhereInput
    orderBy?: illnesstypeOrderByWithAggregationInput | illnesstypeOrderByWithAggregationInput[]
    by: IllnesstypeScalarFieldEnum[] | IllnesstypeScalarFieldEnum
    having?: illnesstypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IllnesstypeCountAggregateInputType | true
    _avg?: IllnesstypeAvgAggregateInputType
    _sum?: IllnesstypeSumAggregateInputType
    _min?: IllnesstypeMinAggregateInputType
    _max?: IllnesstypeMaxAggregateInputType
  }

  export type IllnesstypeGroupByOutputType = {
    id: number
    illnesstypecode: string
    illnesstypedesc: string | null
    insurerid: number | null
    _count: IllnesstypeCountAggregateOutputType | null
    _avg: IllnesstypeAvgAggregateOutputType | null
    _sum: IllnesstypeSumAggregateOutputType | null
    _min: IllnesstypeMinAggregateOutputType | null
    _max: IllnesstypeMaxAggregateOutputType | null
  }

  type GetIllnesstypeGroupByPayload<T extends illnesstypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IllnesstypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IllnesstypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IllnesstypeGroupByOutputType[P]>
            : GetScalarType<T[P], IllnesstypeGroupByOutputType[P]>
        }
      >
    >


  export type illnesstypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    illnesstypecode?: boolean
    illnesstypedesc?: boolean
    insurerid?: boolean
    insurers?: boolean | illnesstype$insurersArgs<ExtArgs>
  }, ExtArgs["result"]["illnesstype"]>

  export type illnesstypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    illnesstypecode?: boolean
    illnesstypedesc?: boolean
    insurerid?: boolean
    insurers?: boolean | illnesstype$insurersArgs<ExtArgs>
  }, ExtArgs["result"]["illnesstype"]>

  export type illnesstypeSelectScalar = {
    id?: boolean
    illnesstypecode?: boolean
    illnesstypedesc?: boolean
    insurerid?: boolean
  }

  export type illnesstypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurers?: boolean | illnesstype$insurersArgs<ExtArgs>
  }
  export type illnesstypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurers?: boolean | illnesstype$insurersArgs<ExtArgs>
  }

  export type $illnesstypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "illnesstype"
    objects: {
      insurers: Prisma.$insurersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      illnesstypecode: string
      illnesstypedesc: string | null
      insurerid: number | null
    }, ExtArgs["result"]["illnesstype"]>
    composites: {}
  }

  type illnesstypeGetPayload<S extends boolean | null | undefined | illnesstypeDefaultArgs> = $Result.GetResult<Prisma.$illnesstypePayload, S>

  type illnesstypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<illnesstypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IllnesstypeCountAggregateInputType | true
    }

  export interface illnesstypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['illnesstype'], meta: { name: 'illnesstype' } }
    /**
     * Find zero or one Illnesstype that matches the filter.
     * @param {illnesstypeFindUniqueArgs} args - Arguments to find a Illnesstype
     * @example
     * // Get one Illnesstype
     * const illnesstype = await prisma.illnesstype.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends illnesstypeFindUniqueArgs>(args: SelectSubset<T, illnesstypeFindUniqueArgs<ExtArgs>>): Prisma__illnesstypeClient<$Result.GetResult<Prisma.$illnesstypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Illnesstype that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {illnesstypeFindUniqueOrThrowArgs} args - Arguments to find a Illnesstype
     * @example
     * // Get one Illnesstype
     * const illnesstype = await prisma.illnesstype.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends illnesstypeFindUniqueOrThrowArgs>(args: SelectSubset<T, illnesstypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__illnesstypeClient<$Result.GetResult<Prisma.$illnesstypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Illnesstype that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {illnesstypeFindFirstArgs} args - Arguments to find a Illnesstype
     * @example
     * // Get one Illnesstype
     * const illnesstype = await prisma.illnesstype.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends illnesstypeFindFirstArgs>(args?: SelectSubset<T, illnesstypeFindFirstArgs<ExtArgs>>): Prisma__illnesstypeClient<$Result.GetResult<Prisma.$illnesstypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Illnesstype that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {illnesstypeFindFirstOrThrowArgs} args - Arguments to find a Illnesstype
     * @example
     * // Get one Illnesstype
     * const illnesstype = await prisma.illnesstype.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends illnesstypeFindFirstOrThrowArgs>(args?: SelectSubset<T, illnesstypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__illnesstypeClient<$Result.GetResult<Prisma.$illnesstypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Illnesstypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {illnesstypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Illnesstypes
     * const illnesstypes = await prisma.illnesstype.findMany()
     * 
     * // Get first 10 Illnesstypes
     * const illnesstypes = await prisma.illnesstype.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const illnesstypeWithIdOnly = await prisma.illnesstype.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends illnesstypeFindManyArgs>(args?: SelectSubset<T, illnesstypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$illnesstypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Illnesstype.
     * @param {illnesstypeCreateArgs} args - Arguments to create a Illnesstype.
     * @example
     * // Create one Illnesstype
     * const Illnesstype = await prisma.illnesstype.create({
     *   data: {
     *     // ... data to create a Illnesstype
     *   }
     * })
     * 
     */
    create<T extends illnesstypeCreateArgs>(args: SelectSubset<T, illnesstypeCreateArgs<ExtArgs>>): Prisma__illnesstypeClient<$Result.GetResult<Prisma.$illnesstypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Illnesstypes.
     * @param {illnesstypeCreateManyArgs} args - Arguments to create many Illnesstypes.
     * @example
     * // Create many Illnesstypes
     * const illnesstype = await prisma.illnesstype.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends illnesstypeCreateManyArgs>(args?: SelectSubset<T, illnesstypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Illnesstypes and returns the data saved in the database.
     * @param {illnesstypeCreateManyAndReturnArgs} args - Arguments to create many Illnesstypes.
     * @example
     * // Create many Illnesstypes
     * const illnesstype = await prisma.illnesstype.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Illnesstypes and only return the `id`
     * const illnesstypeWithIdOnly = await prisma.illnesstype.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends illnesstypeCreateManyAndReturnArgs>(args?: SelectSubset<T, illnesstypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$illnesstypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Illnesstype.
     * @param {illnesstypeDeleteArgs} args - Arguments to delete one Illnesstype.
     * @example
     * // Delete one Illnesstype
     * const Illnesstype = await prisma.illnesstype.delete({
     *   where: {
     *     // ... filter to delete one Illnesstype
     *   }
     * })
     * 
     */
    delete<T extends illnesstypeDeleteArgs>(args: SelectSubset<T, illnesstypeDeleteArgs<ExtArgs>>): Prisma__illnesstypeClient<$Result.GetResult<Prisma.$illnesstypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Illnesstype.
     * @param {illnesstypeUpdateArgs} args - Arguments to update one Illnesstype.
     * @example
     * // Update one Illnesstype
     * const illnesstype = await prisma.illnesstype.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends illnesstypeUpdateArgs>(args: SelectSubset<T, illnesstypeUpdateArgs<ExtArgs>>): Prisma__illnesstypeClient<$Result.GetResult<Prisma.$illnesstypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Illnesstypes.
     * @param {illnesstypeDeleteManyArgs} args - Arguments to filter Illnesstypes to delete.
     * @example
     * // Delete a few Illnesstypes
     * const { count } = await prisma.illnesstype.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends illnesstypeDeleteManyArgs>(args?: SelectSubset<T, illnesstypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Illnesstypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {illnesstypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Illnesstypes
     * const illnesstype = await prisma.illnesstype.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends illnesstypeUpdateManyArgs>(args: SelectSubset<T, illnesstypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Illnesstype.
     * @param {illnesstypeUpsertArgs} args - Arguments to update or create a Illnesstype.
     * @example
     * // Update or create a Illnesstype
     * const illnesstype = await prisma.illnesstype.upsert({
     *   create: {
     *     // ... data to create a Illnesstype
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Illnesstype we want to update
     *   }
     * })
     */
    upsert<T extends illnesstypeUpsertArgs>(args: SelectSubset<T, illnesstypeUpsertArgs<ExtArgs>>): Prisma__illnesstypeClient<$Result.GetResult<Prisma.$illnesstypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Illnesstypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {illnesstypeCountArgs} args - Arguments to filter Illnesstypes to count.
     * @example
     * // Count the number of Illnesstypes
     * const count = await prisma.illnesstype.count({
     *   where: {
     *     // ... the filter for the Illnesstypes we want to count
     *   }
     * })
    **/
    count<T extends illnesstypeCountArgs>(
      args?: Subset<T, illnesstypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IllnesstypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Illnesstype.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IllnesstypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IllnesstypeAggregateArgs>(args: Subset<T, IllnesstypeAggregateArgs>): Prisma.PrismaPromise<GetIllnesstypeAggregateType<T>>

    /**
     * Group by Illnesstype.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {illnesstypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends illnesstypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: illnesstypeGroupByArgs['orderBy'] }
        : { orderBy?: illnesstypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, illnesstypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIllnesstypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the illnesstype model
   */
  readonly fields: illnesstypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for illnesstype.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__illnesstypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    insurers<T extends illnesstype$insurersArgs<ExtArgs> = {}>(args?: Subset<T, illnesstype$insurersArgs<ExtArgs>>): Prisma__insurersClient<$Result.GetResult<Prisma.$insurersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the illnesstype model
   */ 
  interface illnesstypeFieldRefs {
    readonly id: FieldRef<"illnesstype", 'Int'>
    readonly illnesstypecode: FieldRef<"illnesstype", 'String'>
    readonly illnesstypedesc: FieldRef<"illnesstype", 'String'>
    readonly insurerid: FieldRef<"illnesstype", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * illnesstype findUnique
   */
  export type illnesstypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the illnesstype
     */
    select?: illnesstypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: illnesstypeInclude<ExtArgs> | null
    /**
     * Filter, which illnesstype to fetch.
     */
    where: illnesstypeWhereUniqueInput
  }

  /**
   * illnesstype findUniqueOrThrow
   */
  export type illnesstypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the illnesstype
     */
    select?: illnesstypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: illnesstypeInclude<ExtArgs> | null
    /**
     * Filter, which illnesstype to fetch.
     */
    where: illnesstypeWhereUniqueInput
  }

  /**
   * illnesstype findFirst
   */
  export type illnesstypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the illnesstype
     */
    select?: illnesstypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: illnesstypeInclude<ExtArgs> | null
    /**
     * Filter, which illnesstype to fetch.
     */
    where?: illnesstypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of illnesstypes to fetch.
     */
    orderBy?: illnesstypeOrderByWithRelationInput | illnesstypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for illnesstypes.
     */
    cursor?: illnesstypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` illnesstypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` illnesstypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of illnesstypes.
     */
    distinct?: IllnesstypeScalarFieldEnum | IllnesstypeScalarFieldEnum[]
  }

  /**
   * illnesstype findFirstOrThrow
   */
  export type illnesstypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the illnesstype
     */
    select?: illnesstypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: illnesstypeInclude<ExtArgs> | null
    /**
     * Filter, which illnesstype to fetch.
     */
    where?: illnesstypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of illnesstypes to fetch.
     */
    orderBy?: illnesstypeOrderByWithRelationInput | illnesstypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for illnesstypes.
     */
    cursor?: illnesstypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` illnesstypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` illnesstypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of illnesstypes.
     */
    distinct?: IllnesstypeScalarFieldEnum | IllnesstypeScalarFieldEnum[]
  }

  /**
   * illnesstype findMany
   */
  export type illnesstypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the illnesstype
     */
    select?: illnesstypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: illnesstypeInclude<ExtArgs> | null
    /**
     * Filter, which illnesstypes to fetch.
     */
    where?: illnesstypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of illnesstypes to fetch.
     */
    orderBy?: illnesstypeOrderByWithRelationInput | illnesstypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing illnesstypes.
     */
    cursor?: illnesstypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` illnesstypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` illnesstypes.
     */
    skip?: number
    distinct?: IllnesstypeScalarFieldEnum | IllnesstypeScalarFieldEnum[]
  }

  /**
   * illnesstype create
   */
  export type illnesstypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the illnesstype
     */
    select?: illnesstypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: illnesstypeInclude<ExtArgs> | null
    /**
     * The data needed to create a illnesstype.
     */
    data: XOR<illnesstypeCreateInput, illnesstypeUncheckedCreateInput>
  }

  /**
   * illnesstype createMany
   */
  export type illnesstypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many illnesstypes.
     */
    data: illnesstypeCreateManyInput | illnesstypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * illnesstype createManyAndReturn
   */
  export type illnesstypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the illnesstype
     */
    select?: illnesstypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many illnesstypes.
     */
    data: illnesstypeCreateManyInput | illnesstypeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: illnesstypeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * illnesstype update
   */
  export type illnesstypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the illnesstype
     */
    select?: illnesstypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: illnesstypeInclude<ExtArgs> | null
    /**
     * The data needed to update a illnesstype.
     */
    data: XOR<illnesstypeUpdateInput, illnesstypeUncheckedUpdateInput>
    /**
     * Choose, which illnesstype to update.
     */
    where: illnesstypeWhereUniqueInput
  }

  /**
   * illnesstype updateMany
   */
  export type illnesstypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update illnesstypes.
     */
    data: XOR<illnesstypeUpdateManyMutationInput, illnesstypeUncheckedUpdateManyInput>
    /**
     * Filter which illnesstypes to update
     */
    where?: illnesstypeWhereInput
  }

  /**
   * illnesstype upsert
   */
  export type illnesstypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the illnesstype
     */
    select?: illnesstypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: illnesstypeInclude<ExtArgs> | null
    /**
     * The filter to search for the illnesstype to update in case it exists.
     */
    where: illnesstypeWhereUniqueInput
    /**
     * In case the illnesstype found by the `where` argument doesn't exist, create a new illnesstype with this data.
     */
    create: XOR<illnesstypeCreateInput, illnesstypeUncheckedCreateInput>
    /**
     * In case the illnesstype was found with the provided `where` argument, update it with this data.
     */
    update: XOR<illnesstypeUpdateInput, illnesstypeUncheckedUpdateInput>
  }

  /**
   * illnesstype delete
   */
  export type illnesstypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the illnesstype
     */
    select?: illnesstypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: illnesstypeInclude<ExtArgs> | null
    /**
     * Filter which illnesstype to delete.
     */
    where: illnesstypeWhereUniqueInput
  }

  /**
   * illnesstype deleteMany
   */
  export type illnesstypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which illnesstypes to delete
     */
    where?: illnesstypeWhereInput
  }

  /**
   * illnesstype.insurers
   */
  export type illnesstype$insurersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insurers
     */
    select?: insurersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: insurersInclude<ExtArgs> | null
    where?: insurersWhereInput
  }

  /**
   * illnesstype without action
   */
  export type illnesstypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the illnesstype
     */
    select?: illnesstypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: illnesstypeInclude<ExtArgs> | null
  }


  /**
   * Model insurers
   */

  export type AggregateInsurers = {
    _count: InsurersCountAggregateOutputType | null
    _avg: InsurersAvgAggregateOutputType | null
    _sum: InsurersSumAggregateOutputType | null
    _min: InsurersMinAggregateOutputType | null
    _max: InsurersMaxAggregateOutputType | null
  }

  export type InsurersAvgAggregateOutputType = {
    id: number | null
    insurerid: number | null
    insurercode: number | null
  }

  export type InsurersSumAggregateOutputType = {
    id: number | null
    insurerid: number | null
    insurercode: number | null
  }

  export type InsurersMinAggregateOutputType = {
    id: number | null
    insurerid: number | null
    insurercode: number | null
    insurername: string | null
  }

  export type InsurersMaxAggregateOutputType = {
    id: number | null
    insurerid: number | null
    insurercode: number | null
    insurername: string | null
  }

  export type InsurersCountAggregateOutputType = {
    id: number
    insurerid: number
    insurercode: number
    insurername: number
    _all: number
  }


  export type InsurersAvgAggregateInputType = {
    id?: true
    insurerid?: true
    insurercode?: true
  }

  export type InsurersSumAggregateInputType = {
    id?: true
    insurerid?: true
    insurercode?: true
  }

  export type InsurersMinAggregateInputType = {
    id?: true
    insurerid?: true
    insurercode?: true
    insurername?: true
  }

  export type InsurersMaxAggregateInputType = {
    id?: true
    insurerid?: true
    insurercode?: true
    insurername?: true
  }

  export type InsurersCountAggregateInputType = {
    id?: true
    insurerid?: true
    insurercode?: true
    insurername?: true
    _all?: true
  }

  export type InsurersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which insurers to aggregate.
     */
    where?: insurersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of insurers to fetch.
     */
    orderBy?: insurersOrderByWithRelationInput | insurersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: insurersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` insurers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` insurers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned insurers
    **/
    _count?: true | InsurersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InsurersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InsurersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InsurersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InsurersMaxAggregateInputType
  }

  export type GetInsurersAggregateType<T extends InsurersAggregateArgs> = {
        [P in keyof T & keyof AggregateInsurers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInsurers[P]>
      : GetScalarType<T[P], AggregateInsurers[P]>
  }




  export type insurersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: insurersWhereInput
    orderBy?: insurersOrderByWithAggregationInput | insurersOrderByWithAggregationInput[]
    by: InsurersScalarFieldEnum[] | InsurersScalarFieldEnum
    having?: insurersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InsurersCountAggregateInputType | true
    _avg?: InsurersAvgAggregateInputType
    _sum?: InsurersSumAggregateInputType
    _min?: InsurersMinAggregateInputType
    _max?: InsurersMaxAggregateInputType
  }

  export type InsurersGroupByOutputType = {
    id: number
    insurerid: number
    insurercode: number | null
    insurername: string | null
    _count: InsurersCountAggregateOutputType | null
    _avg: InsurersAvgAggregateOutputType | null
    _sum: InsurersSumAggregateOutputType | null
    _min: InsurersMinAggregateOutputType | null
    _max: InsurersMaxAggregateOutputType | null
  }

  type GetInsurersGroupByPayload<T extends insurersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InsurersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InsurersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InsurersGroupByOutputType[P]>
            : GetScalarType<T[P], InsurersGroupByOutputType[P]>
        }
      >
    >


  export type insurersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insurerid?: boolean
    insurercode?: boolean
    insurername?: boolean
    accidentcauseover45days?: boolean | insurers$accidentcauseover45daysArgs<ExtArgs>
    accidentplace?: boolean | insurers$accidentplaceArgs<ExtArgs>
    accidenttransactions?: boolean | insurers$accidenttransactionsArgs<ExtArgs>
    accidenttransactions22?: boolean | insurers$accidenttransactions22Args<ExtArgs>
    causeofinjuryside?: boolean | insurers$causeofinjurysideArgs<ExtArgs>
    causeofinjurywoundtype?: boolean | insurers$causeofinjurywoundtypeArgs<ExtArgs>
    claimants?: boolean | insurers$claimantsArgs<ExtArgs>
    claimdocuments?: boolean | insurers$claimdocumentsArgs<ExtArgs>
    claimstatus?: boolean | insurers$claimstatusArgs<ExtArgs>
    diagnosistypemapping?: boolean | insurers$diagnosistypemappingArgs<ExtArgs>
    documenttype?: boolean | insurers$documenttypeArgs<ExtArgs>
    illnesssurgery?: boolean | insurers$illnesssurgeryArgs<ExtArgs>
    illnesstype?: boolean | insurers$illnesstypeArgs<ExtArgs>
    policytype?: boolean | insurers$policytypeArgs<ExtArgs>
    proceduretransactions?: boolean | insurers$proceduretransactionsArgs<ExtArgs>
    servicesetting?: boolean | insurers$servicesettingArgs<ExtArgs>
    _count?: boolean | InsurersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insurers"]>

  export type insurersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insurerid?: boolean
    insurercode?: boolean
    insurername?: boolean
  }, ExtArgs["result"]["insurers"]>

  export type insurersSelectScalar = {
    id?: boolean
    insurerid?: boolean
    insurercode?: boolean
    insurername?: boolean
  }

  export type insurersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accidentcauseover45days?: boolean | insurers$accidentcauseover45daysArgs<ExtArgs>
    accidentplace?: boolean | insurers$accidentplaceArgs<ExtArgs>
    accidenttransactions?: boolean | insurers$accidenttransactionsArgs<ExtArgs>
    accidenttransactions22?: boolean | insurers$accidenttransactions22Args<ExtArgs>
    causeofinjuryside?: boolean | insurers$causeofinjurysideArgs<ExtArgs>
    causeofinjurywoundtype?: boolean | insurers$causeofinjurywoundtypeArgs<ExtArgs>
    claimants?: boolean | insurers$claimantsArgs<ExtArgs>
    claimdocuments?: boolean | insurers$claimdocumentsArgs<ExtArgs>
    claimstatus?: boolean | insurers$claimstatusArgs<ExtArgs>
    diagnosistypemapping?: boolean | insurers$diagnosistypemappingArgs<ExtArgs>
    documenttype?: boolean | insurers$documenttypeArgs<ExtArgs>
    illnesssurgery?: boolean | insurers$illnesssurgeryArgs<ExtArgs>
    illnesstype?: boolean | insurers$illnesstypeArgs<ExtArgs>
    policytype?: boolean | insurers$policytypeArgs<ExtArgs>
    proceduretransactions?: boolean | insurers$proceduretransactionsArgs<ExtArgs>
    servicesetting?: boolean | insurers$servicesettingArgs<ExtArgs>
    _count?: boolean | InsurersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type insurersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $insurersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "insurers"
    objects: {
      accidentcauseover45days: Prisma.$accidentcauseover45daysPayload<ExtArgs>[]
      accidentplace: Prisma.$accidentplacePayload<ExtArgs>[]
      accidenttransactions: Prisma.$accidenttransactionsPayload<ExtArgs>[]
      accidenttransactions22: Prisma.$accidenttransactions22Payload<ExtArgs>[]
      causeofinjuryside: Prisma.$causeofinjurysidePayload<ExtArgs>[]
      causeofinjurywoundtype: Prisma.$causeofinjurywoundtypePayload<ExtArgs>[]
      claimants: Prisma.$claimantsPayload<ExtArgs>[]
      claimdocuments: Prisma.$claimdocumentsPayload<ExtArgs>[]
      claimstatus: Prisma.$claimstatusPayload<ExtArgs>[]
      diagnosistypemapping: Prisma.$diagnosistypemappingPayload<ExtArgs>[]
      documenttype: Prisma.$documenttypePayload<ExtArgs>[]
      illnesssurgery: Prisma.$illnesssurgeryPayload<ExtArgs>[]
      illnesstype: Prisma.$illnesstypePayload<ExtArgs>[]
      policytype: Prisma.$policytypePayload<ExtArgs>[]
      proceduretransactions: Prisma.$proceduretransactionsPayload<ExtArgs>[]
      servicesetting: Prisma.$servicesettingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      insurerid: number
      insurercode: number | null
      insurername: string | null
    }, ExtArgs["result"]["insurers"]>
    composites: {}
  }

  type insurersGetPayload<S extends boolean | null | undefined | insurersDefaultArgs> = $Result.GetResult<Prisma.$insurersPayload, S>

  type insurersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<insurersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InsurersCountAggregateInputType | true
    }

  export interface insurersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['insurers'], meta: { name: 'insurers' } }
    /**
     * Find zero or one Insurers that matches the filter.
     * @param {insurersFindUniqueArgs} args - Arguments to find a Insurers
     * @example
     * // Get one Insurers
     * const insurers = await prisma.insurers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends insurersFindUniqueArgs>(args: SelectSubset<T, insurersFindUniqueArgs<ExtArgs>>): Prisma__insurersClient<$Result.GetResult<Prisma.$insurersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Insurers that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {insurersFindUniqueOrThrowArgs} args - Arguments to find a Insurers
     * @example
     * // Get one Insurers
     * const insurers = await prisma.insurers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends insurersFindUniqueOrThrowArgs>(args: SelectSubset<T, insurersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__insurersClient<$Result.GetResult<Prisma.$insurersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Insurers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {insurersFindFirstArgs} args - Arguments to find a Insurers
     * @example
     * // Get one Insurers
     * const insurers = await prisma.insurers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends insurersFindFirstArgs>(args?: SelectSubset<T, insurersFindFirstArgs<ExtArgs>>): Prisma__insurersClient<$Result.GetResult<Prisma.$insurersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Insurers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {insurersFindFirstOrThrowArgs} args - Arguments to find a Insurers
     * @example
     * // Get one Insurers
     * const insurers = await prisma.insurers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends insurersFindFirstOrThrowArgs>(args?: SelectSubset<T, insurersFindFirstOrThrowArgs<ExtArgs>>): Prisma__insurersClient<$Result.GetResult<Prisma.$insurersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Insurers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {insurersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Insurers
     * const insurers = await prisma.insurers.findMany()
     * 
     * // Get first 10 Insurers
     * const insurers = await prisma.insurers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const insurersWithIdOnly = await prisma.insurers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends insurersFindManyArgs>(args?: SelectSubset<T, insurersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$insurersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Insurers.
     * @param {insurersCreateArgs} args - Arguments to create a Insurers.
     * @example
     * // Create one Insurers
     * const Insurers = await prisma.insurers.create({
     *   data: {
     *     // ... data to create a Insurers
     *   }
     * })
     * 
     */
    create<T extends insurersCreateArgs>(args: SelectSubset<T, insurersCreateArgs<ExtArgs>>): Prisma__insurersClient<$Result.GetResult<Prisma.$insurersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Insurers.
     * @param {insurersCreateManyArgs} args - Arguments to create many Insurers.
     * @example
     * // Create many Insurers
     * const insurers = await prisma.insurers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends insurersCreateManyArgs>(args?: SelectSubset<T, insurersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Insurers and returns the data saved in the database.
     * @param {insurersCreateManyAndReturnArgs} args - Arguments to create many Insurers.
     * @example
     * // Create many Insurers
     * const insurers = await prisma.insurers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Insurers and only return the `id`
     * const insurersWithIdOnly = await prisma.insurers.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends insurersCreateManyAndReturnArgs>(args?: SelectSubset<T, insurersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$insurersPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Insurers.
     * @param {insurersDeleteArgs} args - Arguments to delete one Insurers.
     * @example
     * // Delete one Insurers
     * const Insurers = await prisma.insurers.delete({
     *   where: {
     *     // ... filter to delete one Insurers
     *   }
     * })
     * 
     */
    delete<T extends insurersDeleteArgs>(args: SelectSubset<T, insurersDeleteArgs<ExtArgs>>): Prisma__insurersClient<$Result.GetResult<Prisma.$insurersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Insurers.
     * @param {insurersUpdateArgs} args - Arguments to update one Insurers.
     * @example
     * // Update one Insurers
     * const insurers = await prisma.insurers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends insurersUpdateArgs>(args: SelectSubset<T, insurersUpdateArgs<ExtArgs>>): Prisma__insurersClient<$Result.GetResult<Prisma.$insurersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Insurers.
     * @param {insurersDeleteManyArgs} args - Arguments to filter Insurers to delete.
     * @example
     * // Delete a few Insurers
     * const { count } = await prisma.insurers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends insurersDeleteManyArgs>(args?: SelectSubset<T, insurersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Insurers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {insurersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Insurers
     * const insurers = await prisma.insurers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends insurersUpdateManyArgs>(args: SelectSubset<T, insurersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Insurers.
     * @param {insurersUpsertArgs} args - Arguments to update or create a Insurers.
     * @example
     * // Update or create a Insurers
     * const insurers = await prisma.insurers.upsert({
     *   create: {
     *     // ... data to create a Insurers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Insurers we want to update
     *   }
     * })
     */
    upsert<T extends insurersUpsertArgs>(args: SelectSubset<T, insurersUpsertArgs<ExtArgs>>): Prisma__insurersClient<$Result.GetResult<Prisma.$insurersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Insurers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {insurersCountArgs} args - Arguments to filter Insurers to count.
     * @example
     * // Count the number of Insurers
     * const count = await prisma.insurers.count({
     *   where: {
     *     // ... the filter for the Insurers we want to count
     *   }
     * })
    **/
    count<T extends insurersCountArgs>(
      args?: Subset<T, insurersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InsurersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Insurers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsurersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InsurersAggregateArgs>(args: Subset<T, InsurersAggregateArgs>): Prisma.PrismaPromise<GetInsurersAggregateType<T>>

    /**
     * Group by Insurers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {insurersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends insurersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: insurersGroupByArgs['orderBy'] }
        : { orderBy?: insurersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, insurersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInsurersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the insurers model
   */
  readonly fields: insurersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for insurers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__insurersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accidentcauseover45days<T extends insurers$accidentcauseover45daysArgs<ExtArgs> = {}>(args?: Subset<T, insurers$accidentcauseover45daysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accidentcauseover45daysPayload<ExtArgs>, T, "findMany"> | Null>
    accidentplace<T extends insurers$accidentplaceArgs<ExtArgs> = {}>(args?: Subset<T, insurers$accidentplaceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accidentplacePayload<ExtArgs>, T, "findMany"> | Null>
    accidenttransactions<T extends insurers$accidenttransactionsArgs<ExtArgs> = {}>(args?: Subset<T, insurers$accidenttransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accidenttransactionsPayload<ExtArgs>, T, "findMany"> | Null>
    accidenttransactions22<T extends insurers$accidenttransactions22Args<ExtArgs> = {}>(args?: Subset<T, insurers$accidenttransactions22Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accidenttransactions22Payload<ExtArgs>, T, "findMany"> | Null>
    causeofinjuryside<T extends insurers$causeofinjurysideArgs<ExtArgs> = {}>(args?: Subset<T, insurers$causeofinjurysideArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$causeofinjurysidePayload<ExtArgs>, T, "findMany"> | Null>
    causeofinjurywoundtype<T extends insurers$causeofinjurywoundtypeArgs<ExtArgs> = {}>(args?: Subset<T, insurers$causeofinjurywoundtypeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$causeofinjurywoundtypePayload<ExtArgs>, T, "findMany"> | Null>
    claimants<T extends insurers$claimantsArgs<ExtArgs> = {}>(args?: Subset<T, insurers$claimantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$claimantsPayload<ExtArgs>, T, "findMany"> | Null>
    claimdocuments<T extends insurers$claimdocumentsArgs<ExtArgs> = {}>(args?: Subset<T, insurers$claimdocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$claimdocumentsPayload<ExtArgs>, T, "findMany"> | Null>
    claimstatus<T extends insurers$claimstatusArgs<ExtArgs> = {}>(args?: Subset<T, insurers$claimstatusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$claimstatusPayload<ExtArgs>, T, "findMany"> | Null>
    diagnosistypemapping<T extends insurers$diagnosistypemappingArgs<ExtArgs> = {}>(args?: Subset<T, insurers$diagnosistypemappingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$diagnosistypemappingPayload<ExtArgs>, T, "findMany"> | Null>
    documenttype<T extends insurers$documenttypeArgs<ExtArgs> = {}>(args?: Subset<T, insurers$documenttypeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$documenttypePayload<ExtArgs>, T, "findMany"> | Null>
    illnesssurgery<T extends insurers$illnesssurgeryArgs<ExtArgs> = {}>(args?: Subset<T, insurers$illnesssurgeryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$illnesssurgeryPayload<ExtArgs>, T, "findMany"> | Null>
    illnesstype<T extends insurers$illnesstypeArgs<ExtArgs> = {}>(args?: Subset<T, insurers$illnesstypeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$illnesstypePayload<ExtArgs>, T, "findMany"> | Null>
    policytype<T extends insurers$policytypeArgs<ExtArgs> = {}>(args?: Subset<T, insurers$policytypeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$policytypePayload<ExtArgs>, T, "findMany"> | Null>
    proceduretransactions<T extends insurers$proceduretransactionsArgs<ExtArgs> = {}>(args?: Subset<T, insurers$proceduretransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$proceduretransactionsPayload<ExtArgs>, T, "findMany"> | Null>
    servicesetting<T extends insurers$servicesettingArgs<ExtArgs> = {}>(args?: Subset<T, insurers$servicesettingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$servicesettingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the insurers model
   */ 
  interface insurersFieldRefs {
    readonly id: FieldRef<"insurers", 'Int'>
    readonly insurerid: FieldRef<"insurers", 'Int'>
    readonly insurercode: FieldRef<"insurers", 'Int'>
    readonly insurername: FieldRef<"insurers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * insurers findUnique
   */
  export type insurersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insurers
     */
    select?: insurersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: insurersInclude<ExtArgs> | null
    /**
     * Filter, which insurers to fetch.
     */
    where: insurersWhereUniqueInput
  }

  /**
   * insurers findUniqueOrThrow
   */
  export type insurersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insurers
     */
    select?: insurersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: insurersInclude<ExtArgs> | null
    /**
     * Filter, which insurers to fetch.
     */
    where: insurersWhereUniqueInput
  }

  /**
   * insurers findFirst
   */
  export type insurersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insurers
     */
    select?: insurersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: insurersInclude<ExtArgs> | null
    /**
     * Filter, which insurers to fetch.
     */
    where?: insurersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of insurers to fetch.
     */
    orderBy?: insurersOrderByWithRelationInput | insurersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for insurers.
     */
    cursor?: insurersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` insurers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` insurers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of insurers.
     */
    distinct?: InsurersScalarFieldEnum | InsurersScalarFieldEnum[]
  }

  /**
   * insurers findFirstOrThrow
   */
  export type insurersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insurers
     */
    select?: insurersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: insurersInclude<ExtArgs> | null
    /**
     * Filter, which insurers to fetch.
     */
    where?: insurersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of insurers to fetch.
     */
    orderBy?: insurersOrderByWithRelationInput | insurersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for insurers.
     */
    cursor?: insurersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` insurers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` insurers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of insurers.
     */
    distinct?: InsurersScalarFieldEnum | InsurersScalarFieldEnum[]
  }

  /**
   * insurers findMany
   */
  export type insurersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insurers
     */
    select?: insurersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: insurersInclude<ExtArgs> | null
    /**
     * Filter, which insurers to fetch.
     */
    where?: insurersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of insurers to fetch.
     */
    orderBy?: insurersOrderByWithRelationInput | insurersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing insurers.
     */
    cursor?: insurersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` insurers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` insurers.
     */
    skip?: number
    distinct?: InsurersScalarFieldEnum | InsurersScalarFieldEnum[]
  }

  /**
   * insurers create
   */
  export type insurersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insurers
     */
    select?: insurersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: insurersInclude<ExtArgs> | null
    /**
     * The data needed to create a insurers.
     */
    data: XOR<insurersCreateInput, insurersUncheckedCreateInput>
  }

  /**
   * insurers createMany
   */
  export type insurersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many insurers.
     */
    data: insurersCreateManyInput | insurersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * insurers createManyAndReturn
   */
  export type insurersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insurers
     */
    select?: insurersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many insurers.
     */
    data: insurersCreateManyInput | insurersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * insurers update
   */
  export type insurersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insurers
     */
    select?: insurersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: insurersInclude<ExtArgs> | null
    /**
     * The data needed to update a insurers.
     */
    data: XOR<insurersUpdateInput, insurersUncheckedUpdateInput>
    /**
     * Choose, which insurers to update.
     */
    where: insurersWhereUniqueInput
  }

  /**
   * insurers updateMany
   */
  export type insurersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update insurers.
     */
    data: XOR<insurersUpdateManyMutationInput, insurersUncheckedUpdateManyInput>
    /**
     * Filter which insurers to update
     */
    where?: insurersWhereInput
  }

  /**
   * insurers upsert
   */
  export type insurersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insurers
     */
    select?: insurersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: insurersInclude<ExtArgs> | null
    /**
     * The filter to search for the insurers to update in case it exists.
     */
    where: insurersWhereUniqueInput
    /**
     * In case the insurers found by the `where` argument doesn't exist, create a new insurers with this data.
     */
    create: XOR<insurersCreateInput, insurersUncheckedCreateInput>
    /**
     * In case the insurers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<insurersUpdateInput, insurersUncheckedUpdateInput>
  }

  /**
   * insurers delete
   */
  export type insurersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insurers
     */
    select?: insurersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: insurersInclude<ExtArgs> | null
    /**
     * Filter which insurers to delete.
     */
    where: insurersWhereUniqueInput
  }

  /**
   * insurers deleteMany
   */
  export type insurersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which insurers to delete
     */
    where?: insurersWhereInput
  }

  /**
   * insurers.accidentcauseover45days
   */
  export type insurers$accidentcauseover45daysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidentcauseover45days
     */
    select?: accidentcauseover45daysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidentcauseover45daysInclude<ExtArgs> | null
    where?: accidentcauseover45daysWhereInput
    orderBy?: accidentcauseover45daysOrderByWithRelationInput | accidentcauseover45daysOrderByWithRelationInput[]
    cursor?: accidentcauseover45daysWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Accidentcauseover45daysScalarFieldEnum | Accidentcauseover45daysScalarFieldEnum[]
  }

  /**
   * insurers.accidentplace
   */
  export type insurers$accidentplaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidentplace
     */
    select?: accidentplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidentplaceInclude<ExtArgs> | null
    where?: accidentplaceWhereInput
    orderBy?: accidentplaceOrderByWithRelationInput | accidentplaceOrderByWithRelationInput[]
    cursor?: accidentplaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccidentplaceScalarFieldEnum | AccidentplaceScalarFieldEnum[]
  }

  /**
   * insurers.accidenttransactions
   */
  export type insurers$accidenttransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidenttransactions
     */
    select?: accidenttransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidenttransactionsInclude<ExtArgs> | null
    where?: accidenttransactionsWhereInput
    orderBy?: accidenttransactionsOrderByWithRelationInput | accidenttransactionsOrderByWithRelationInput[]
    cursor?: accidenttransactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccidenttransactionsScalarFieldEnum | AccidenttransactionsScalarFieldEnum[]
  }

  /**
   * insurers.accidenttransactions22
   */
  export type insurers$accidenttransactions22Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidenttransactions22
     */
    select?: accidenttransactions22Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidenttransactions22Include<ExtArgs> | null
    where?: accidenttransactions22WhereInput
    orderBy?: accidenttransactions22OrderByWithRelationInput | accidenttransactions22OrderByWithRelationInput[]
    cursor?: accidenttransactions22WhereUniqueInput
    take?: number
    skip?: number
    distinct?: Accidenttransactions22ScalarFieldEnum | Accidenttransactions22ScalarFieldEnum[]
  }

  /**
   * insurers.causeofinjuryside
   */
  export type insurers$causeofinjurysideArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjuryside
     */
    select?: causeofinjurysideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurysideInclude<ExtArgs> | null
    where?: causeofinjurysideWhereInput
    orderBy?: causeofinjurysideOrderByWithRelationInput | causeofinjurysideOrderByWithRelationInput[]
    cursor?: causeofinjurysideWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CauseofinjurysideScalarFieldEnum | CauseofinjurysideScalarFieldEnum[]
  }

  /**
   * insurers.causeofinjurywoundtype
   */
  export type insurers$causeofinjurywoundtypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjurywoundtype
     */
    select?: causeofinjurywoundtypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurywoundtypeInclude<ExtArgs> | null
    where?: causeofinjurywoundtypeWhereInput
    orderBy?: causeofinjurywoundtypeOrderByWithRelationInput | causeofinjurywoundtypeOrderByWithRelationInput[]
    cursor?: causeofinjurywoundtypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CauseofinjurywoundtypeScalarFieldEnum | CauseofinjurywoundtypeScalarFieldEnum[]
  }

  /**
   * insurers.claimants
   */
  export type insurers$claimantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimants
     */
    select?: claimantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimantsInclude<ExtArgs> | null
    where?: claimantsWhereInput
    orderBy?: claimantsOrderByWithRelationInput | claimantsOrderByWithRelationInput[]
    cursor?: claimantsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaimantsScalarFieldEnum | ClaimantsScalarFieldEnum[]
  }

  /**
   * insurers.claimdocuments
   */
  export type insurers$claimdocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimdocuments
     */
    select?: claimdocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimdocumentsInclude<ExtArgs> | null
    where?: claimdocumentsWhereInput
    orderBy?: claimdocumentsOrderByWithRelationInput | claimdocumentsOrderByWithRelationInput[]
    cursor?: claimdocumentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaimdocumentsScalarFieldEnum | ClaimdocumentsScalarFieldEnum[]
  }

  /**
   * insurers.claimstatus
   */
  export type insurers$claimstatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimstatus
     */
    select?: claimstatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimstatusInclude<ExtArgs> | null
    where?: claimstatusWhereInput
    orderBy?: claimstatusOrderByWithRelationInput | claimstatusOrderByWithRelationInput[]
    cursor?: claimstatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaimstatusScalarFieldEnum | ClaimstatusScalarFieldEnum[]
  }

  /**
   * insurers.diagnosistypemapping
   */
  export type insurers$diagnosistypemappingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnosistypemapping
     */
    select?: diagnosistypemappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosistypemappingInclude<ExtArgs> | null
    where?: diagnosistypemappingWhereInput
    orderBy?: diagnosistypemappingOrderByWithRelationInput | diagnosistypemappingOrderByWithRelationInput[]
    cursor?: diagnosistypemappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiagnosistypemappingScalarFieldEnum | DiagnosistypemappingScalarFieldEnum[]
  }

  /**
   * insurers.documenttype
   */
  export type insurers$documenttypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documenttype
     */
    select?: documenttypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documenttypeInclude<ExtArgs> | null
    where?: documenttypeWhereInput
    orderBy?: documenttypeOrderByWithRelationInput | documenttypeOrderByWithRelationInput[]
    cursor?: documenttypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumenttypeScalarFieldEnum | DocumenttypeScalarFieldEnum[]
  }

  /**
   * insurers.illnesssurgery
   */
  export type insurers$illnesssurgeryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the illnesssurgery
     */
    select?: illnesssurgerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: illnesssurgeryInclude<ExtArgs> | null
    where?: illnesssurgeryWhereInput
    orderBy?: illnesssurgeryOrderByWithRelationInput | illnesssurgeryOrderByWithRelationInput[]
    cursor?: illnesssurgeryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IllnesssurgeryScalarFieldEnum | IllnesssurgeryScalarFieldEnum[]
  }

  /**
   * insurers.illnesstype
   */
  export type insurers$illnesstypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the illnesstype
     */
    select?: illnesstypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: illnesstypeInclude<ExtArgs> | null
    where?: illnesstypeWhereInput
    orderBy?: illnesstypeOrderByWithRelationInput | illnesstypeOrderByWithRelationInput[]
    cursor?: illnesstypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IllnesstypeScalarFieldEnum | IllnesstypeScalarFieldEnum[]
  }

  /**
   * insurers.policytype
   */
  export type insurers$policytypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the policytype
     */
    select?: policytypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: policytypeInclude<ExtArgs> | null
    where?: policytypeWhereInput
    orderBy?: policytypeOrderByWithRelationInput | policytypeOrderByWithRelationInput[]
    cursor?: policytypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PolicytypeScalarFieldEnum | PolicytypeScalarFieldEnum[]
  }

  /**
   * insurers.proceduretransactions
   */
  export type insurers$proceduretransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proceduretransactions
     */
    select?: proceduretransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proceduretransactionsInclude<ExtArgs> | null
    where?: proceduretransactionsWhereInput
    orderBy?: proceduretransactionsOrderByWithRelationInput | proceduretransactionsOrderByWithRelationInput[]
    cursor?: proceduretransactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProceduretransactionsScalarFieldEnum | ProceduretransactionsScalarFieldEnum[]
  }

  /**
   * insurers.servicesetting
   */
  export type insurers$servicesettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicesetting
     */
    select?: servicesettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesettingInclude<ExtArgs> | null
    where?: servicesettingWhereInput
    orderBy?: servicesettingOrderByWithRelationInput | servicesettingOrderByWithRelationInput[]
    cursor?: servicesettingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicesettingScalarFieldEnum | ServicesettingScalarFieldEnum[]
  }

  /**
   * insurers without action
   */
  export type insurersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insurers
     */
    select?: insurersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: insurersInclude<ExtArgs> | null
  }


  /**
   * Model medicaltransactions
   */

  export type AggregateMedicaltransactions = {
    _count: MedicaltransactionsCountAggregateOutputType | null
    _avg: MedicaltransactionsAvgAggregateOutputType | null
    _sum: MedicaltransactionsSumAggregateOutputType | null
    _min: MedicaltransactionsMinAggregateOutputType | null
    _max: MedicaltransactionsMaxAggregateOutputType | null
  }

  export type MedicaltransactionsAvgAggregateOutputType = {
    id: number | null
    insurerid: number | null
  }

  export type MedicaltransactionsSumAggregateOutputType = {
    id: number | null
    insurerid: number | null
  }

  export type MedicaltransactionsMinAggregateOutputType = {
    id: number | null
    insurerid: number | null
    refid: string | null
    transactionno: string | null
    hn: string | null
    vn: string | null
    dxfreetext: string | null
    presentillness: string | null
    chiefcomplaint: string | null
    accidentcauseover45days: string | null
    underlyingcondition: string | null
    physicalexam: string | null
    planoftreatment: string | null
    procedurefreetext: string | null
    additionalnote: string | null
    signsymptomsdate: string | null
    comascore: string | null
    expecteddayofrecovery: string | null
    pregnant: boolean | null
    alcoholrelated: boolean | null
    haveaccidentinjurydetail: boolean | null
    haveaccidentcauseofinjurydetail: boolean | null
    haveprocedure: boolean | null
    privatecase: boolean | null
  }

  export type MedicaltransactionsMaxAggregateOutputType = {
    id: number | null
    insurerid: number | null
    refid: string | null
    transactionno: string | null
    hn: string | null
    vn: string | null
    dxfreetext: string | null
    presentillness: string | null
    chiefcomplaint: string | null
    accidentcauseover45days: string | null
    underlyingcondition: string | null
    physicalexam: string | null
    planoftreatment: string | null
    procedurefreetext: string | null
    additionalnote: string | null
    signsymptomsdate: string | null
    comascore: string | null
    expecteddayofrecovery: string | null
    pregnant: boolean | null
    alcoholrelated: boolean | null
    haveaccidentinjurydetail: boolean | null
    haveaccidentcauseofinjurydetail: boolean | null
    haveprocedure: boolean | null
    privatecase: boolean | null
  }

  export type MedicaltransactionsCountAggregateOutputType = {
    id: number
    insurerid: number
    refid: number
    transactionno: number
    hn: number
    vn: number
    dxfreetext: number
    presentillness: number
    chiefcomplaint: number
    accidentcauseover45days: number
    underlyingcondition: number
    physicalexam: number
    planoftreatment: number
    procedurefreetext: number
    additionalnote: number
    signsymptomsdate: number
    comascore: number
    expecteddayofrecovery: number
    pregnant: number
    alcoholrelated: number
    haveaccidentinjurydetail: number
    haveaccidentcauseofinjurydetail: number
    haveprocedure: number
    privatecase: number
    _all: number
  }


  export type MedicaltransactionsAvgAggregateInputType = {
    id?: true
    insurerid?: true
  }

  export type MedicaltransactionsSumAggregateInputType = {
    id?: true
    insurerid?: true
  }

  export type MedicaltransactionsMinAggregateInputType = {
    id?: true
    insurerid?: true
    refid?: true
    transactionno?: true
    hn?: true
    vn?: true
    dxfreetext?: true
    presentillness?: true
    chiefcomplaint?: true
    accidentcauseover45days?: true
    underlyingcondition?: true
    physicalexam?: true
    planoftreatment?: true
    procedurefreetext?: true
    additionalnote?: true
    signsymptomsdate?: true
    comascore?: true
    expecteddayofrecovery?: true
    pregnant?: true
    alcoholrelated?: true
    haveaccidentinjurydetail?: true
    haveaccidentcauseofinjurydetail?: true
    haveprocedure?: true
    privatecase?: true
  }

  export type MedicaltransactionsMaxAggregateInputType = {
    id?: true
    insurerid?: true
    refid?: true
    transactionno?: true
    hn?: true
    vn?: true
    dxfreetext?: true
    presentillness?: true
    chiefcomplaint?: true
    accidentcauseover45days?: true
    underlyingcondition?: true
    physicalexam?: true
    planoftreatment?: true
    procedurefreetext?: true
    additionalnote?: true
    signsymptomsdate?: true
    comascore?: true
    expecteddayofrecovery?: true
    pregnant?: true
    alcoholrelated?: true
    haveaccidentinjurydetail?: true
    haveaccidentcauseofinjurydetail?: true
    haveprocedure?: true
    privatecase?: true
  }

  export type MedicaltransactionsCountAggregateInputType = {
    id?: true
    insurerid?: true
    refid?: true
    transactionno?: true
    hn?: true
    vn?: true
    dxfreetext?: true
    presentillness?: true
    chiefcomplaint?: true
    accidentcauseover45days?: true
    underlyingcondition?: true
    physicalexam?: true
    planoftreatment?: true
    procedurefreetext?: true
    additionalnote?: true
    signsymptomsdate?: true
    comascore?: true
    expecteddayofrecovery?: true
    pregnant?: true
    alcoholrelated?: true
    haveaccidentinjurydetail?: true
    haveaccidentcauseofinjurydetail?: true
    haveprocedure?: true
    privatecase?: true
    _all?: true
  }

  export type MedicaltransactionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which medicaltransactions to aggregate.
     */
    where?: medicaltransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medicaltransactions to fetch.
     */
    orderBy?: medicaltransactionsOrderByWithRelationInput | medicaltransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: medicaltransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medicaltransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medicaltransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned medicaltransactions
    **/
    _count?: true | MedicaltransactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicaltransactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicaltransactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicaltransactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicaltransactionsMaxAggregateInputType
  }

  export type GetMedicaltransactionsAggregateType<T extends MedicaltransactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicaltransactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicaltransactions[P]>
      : GetScalarType<T[P], AggregateMedicaltransactions[P]>
  }




  export type medicaltransactionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: medicaltransactionsWhereInput
    orderBy?: medicaltransactionsOrderByWithAggregationInput | medicaltransactionsOrderByWithAggregationInput[]
    by: MedicaltransactionsScalarFieldEnum[] | MedicaltransactionsScalarFieldEnum
    having?: medicaltransactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicaltransactionsCountAggregateInputType | true
    _avg?: MedicaltransactionsAvgAggregateInputType
    _sum?: MedicaltransactionsSumAggregateInputType
    _min?: MedicaltransactionsMinAggregateInputType
    _max?: MedicaltransactionsMaxAggregateInputType
  }

  export type MedicaltransactionsGroupByOutputType = {
    id: number
    insurerid: number | null
    refid: string | null
    transactionno: string | null
    hn: string | null
    vn: string | null
    dxfreetext: string | null
    presentillness: string | null
    chiefcomplaint: string | null
    accidentcauseover45days: string | null
    underlyingcondition: string | null
    physicalexam: string | null
    planoftreatment: string | null
    procedurefreetext: string | null
    additionalnote: string | null
    signsymptomsdate: string | null
    comascore: string | null
    expecteddayofrecovery: string | null
    pregnant: boolean | null
    alcoholrelated: boolean | null
    haveaccidentinjurydetail: boolean | null
    haveaccidentcauseofinjurydetail: boolean | null
    haveprocedure: boolean | null
    privatecase: boolean | null
    _count: MedicaltransactionsCountAggregateOutputType | null
    _avg: MedicaltransactionsAvgAggregateOutputType | null
    _sum: MedicaltransactionsSumAggregateOutputType | null
    _min: MedicaltransactionsMinAggregateOutputType | null
    _max: MedicaltransactionsMaxAggregateOutputType | null
  }

  type GetMedicaltransactionsGroupByPayload<T extends medicaltransactionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicaltransactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicaltransactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicaltransactionsGroupByOutputType[P]>
            : GetScalarType<T[P], MedicaltransactionsGroupByOutputType[P]>
        }
      >
    >


  export type medicaltransactionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insurerid?: boolean
    refid?: boolean
    transactionno?: boolean
    hn?: boolean
    vn?: boolean
    dxfreetext?: boolean
    presentillness?: boolean
    chiefcomplaint?: boolean
    accidentcauseover45days?: boolean
    underlyingcondition?: boolean
    physicalexam?: boolean
    planoftreatment?: boolean
    procedurefreetext?: boolean
    additionalnote?: boolean
    signsymptomsdate?: boolean
    comascore?: boolean
    expecteddayofrecovery?: boolean
    pregnant?: boolean
    alcoholrelated?: boolean
    haveaccidentinjurydetail?: boolean
    haveaccidentcauseofinjurydetail?: boolean
    haveprocedure?: boolean
    privatecase?: boolean
  }, ExtArgs["result"]["medicaltransactions"]>

  export type medicaltransactionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insurerid?: boolean
    refid?: boolean
    transactionno?: boolean
    hn?: boolean
    vn?: boolean
    dxfreetext?: boolean
    presentillness?: boolean
    chiefcomplaint?: boolean
    accidentcauseover45days?: boolean
    underlyingcondition?: boolean
    physicalexam?: boolean
    planoftreatment?: boolean
    procedurefreetext?: boolean
    additionalnote?: boolean
    signsymptomsdate?: boolean
    comascore?: boolean
    expecteddayofrecovery?: boolean
    pregnant?: boolean
    alcoholrelated?: boolean
    haveaccidentinjurydetail?: boolean
    haveaccidentcauseofinjurydetail?: boolean
    haveprocedure?: boolean
    privatecase?: boolean
  }, ExtArgs["result"]["medicaltransactions"]>

  export type medicaltransactionsSelectScalar = {
    id?: boolean
    insurerid?: boolean
    refid?: boolean
    transactionno?: boolean
    hn?: boolean
    vn?: boolean
    dxfreetext?: boolean
    presentillness?: boolean
    chiefcomplaint?: boolean
    accidentcauseover45days?: boolean
    underlyingcondition?: boolean
    physicalexam?: boolean
    planoftreatment?: boolean
    procedurefreetext?: boolean
    additionalnote?: boolean
    signsymptomsdate?: boolean
    comascore?: boolean
    expecteddayofrecovery?: boolean
    pregnant?: boolean
    alcoholrelated?: boolean
    haveaccidentinjurydetail?: boolean
    haveaccidentcauseofinjurydetail?: boolean
    haveprocedure?: boolean
    privatecase?: boolean
  }


  export type $medicaltransactionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "medicaltransactions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      insurerid: number | null
      refid: string | null
      transactionno: string | null
      hn: string | null
      vn: string | null
      dxfreetext: string | null
      presentillness: string | null
      chiefcomplaint: string | null
      accidentcauseover45days: string | null
      underlyingcondition: string | null
      physicalexam: string | null
      planoftreatment: string | null
      procedurefreetext: string | null
      additionalnote: string | null
      signsymptomsdate: string | null
      comascore: string | null
      expecteddayofrecovery: string | null
      pregnant: boolean | null
      alcoholrelated: boolean | null
      haveaccidentinjurydetail: boolean | null
      haveaccidentcauseofinjurydetail: boolean | null
      haveprocedure: boolean | null
      privatecase: boolean | null
    }, ExtArgs["result"]["medicaltransactions"]>
    composites: {}
  }

  type medicaltransactionsGetPayload<S extends boolean | null | undefined | medicaltransactionsDefaultArgs> = $Result.GetResult<Prisma.$medicaltransactionsPayload, S>

  type medicaltransactionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<medicaltransactionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MedicaltransactionsCountAggregateInputType | true
    }

  export interface medicaltransactionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['medicaltransactions'], meta: { name: 'medicaltransactions' } }
    /**
     * Find zero or one Medicaltransactions that matches the filter.
     * @param {medicaltransactionsFindUniqueArgs} args - Arguments to find a Medicaltransactions
     * @example
     * // Get one Medicaltransactions
     * const medicaltransactions = await prisma.medicaltransactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends medicaltransactionsFindUniqueArgs>(args: SelectSubset<T, medicaltransactionsFindUniqueArgs<ExtArgs>>): Prisma__medicaltransactionsClient<$Result.GetResult<Prisma.$medicaltransactionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Medicaltransactions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {medicaltransactionsFindUniqueOrThrowArgs} args - Arguments to find a Medicaltransactions
     * @example
     * // Get one Medicaltransactions
     * const medicaltransactions = await prisma.medicaltransactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends medicaltransactionsFindUniqueOrThrowArgs>(args: SelectSubset<T, medicaltransactionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__medicaltransactionsClient<$Result.GetResult<Prisma.$medicaltransactionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Medicaltransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicaltransactionsFindFirstArgs} args - Arguments to find a Medicaltransactions
     * @example
     * // Get one Medicaltransactions
     * const medicaltransactions = await prisma.medicaltransactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends medicaltransactionsFindFirstArgs>(args?: SelectSubset<T, medicaltransactionsFindFirstArgs<ExtArgs>>): Prisma__medicaltransactionsClient<$Result.GetResult<Prisma.$medicaltransactionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Medicaltransactions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicaltransactionsFindFirstOrThrowArgs} args - Arguments to find a Medicaltransactions
     * @example
     * // Get one Medicaltransactions
     * const medicaltransactions = await prisma.medicaltransactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends medicaltransactionsFindFirstOrThrowArgs>(args?: SelectSubset<T, medicaltransactionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__medicaltransactionsClient<$Result.GetResult<Prisma.$medicaltransactionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Medicaltransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicaltransactionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Medicaltransactions
     * const medicaltransactions = await prisma.medicaltransactions.findMany()
     * 
     * // Get first 10 Medicaltransactions
     * const medicaltransactions = await prisma.medicaltransactions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicaltransactionsWithIdOnly = await prisma.medicaltransactions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends medicaltransactionsFindManyArgs>(args?: SelectSubset<T, medicaltransactionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medicaltransactionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Medicaltransactions.
     * @param {medicaltransactionsCreateArgs} args - Arguments to create a Medicaltransactions.
     * @example
     * // Create one Medicaltransactions
     * const Medicaltransactions = await prisma.medicaltransactions.create({
     *   data: {
     *     // ... data to create a Medicaltransactions
     *   }
     * })
     * 
     */
    create<T extends medicaltransactionsCreateArgs>(args: SelectSubset<T, medicaltransactionsCreateArgs<ExtArgs>>): Prisma__medicaltransactionsClient<$Result.GetResult<Prisma.$medicaltransactionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Medicaltransactions.
     * @param {medicaltransactionsCreateManyArgs} args - Arguments to create many Medicaltransactions.
     * @example
     * // Create many Medicaltransactions
     * const medicaltransactions = await prisma.medicaltransactions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends medicaltransactionsCreateManyArgs>(args?: SelectSubset<T, medicaltransactionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Medicaltransactions and returns the data saved in the database.
     * @param {medicaltransactionsCreateManyAndReturnArgs} args - Arguments to create many Medicaltransactions.
     * @example
     * // Create many Medicaltransactions
     * const medicaltransactions = await prisma.medicaltransactions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Medicaltransactions and only return the `id`
     * const medicaltransactionsWithIdOnly = await prisma.medicaltransactions.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends medicaltransactionsCreateManyAndReturnArgs>(args?: SelectSubset<T, medicaltransactionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medicaltransactionsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Medicaltransactions.
     * @param {medicaltransactionsDeleteArgs} args - Arguments to delete one Medicaltransactions.
     * @example
     * // Delete one Medicaltransactions
     * const Medicaltransactions = await prisma.medicaltransactions.delete({
     *   where: {
     *     // ... filter to delete one Medicaltransactions
     *   }
     * })
     * 
     */
    delete<T extends medicaltransactionsDeleteArgs>(args: SelectSubset<T, medicaltransactionsDeleteArgs<ExtArgs>>): Prisma__medicaltransactionsClient<$Result.GetResult<Prisma.$medicaltransactionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Medicaltransactions.
     * @param {medicaltransactionsUpdateArgs} args - Arguments to update one Medicaltransactions.
     * @example
     * // Update one Medicaltransactions
     * const medicaltransactions = await prisma.medicaltransactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends medicaltransactionsUpdateArgs>(args: SelectSubset<T, medicaltransactionsUpdateArgs<ExtArgs>>): Prisma__medicaltransactionsClient<$Result.GetResult<Prisma.$medicaltransactionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Medicaltransactions.
     * @param {medicaltransactionsDeleteManyArgs} args - Arguments to filter Medicaltransactions to delete.
     * @example
     * // Delete a few Medicaltransactions
     * const { count } = await prisma.medicaltransactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends medicaltransactionsDeleteManyArgs>(args?: SelectSubset<T, medicaltransactionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medicaltransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicaltransactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Medicaltransactions
     * const medicaltransactions = await prisma.medicaltransactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends medicaltransactionsUpdateManyArgs>(args: SelectSubset<T, medicaltransactionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Medicaltransactions.
     * @param {medicaltransactionsUpsertArgs} args - Arguments to update or create a Medicaltransactions.
     * @example
     * // Update or create a Medicaltransactions
     * const medicaltransactions = await prisma.medicaltransactions.upsert({
     *   create: {
     *     // ... data to create a Medicaltransactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Medicaltransactions we want to update
     *   }
     * })
     */
    upsert<T extends medicaltransactionsUpsertArgs>(args: SelectSubset<T, medicaltransactionsUpsertArgs<ExtArgs>>): Prisma__medicaltransactionsClient<$Result.GetResult<Prisma.$medicaltransactionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Medicaltransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicaltransactionsCountArgs} args - Arguments to filter Medicaltransactions to count.
     * @example
     * // Count the number of Medicaltransactions
     * const count = await prisma.medicaltransactions.count({
     *   where: {
     *     // ... the filter for the Medicaltransactions we want to count
     *   }
     * })
    **/
    count<T extends medicaltransactionsCountArgs>(
      args?: Subset<T, medicaltransactionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicaltransactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Medicaltransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicaltransactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicaltransactionsAggregateArgs>(args: Subset<T, MedicaltransactionsAggregateArgs>): Prisma.PrismaPromise<GetMedicaltransactionsAggregateType<T>>

    /**
     * Group by Medicaltransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicaltransactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends medicaltransactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: medicaltransactionsGroupByArgs['orderBy'] }
        : { orderBy?: medicaltransactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, medicaltransactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicaltransactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the medicaltransactions model
   */
  readonly fields: medicaltransactionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for medicaltransactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__medicaltransactionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the medicaltransactions model
   */ 
  interface medicaltransactionsFieldRefs {
    readonly id: FieldRef<"medicaltransactions", 'Int'>
    readonly insurerid: FieldRef<"medicaltransactions", 'Int'>
    readonly refid: FieldRef<"medicaltransactions", 'String'>
    readonly transactionno: FieldRef<"medicaltransactions", 'String'>
    readonly hn: FieldRef<"medicaltransactions", 'String'>
    readonly vn: FieldRef<"medicaltransactions", 'String'>
    readonly dxfreetext: FieldRef<"medicaltransactions", 'String'>
    readonly presentillness: FieldRef<"medicaltransactions", 'String'>
    readonly chiefcomplaint: FieldRef<"medicaltransactions", 'String'>
    readonly accidentcauseover45days: FieldRef<"medicaltransactions", 'String'>
    readonly underlyingcondition: FieldRef<"medicaltransactions", 'String'>
    readonly physicalexam: FieldRef<"medicaltransactions", 'String'>
    readonly planoftreatment: FieldRef<"medicaltransactions", 'String'>
    readonly procedurefreetext: FieldRef<"medicaltransactions", 'String'>
    readonly additionalnote: FieldRef<"medicaltransactions", 'String'>
    readonly signsymptomsdate: FieldRef<"medicaltransactions", 'String'>
    readonly comascore: FieldRef<"medicaltransactions", 'String'>
    readonly expecteddayofrecovery: FieldRef<"medicaltransactions", 'String'>
    readonly pregnant: FieldRef<"medicaltransactions", 'Boolean'>
    readonly alcoholrelated: FieldRef<"medicaltransactions", 'Boolean'>
    readonly haveaccidentinjurydetail: FieldRef<"medicaltransactions", 'Boolean'>
    readonly haveaccidentcauseofinjurydetail: FieldRef<"medicaltransactions", 'Boolean'>
    readonly haveprocedure: FieldRef<"medicaltransactions", 'Boolean'>
    readonly privatecase: FieldRef<"medicaltransactions", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * medicaltransactions findUnique
   */
  export type medicaltransactionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicaltransactions
     */
    select?: medicaltransactionsSelect<ExtArgs> | null
    /**
     * Filter, which medicaltransactions to fetch.
     */
    where: medicaltransactionsWhereUniqueInput
  }

  /**
   * medicaltransactions findUniqueOrThrow
   */
  export type medicaltransactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicaltransactions
     */
    select?: medicaltransactionsSelect<ExtArgs> | null
    /**
     * Filter, which medicaltransactions to fetch.
     */
    where: medicaltransactionsWhereUniqueInput
  }

  /**
   * medicaltransactions findFirst
   */
  export type medicaltransactionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicaltransactions
     */
    select?: medicaltransactionsSelect<ExtArgs> | null
    /**
     * Filter, which medicaltransactions to fetch.
     */
    where?: medicaltransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medicaltransactions to fetch.
     */
    orderBy?: medicaltransactionsOrderByWithRelationInput | medicaltransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for medicaltransactions.
     */
    cursor?: medicaltransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medicaltransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medicaltransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of medicaltransactions.
     */
    distinct?: MedicaltransactionsScalarFieldEnum | MedicaltransactionsScalarFieldEnum[]
  }

  /**
   * medicaltransactions findFirstOrThrow
   */
  export type medicaltransactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicaltransactions
     */
    select?: medicaltransactionsSelect<ExtArgs> | null
    /**
     * Filter, which medicaltransactions to fetch.
     */
    where?: medicaltransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medicaltransactions to fetch.
     */
    orderBy?: medicaltransactionsOrderByWithRelationInput | medicaltransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for medicaltransactions.
     */
    cursor?: medicaltransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medicaltransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medicaltransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of medicaltransactions.
     */
    distinct?: MedicaltransactionsScalarFieldEnum | MedicaltransactionsScalarFieldEnum[]
  }

  /**
   * medicaltransactions findMany
   */
  export type medicaltransactionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicaltransactions
     */
    select?: medicaltransactionsSelect<ExtArgs> | null
    /**
     * Filter, which medicaltransactions to fetch.
     */
    where?: medicaltransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medicaltransactions to fetch.
     */
    orderBy?: medicaltransactionsOrderByWithRelationInput | medicaltransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing medicaltransactions.
     */
    cursor?: medicaltransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medicaltransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medicaltransactions.
     */
    skip?: number
    distinct?: MedicaltransactionsScalarFieldEnum | MedicaltransactionsScalarFieldEnum[]
  }

  /**
   * medicaltransactions create
   */
  export type medicaltransactionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicaltransactions
     */
    select?: medicaltransactionsSelect<ExtArgs> | null
    /**
     * The data needed to create a medicaltransactions.
     */
    data?: XOR<medicaltransactionsCreateInput, medicaltransactionsUncheckedCreateInput>
  }

  /**
   * medicaltransactions createMany
   */
  export type medicaltransactionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many medicaltransactions.
     */
    data: medicaltransactionsCreateManyInput | medicaltransactionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * medicaltransactions createManyAndReturn
   */
  export type medicaltransactionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicaltransactions
     */
    select?: medicaltransactionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many medicaltransactions.
     */
    data: medicaltransactionsCreateManyInput | medicaltransactionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * medicaltransactions update
   */
  export type medicaltransactionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicaltransactions
     */
    select?: medicaltransactionsSelect<ExtArgs> | null
    /**
     * The data needed to update a medicaltransactions.
     */
    data: XOR<medicaltransactionsUpdateInput, medicaltransactionsUncheckedUpdateInput>
    /**
     * Choose, which medicaltransactions to update.
     */
    where: medicaltransactionsWhereUniqueInput
  }

  /**
   * medicaltransactions updateMany
   */
  export type medicaltransactionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update medicaltransactions.
     */
    data: XOR<medicaltransactionsUpdateManyMutationInput, medicaltransactionsUncheckedUpdateManyInput>
    /**
     * Filter which medicaltransactions to update
     */
    where?: medicaltransactionsWhereInput
  }

  /**
   * medicaltransactions upsert
   */
  export type medicaltransactionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicaltransactions
     */
    select?: medicaltransactionsSelect<ExtArgs> | null
    /**
     * The filter to search for the medicaltransactions to update in case it exists.
     */
    where: medicaltransactionsWhereUniqueInput
    /**
     * In case the medicaltransactions found by the `where` argument doesn't exist, create a new medicaltransactions with this data.
     */
    create: XOR<medicaltransactionsCreateInput, medicaltransactionsUncheckedCreateInput>
    /**
     * In case the medicaltransactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<medicaltransactionsUpdateInput, medicaltransactionsUncheckedUpdateInput>
  }

  /**
   * medicaltransactions delete
   */
  export type medicaltransactionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicaltransactions
     */
    select?: medicaltransactionsSelect<ExtArgs> | null
    /**
     * Filter which medicaltransactions to delete.
     */
    where: medicaltransactionsWhereUniqueInput
  }

  /**
   * medicaltransactions deleteMany
   */
  export type medicaltransactionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which medicaltransactions to delete
     */
    where?: medicaltransactionsWhereInput
  }

  /**
   * medicaltransactions without action
   */
  export type medicaltransactionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicaltransactions
     */
    select?: medicaltransactionsSelect<ExtArgs> | null
  }


  /**
   * Model policytype
   */

  export type AggregatePolicytype = {
    _count: PolicytypeCountAggregateOutputType | null
    _avg: PolicytypeAvgAggregateOutputType | null
    _sum: PolicytypeSumAggregateOutputType | null
    _min: PolicytypeMinAggregateOutputType | null
    _max: PolicytypeMaxAggregateOutputType | null
  }

  export type PolicytypeAvgAggregateOutputType = {
    id: number | null
    insurerid: number | null
  }

  export type PolicytypeSumAggregateOutputType = {
    id: number | null
    insurerid: number | null
  }

  export type PolicytypeMinAggregateOutputType = {
    id: number | null
    policytypecode: string | null
    policytypedesc: string | null
    insurerid: number | null
  }

  export type PolicytypeMaxAggregateOutputType = {
    id: number | null
    policytypecode: string | null
    policytypedesc: string | null
    insurerid: number | null
  }

  export type PolicytypeCountAggregateOutputType = {
    id: number
    policytypecode: number
    policytypedesc: number
    insurerid: number
    _all: number
  }


  export type PolicytypeAvgAggregateInputType = {
    id?: true
    insurerid?: true
  }

  export type PolicytypeSumAggregateInputType = {
    id?: true
    insurerid?: true
  }

  export type PolicytypeMinAggregateInputType = {
    id?: true
    policytypecode?: true
    policytypedesc?: true
    insurerid?: true
  }

  export type PolicytypeMaxAggregateInputType = {
    id?: true
    policytypecode?: true
    policytypedesc?: true
    insurerid?: true
  }

  export type PolicytypeCountAggregateInputType = {
    id?: true
    policytypecode?: true
    policytypedesc?: true
    insurerid?: true
    _all?: true
  }

  export type PolicytypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which policytype to aggregate.
     */
    where?: policytypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of policytypes to fetch.
     */
    orderBy?: policytypeOrderByWithRelationInput | policytypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: policytypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` policytypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` policytypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned policytypes
    **/
    _count?: true | PolicytypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PolicytypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PolicytypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PolicytypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PolicytypeMaxAggregateInputType
  }

  export type GetPolicytypeAggregateType<T extends PolicytypeAggregateArgs> = {
        [P in keyof T & keyof AggregatePolicytype]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePolicytype[P]>
      : GetScalarType<T[P], AggregatePolicytype[P]>
  }




  export type policytypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: policytypeWhereInput
    orderBy?: policytypeOrderByWithAggregationInput | policytypeOrderByWithAggregationInput[]
    by: PolicytypeScalarFieldEnum[] | PolicytypeScalarFieldEnum
    having?: policytypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PolicytypeCountAggregateInputType | true
    _avg?: PolicytypeAvgAggregateInputType
    _sum?: PolicytypeSumAggregateInputType
    _min?: PolicytypeMinAggregateInputType
    _max?: PolicytypeMaxAggregateInputType
  }

  export type PolicytypeGroupByOutputType = {
    id: number
    policytypecode: string
    policytypedesc: string | null
    insurerid: number | null
    _count: PolicytypeCountAggregateOutputType | null
    _avg: PolicytypeAvgAggregateOutputType | null
    _sum: PolicytypeSumAggregateOutputType | null
    _min: PolicytypeMinAggregateOutputType | null
    _max: PolicytypeMaxAggregateOutputType | null
  }

  type GetPolicytypeGroupByPayload<T extends policytypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PolicytypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PolicytypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PolicytypeGroupByOutputType[P]>
            : GetScalarType<T[P], PolicytypeGroupByOutputType[P]>
        }
      >
    >


  export type policytypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    policytypecode?: boolean
    policytypedesc?: boolean
    insurerid?: boolean
    insurers?: boolean | policytype$insurersArgs<ExtArgs>
  }, ExtArgs["result"]["policytype"]>

  export type policytypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    policytypecode?: boolean
    policytypedesc?: boolean
    insurerid?: boolean
    insurers?: boolean | policytype$insurersArgs<ExtArgs>
  }, ExtArgs["result"]["policytype"]>

  export type policytypeSelectScalar = {
    id?: boolean
    policytypecode?: boolean
    policytypedesc?: boolean
    insurerid?: boolean
  }

  export type policytypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurers?: boolean | policytype$insurersArgs<ExtArgs>
  }
  export type policytypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurers?: boolean | policytype$insurersArgs<ExtArgs>
  }

  export type $policytypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "policytype"
    objects: {
      insurers: Prisma.$insurersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      policytypecode: string
      policytypedesc: string | null
      insurerid: number | null
    }, ExtArgs["result"]["policytype"]>
    composites: {}
  }

  type policytypeGetPayload<S extends boolean | null | undefined | policytypeDefaultArgs> = $Result.GetResult<Prisma.$policytypePayload, S>

  type policytypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<policytypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PolicytypeCountAggregateInputType | true
    }

  export interface policytypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['policytype'], meta: { name: 'policytype' } }
    /**
     * Find zero or one Policytype that matches the filter.
     * @param {policytypeFindUniqueArgs} args - Arguments to find a Policytype
     * @example
     * // Get one Policytype
     * const policytype = await prisma.policytype.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends policytypeFindUniqueArgs>(args: SelectSubset<T, policytypeFindUniqueArgs<ExtArgs>>): Prisma__policytypeClient<$Result.GetResult<Prisma.$policytypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Policytype that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {policytypeFindUniqueOrThrowArgs} args - Arguments to find a Policytype
     * @example
     * // Get one Policytype
     * const policytype = await prisma.policytype.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends policytypeFindUniqueOrThrowArgs>(args: SelectSubset<T, policytypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__policytypeClient<$Result.GetResult<Prisma.$policytypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Policytype that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {policytypeFindFirstArgs} args - Arguments to find a Policytype
     * @example
     * // Get one Policytype
     * const policytype = await prisma.policytype.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends policytypeFindFirstArgs>(args?: SelectSubset<T, policytypeFindFirstArgs<ExtArgs>>): Prisma__policytypeClient<$Result.GetResult<Prisma.$policytypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Policytype that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {policytypeFindFirstOrThrowArgs} args - Arguments to find a Policytype
     * @example
     * // Get one Policytype
     * const policytype = await prisma.policytype.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends policytypeFindFirstOrThrowArgs>(args?: SelectSubset<T, policytypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__policytypeClient<$Result.GetResult<Prisma.$policytypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Policytypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {policytypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Policytypes
     * const policytypes = await prisma.policytype.findMany()
     * 
     * // Get first 10 Policytypes
     * const policytypes = await prisma.policytype.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const policytypeWithIdOnly = await prisma.policytype.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends policytypeFindManyArgs>(args?: SelectSubset<T, policytypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$policytypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Policytype.
     * @param {policytypeCreateArgs} args - Arguments to create a Policytype.
     * @example
     * // Create one Policytype
     * const Policytype = await prisma.policytype.create({
     *   data: {
     *     // ... data to create a Policytype
     *   }
     * })
     * 
     */
    create<T extends policytypeCreateArgs>(args: SelectSubset<T, policytypeCreateArgs<ExtArgs>>): Prisma__policytypeClient<$Result.GetResult<Prisma.$policytypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Policytypes.
     * @param {policytypeCreateManyArgs} args - Arguments to create many Policytypes.
     * @example
     * // Create many Policytypes
     * const policytype = await prisma.policytype.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends policytypeCreateManyArgs>(args?: SelectSubset<T, policytypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Policytypes and returns the data saved in the database.
     * @param {policytypeCreateManyAndReturnArgs} args - Arguments to create many Policytypes.
     * @example
     * // Create many Policytypes
     * const policytype = await prisma.policytype.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Policytypes and only return the `id`
     * const policytypeWithIdOnly = await prisma.policytype.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends policytypeCreateManyAndReturnArgs>(args?: SelectSubset<T, policytypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$policytypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Policytype.
     * @param {policytypeDeleteArgs} args - Arguments to delete one Policytype.
     * @example
     * // Delete one Policytype
     * const Policytype = await prisma.policytype.delete({
     *   where: {
     *     // ... filter to delete one Policytype
     *   }
     * })
     * 
     */
    delete<T extends policytypeDeleteArgs>(args: SelectSubset<T, policytypeDeleteArgs<ExtArgs>>): Prisma__policytypeClient<$Result.GetResult<Prisma.$policytypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Policytype.
     * @param {policytypeUpdateArgs} args - Arguments to update one Policytype.
     * @example
     * // Update one Policytype
     * const policytype = await prisma.policytype.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends policytypeUpdateArgs>(args: SelectSubset<T, policytypeUpdateArgs<ExtArgs>>): Prisma__policytypeClient<$Result.GetResult<Prisma.$policytypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Policytypes.
     * @param {policytypeDeleteManyArgs} args - Arguments to filter Policytypes to delete.
     * @example
     * // Delete a few Policytypes
     * const { count } = await prisma.policytype.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends policytypeDeleteManyArgs>(args?: SelectSubset<T, policytypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Policytypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {policytypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Policytypes
     * const policytype = await prisma.policytype.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends policytypeUpdateManyArgs>(args: SelectSubset<T, policytypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Policytype.
     * @param {policytypeUpsertArgs} args - Arguments to update or create a Policytype.
     * @example
     * // Update or create a Policytype
     * const policytype = await prisma.policytype.upsert({
     *   create: {
     *     // ... data to create a Policytype
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Policytype we want to update
     *   }
     * })
     */
    upsert<T extends policytypeUpsertArgs>(args: SelectSubset<T, policytypeUpsertArgs<ExtArgs>>): Prisma__policytypeClient<$Result.GetResult<Prisma.$policytypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Policytypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {policytypeCountArgs} args - Arguments to filter Policytypes to count.
     * @example
     * // Count the number of Policytypes
     * const count = await prisma.policytype.count({
     *   where: {
     *     // ... the filter for the Policytypes we want to count
     *   }
     * })
    **/
    count<T extends policytypeCountArgs>(
      args?: Subset<T, policytypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PolicytypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Policytype.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicytypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PolicytypeAggregateArgs>(args: Subset<T, PolicytypeAggregateArgs>): Prisma.PrismaPromise<GetPolicytypeAggregateType<T>>

    /**
     * Group by Policytype.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {policytypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends policytypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: policytypeGroupByArgs['orderBy'] }
        : { orderBy?: policytypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, policytypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPolicytypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the policytype model
   */
  readonly fields: policytypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for policytype.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__policytypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    insurers<T extends policytype$insurersArgs<ExtArgs> = {}>(args?: Subset<T, policytype$insurersArgs<ExtArgs>>): Prisma__insurersClient<$Result.GetResult<Prisma.$insurersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the policytype model
   */ 
  interface policytypeFieldRefs {
    readonly id: FieldRef<"policytype", 'Int'>
    readonly policytypecode: FieldRef<"policytype", 'String'>
    readonly policytypedesc: FieldRef<"policytype", 'String'>
    readonly insurerid: FieldRef<"policytype", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * policytype findUnique
   */
  export type policytypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the policytype
     */
    select?: policytypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: policytypeInclude<ExtArgs> | null
    /**
     * Filter, which policytype to fetch.
     */
    where: policytypeWhereUniqueInput
  }

  /**
   * policytype findUniqueOrThrow
   */
  export type policytypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the policytype
     */
    select?: policytypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: policytypeInclude<ExtArgs> | null
    /**
     * Filter, which policytype to fetch.
     */
    where: policytypeWhereUniqueInput
  }

  /**
   * policytype findFirst
   */
  export type policytypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the policytype
     */
    select?: policytypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: policytypeInclude<ExtArgs> | null
    /**
     * Filter, which policytype to fetch.
     */
    where?: policytypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of policytypes to fetch.
     */
    orderBy?: policytypeOrderByWithRelationInput | policytypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for policytypes.
     */
    cursor?: policytypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` policytypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` policytypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of policytypes.
     */
    distinct?: PolicytypeScalarFieldEnum | PolicytypeScalarFieldEnum[]
  }

  /**
   * policytype findFirstOrThrow
   */
  export type policytypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the policytype
     */
    select?: policytypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: policytypeInclude<ExtArgs> | null
    /**
     * Filter, which policytype to fetch.
     */
    where?: policytypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of policytypes to fetch.
     */
    orderBy?: policytypeOrderByWithRelationInput | policytypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for policytypes.
     */
    cursor?: policytypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` policytypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` policytypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of policytypes.
     */
    distinct?: PolicytypeScalarFieldEnum | PolicytypeScalarFieldEnum[]
  }

  /**
   * policytype findMany
   */
  export type policytypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the policytype
     */
    select?: policytypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: policytypeInclude<ExtArgs> | null
    /**
     * Filter, which policytypes to fetch.
     */
    where?: policytypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of policytypes to fetch.
     */
    orderBy?: policytypeOrderByWithRelationInput | policytypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing policytypes.
     */
    cursor?: policytypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` policytypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` policytypes.
     */
    skip?: number
    distinct?: PolicytypeScalarFieldEnum | PolicytypeScalarFieldEnum[]
  }

  /**
   * policytype create
   */
  export type policytypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the policytype
     */
    select?: policytypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: policytypeInclude<ExtArgs> | null
    /**
     * The data needed to create a policytype.
     */
    data: XOR<policytypeCreateInput, policytypeUncheckedCreateInput>
  }

  /**
   * policytype createMany
   */
  export type policytypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many policytypes.
     */
    data: policytypeCreateManyInput | policytypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * policytype createManyAndReturn
   */
  export type policytypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the policytype
     */
    select?: policytypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many policytypes.
     */
    data: policytypeCreateManyInput | policytypeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: policytypeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * policytype update
   */
  export type policytypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the policytype
     */
    select?: policytypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: policytypeInclude<ExtArgs> | null
    /**
     * The data needed to update a policytype.
     */
    data: XOR<policytypeUpdateInput, policytypeUncheckedUpdateInput>
    /**
     * Choose, which policytype to update.
     */
    where: policytypeWhereUniqueInput
  }

  /**
   * policytype updateMany
   */
  export type policytypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update policytypes.
     */
    data: XOR<policytypeUpdateManyMutationInput, policytypeUncheckedUpdateManyInput>
    /**
     * Filter which policytypes to update
     */
    where?: policytypeWhereInput
  }

  /**
   * policytype upsert
   */
  export type policytypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the policytype
     */
    select?: policytypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: policytypeInclude<ExtArgs> | null
    /**
     * The filter to search for the policytype to update in case it exists.
     */
    where: policytypeWhereUniqueInput
    /**
     * In case the policytype found by the `where` argument doesn't exist, create a new policytype with this data.
     */
    create: XOR<policytypeCreateInput, policytypeUncheckedCreateInput>
    /**
     * In case the policytype was found with the provided `where` argument, update it with this data.
     */
    update: XOR<policytypeUpdateInput, policytypeUncheckedUpdateInput>
  }

  /**
   * policytype delete
   */
  export type policytypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the policytype
     */
    select?: policytypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: policytypeInclude<ExtArgs> | null
    /**
     * Filter which policytype to delete.
     */
    where: policytypeWhereUniqueInput
  }

  /**
   * policytype deleteMany
   */
  export type policytypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which policytypes to delete
     */
    where?: policytypeWhereInput
  }

  /**
   * policytype.insurers
   */
  export type policytype$insurersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insurers
     */
    select?: insurersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: insurersInclude<ExtArgs> | null
    where?: insurersWhereInput
  }

  /**
   * policytype without action
   */
  export type policytypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the policytype
     */
    select?: policytypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: policytypeInclude<ExtArgs> | null
  }


  /**
   * Model servicesetting
   */

  export type AggregateServicesetting = {
    _count: ServicesettingCountAggregateOutputType | null
    _avg: ServicesettingAvgAggregateOutputType | null
    _sum: ServicesettingSumAggregateOutputType | null
    _min: ServicesettingMinAggregateOutputType | null
    _max: ServicesettingMaxAggregateOutputType | null
  }

  export type ServicesettingAvgAggregateOutputType = {
    id: number | null
    insurerid: number | null
  }

  export type ServicesettingSumAggregateOutputType = {
    id: number | null
    insurerid: number | null
  }

  export type ServicesettingMinAggregateOutputType = {
    id: number | null
    servicesettingcode: string | null
    servicesettingdesc: string | null
    insurerid: number | null
  }

  export type ServicesettingMaxAggregateOutputType = {
    id: number | null
    servicesettingcode: string | null
    servicesettingdesc: string | null
    insurerid: number | null
  }

  export type ServicesettingCountAggregateOutputType = {
    id: number
    servicesettingcode: number
    servicesettingdesc: number
    insurerid: number
    _all: number
  }


  export type ServicesettingAvgAggregateInputType = {
    id?: true
    insurerid?: true
  }

  export type ServicesettingSumAggregateInputType = {
    id?: true
    insurerid?: true
  }

  export type ServicesettingMinAggregateInputType = {
    id?: true
    servicesettingcode?: true
    servicesettingdesc?: true
    insurerid?: true
  }

  export type ServicesettingMaxAggregateInputType = {
    id?: true
    servicesettingcode?: true
    servicesettingdesc?: true
    insurerid?: true
  }

  export type ServicesettingCountAggregateInputType = {
    id?: true
    servicesettingcode?: true
    servicesettingdesc?: true
    insurerid?: true
    _all?: true
  }

  export type ServicesettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicesetting to aggregate.
     */
    where?: servicesettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicesettings to fetch.
     */
    orderBy?: servicesettingOrderByWithRelationInput | servicesettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: servicesettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicesettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicesettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned servicesettings
    **/
    _count?: true | ServicesettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicesettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicesettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicesettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicesettingMaxAggregateInputType
  }

  export type GetServicesettingAggregateType<T extends ServicesettingAggregateArgs> = {
        [P in keyof T & keyof AggregateServicesetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicesetting[P]>
      : GetScalarType<T[P], AggregateServicesetting[P]>
  }




  export type servicesettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: servicesettingWhereInput
    orderBy?: servicesettingOrderByWithAggregationInput | servicesettingOrderByWithAggregationInput[]
    by: ServicesettingScalarFieldEnum[] | ServicesettingScalarFieldEnum
    having?: servicesettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicesettingCountAggregateInputType | true
    _avg?: ServicesettingAvgAggregateInputType
    _sum?: ServicesettingSumAggregateInputType
    _min?: ServicesettingMinAggregateInputType
    _max?: ServicesettingMaxAggregateInputType
  }

  export type ServicesettingGroupByOutputType = {
    id: number
    servicesettingcode: string
    servicesettingdesc: string
    insurerid: number | null
    _count: ServicesettingCountAggregateOutputType | null
    _avg: ServicesettingAvgAggregateOutputType | null
    _sum: ServicesettingSumAggregateOutputType | null
    _min: ServicesettingMinAggregateOutputType | null
    _max: ServicesettingMaxAggregateOutputType | null
  }

  type GetServicesettingGroupByPayload<T extends servicesettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicesettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicesettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicesettingGroupByOutputType[P]>
            : GetScalarType<T[P], ServicesettingGroupByOutputType[P]>
        }
      >
    >


  export type servicesettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    servicesettingcode?: boolean
    servicesettingdesc?: boolean
    insurerid?: boolean
    insurers?: boolean | servicesetting$insurersArgs<ExtArgs>
  }, ExtArgs["result"]["servicesetting"]>

  export type servicesettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    servicesettingcode?: boolean
    servicesettingdesc?: boolean
    insurerid?: boolean
    insurers?: boolean | servicesetting$insurersArgs<ExtArgs>
  }, ExtArgs["result"]["servicesetting"]>

  export type servicesettingSelectScalar = {
    id?: boolean
    servicesettingcode?: boolean
    servicesettingdesc?: boolean
    insurerid?: boolean
  }

  export type servicesettingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurers?: boolean | servicesetting$insurersArgs<ExtArgs>
  }
  export type servicesettingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurers?: boolean | servicesetting$insurersArgs<ExtArgs>
  }

  export type $servicesettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "servicesetting"
    objects: {
      insurers: Prisma.$insurersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      servicesettingcode: string
      servicesettingdesc: string
      insurerid: number | null
    }, ExtArgs["result"]["servicesetting"]>
    composites: {}
  }

  type servicesettingGetPayload<S extends boolean | null | undefined | servicesettingDefaultArgs> = $Result.GetResult<Prisma.$servicesettingPayload, S>

  type servicesettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<servicesettingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServicesettingCountAggregateInputType | true
    }

  export interface servicesettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['servicesetting'], meta: { name: 'servicesetting' } }
    /**
     * Find zero or one Servicesetting that matches the filter.
     * @param {servicesettingFindUniqueArgs} args - Arguments to find a Servicesetting
     * @example
     * // Get one Servicesetting
     * const servicesetting = await prisma.servicesetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends servicesettingFindUniqueArgs>(args: SelectSubset<T, servicesettingFindUniqueArgs<ExtArgs>>): Prisma__servicesettingClient<$Result.GetResult<Prisma.$servicesettingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Servicesetting that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {servicesettingFindUniqueOrThrowArgs} args - Arguments to find a Servicesetting
     * @example
     * // Get one Servicesetting
     * const servicesetting = await prisma.servicesetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends servicesettingFindUniqueOrThrowArgs>(args: SelectSubset<T, servicesettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__servicesettingClient<$Result.GetResult<Prisma.$servicesettingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Servicesetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesettingFindFirstArgs} args - Arguments to find a Servicesetting
     * @example
     * // Get one Servicesetting
     * const servicesetting = await prisma.servicesetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends servicesettingFindFirstArgs>(args?: SelectSubset<T, servicesettingFindFirstArgs<ExtArgs>>): Prisma__servicesettingClient<$Result.GetResult<Prisma.$servicesettingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Servicesetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesettingFindFirstOrThrowArgs} args - Arguments to find a Servicesetting
     * @example
     * // Get one Servicesetting
     * const servicesetting = await prisma.servicesetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends servicesettingFindFirstOrThrowArgs>(args?: SelectSubset<T, servicesettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__servicesettingClient<$Result.GetResult<Prisma.$servicesettingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Servicesettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicesettings
     * const servicesettings = await prisma.servicesetting.findMany()
     * 
     * // Get first 10 Servicesettings
     * const servicesettings = await prisma.servicesetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const servicesettingWithIdOnly = await prisma.servicesetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends servicesettingFindManyArgs>(args?: SelectSubset<T, servicesettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$servicesettingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Servicesetting.
     * @param {servicesettingCreateArgs} args - Arguments to create a Servicesetting.
     * @example
     * // Create one Servicesetting
     * const Servicesetting = await prisma.servicesetting.create({
     *   data: {
     *     // ... data to create a Servicesetting
     *   }
     * })
     * 
     */
    create<T extends servicesettingCreateArgs>(args: SelectSubset<T, servicesettingCreateArgs<ExtArgs>>): Prisma__servicesettingClient<$Result.GetResult<Prisma.$servicesettingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Servicesettings.
     * @param {servicesettingCreateManyArgs} args - Arguments to create many Servicesettings.
     * @example
     * // Create many Servicesettings
     * const servicesetting = await prisma.servicesetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends servicesettingCreateManyArgs>(args?: SelectSubset<T, servicesettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Servicesettings and returns the data saved in the database.
     * @param {servicesettingCreateManyAndReturnArgs} args - Arguments to create many Servicesettings.
     * @example
     * // Create many Servicesettings
     * const servicesetting = await prisma.servicesetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Servicesettings and only return the `id`
     * const servicesettingWithIdOnly = await prisma.servicesetting.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends servicesettingCreateManyAndReturnArgs>(args?: SelectSubset<T, servicesettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$servicesettingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Servicesetting.
     * @param {servicesettingDeleteArgs} args - Arguments to delete one Servicesetting.
     * @example
     * // Delete one Servicesetting
     * const Servicesetting = await prisma.servicesetting.delete({
     *   where: {
     *     // ... filter to delete one Servicesetting
     *   }
     * })
     * 
     */
    delete<T extends servicesettingDeleteArgs>(args: SelectSubset<T, servicesettingDeleteArgs<ExtArgs>>): Prisma__servicesettingClient<$Result.GetResult<Prisma.$servicesettingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Servicesetting.
     * @param {servicesettingUpdateArgs} args - Arguments to update one Servicesetting.
     * @example
     * // Update one Servicesetting
     * const servicesetting = await prisma.servicesetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends servicesettingUpdateArgs>(args: SelectSubset<T, servicesettingUpdateArgs<ExtArgs>>): Prisma__servicesettingClient<$Result.GetResult<Prisma.$servicesettingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Servicesettings.
     * @param {servicesettingDeleteManyArgs} args - Arguments to filter Servicesettings to delete.
     * @example
     * // Delete a few Servicesettings
     * const { count } = await prisma.servicesetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends servicesettingDeleteManyArgs>(args?: SelectSubset<T, servicesettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicesettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicesettings
     * const servicesetting = await prisma.servicesetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends servicesettingUpdateManyArgs>(args: SelectSubset<T, servicesettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Servicesetting.
     * @param {servicesettingUpsertArgs} args - Arguments to update or create a Servicesetting.
     * @example
     * // Update or create a Servicesetting
     * const servicesetting = await prisma.servicesetting.upsert({
     *   create: {
     *     // ... data to create a Servicesetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicesetting we want to update
     *   }
     * })
     */
    upsert<T extends servicesettingUpsertArgs>(args: SelectSubset<T, servicesettingUpsertArgs<ExtArgs>>): Prisma__servicesettingClient<$Result.GetResult<Prisma.$servicesettingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Servicesettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesettingCountArgs} args - Arguments to filter Servicesettings to count.
     * @example
     * // Count the number of Servicesettings
     * const count = await prisma.servicesetting.count({
     *   where: {
     *     // ... the filter for the Servicesettings we want to count
     *   }
     * })
    **/
    count<T extends servicesettingCountArgs>(
      args?: Subset<T, servicesettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicesettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicesetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicesettingAggregateArgs>(args: Subset<T, ServicesettingAggregateArgs>): Prisma.PrismaPromise<GetServicesettingAggregateType<T>>

    /**
     * Group by Servicesetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends servicesettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: servicesettingGroupByArgs['orderBy'] }
        : { orderBy?: servicesettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, servicesettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicesettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the servicesetting model
   */
  readonly fields: servicesettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for servicesetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__servicesettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    insurers<T extends servicesetting$insurersArgs<ExtArgs> = {}>(args?: Subset<T, servicesetting$insurersArgs<ExtArgs>>): Prisma__insurersClient<$Result.GetResult<Prisma.$insurersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the servicesetting model
   */ 
  interface servicesettingFieldRefs {
    readonly id: FieldRef<"servicesetting", 'Int'>
    readonly servicesettingcode: FieldRef<"servicesetting", 'String'>
    readonly servicesettingdesc: FieldRef<"servicesetting", 'String'>
    readonly insurerid: FieldRef<"servicesetting", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * servicesetting findUnique
   */
  export type servicesettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicesetting
     */
    select?: servicesettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesettingInclude<ExtArgs> | null
    /**
     * Filter, which servicesetting to fetch.
     */
    where: servicesettingWhereUniqueInput
  }

  /**
   * servicesetting findUniqueOrThrow
   */
  export type servicesettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicesetting
     */
    select?: servicesettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesettingInclude<ExtArgs> | null
    /**
     * Filter, which servicesetting to fetch.
     */
    where: servicesettingWhereUniqueInput
  }

  /**
   * servicesetting findFirst
   */
  export type servicesettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicesetting
     */
    select?: servicesettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesettingInclude<ExtArgs> | null
    /**
     * Filter, which servicesetting to fetch.
     */
    where?: servicesettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicesettings to fetch.
     */
    orderBy?: servicesettingOrderByWithRelationInput | servicesettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicesettings.
     */
    cursor?: servicesettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicesettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicesettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicesettings.
     */
    distinct?: ServicesettingScalarFieldEnum | ServicesettingScalarFieldEnum[]
  }

  /**
   * servicesetting findFirstOrThrow
   */
  export type servicesettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicesetting
     */
    select?: servicesettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesettingInclude<ExtArgs> | null
    /**
     * Filter, which servicesetting to fetch.
     */
    where?: servicesettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicesettings to fetch.
     */
    orderBy?: servicesettingOrderByWithRelationInput | servicesettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicesettings.
     */
    cursor?: servicesettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicesettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicesettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicesettings.
     */
    distinct?: ServicesettingScalarFieldEnum | ServicesettingScalarFieldEnum[]
  }

  /**
   * servicesetting findMany
   */
  export type servicesettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicesetting
     */
    select?: servicesettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesettingInclude<ExtArgs> | null
    /**
     * Filter, which servicesettings to fetch.
     */
    where?: servicesettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicesettings to fetch.
     */
    orderBy?: servicesettingOrderByWithRelationInput | servicesettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing servicesettings.
     */
    cursor?: servicesettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicesettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicesettings.
     */
    skip?: number
    distinct?: ServicesettingScalarFieldEnum | ServicesettingScalarFieldEnum[]
  }

  /**
   * servicesetting create
   */
  export type servicesettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicesetting
     */
    select?: servicesettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesettingInclude<ExtArgs> | null
    /**
     * The data needed to create a servicesetting.
     */
    data: XOR<servicesettingCreateInput, servicesettingUncheckedCreateInput>
  }

  /**
   * servicesetting createMany
   */
  export type servicesettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many servicesettings.
     */
    data: servicesettingCreateManyInput | servicesettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * servicesetting createManyAndReturn
   */
  export type servicesettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicesetting
     */
    select?: servicesettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many servicesettings.
     */
    data: servicesettingCreateManyInput | servicesettingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesettingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * servicesetting update
   */
  export type servicesettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicesetting
     */
    select?: servicesettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesettingInclude<ExtArgs> | null
    /**
     * The data needed to update a servicesetting.
     */
    data: XOR<servicesettingUpdateInput, servicesettingUncheckedUpdateInput>
    /**
     * Choose, which servicesetting to update.
     */
    where: servicesettingWhereUniqueInput
  }

  /**
   * servicesetting updateMany
   */
  export type servicesettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update servicesettings.
     */
    data: XOR<servicesettingUpdateManyMutationInput, servicesettingUncheckedUpdateManyInput>
    /**
     * Filter which servicesettings to update
     */
    where?: servicesettingWhereInput
  }

  /**
   * servicesetting upsert
   */
  export type servicesettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicesetting
     */
    select?: servicesettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesettingInclude<ExtArgs> | null
    /**
     * The filter to search for the servicesetting to update in case it exists.
     */
    where: servicesettingWhereUniqueInput
    /**
     * In case the servicesetting found by the `where` argument doesn't exist, create a new servicesetting with this data.
     */
    create: XOR<servicesettingCreateInput, servicesettingUncheckedCreateInput>
    /**
     * In case the servicesetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<servicesettingUpdateInput, servicesettingUncheckedUpdateInput>
  }

  /**
   * servicesetting delete
   */
  export type servicesettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicesetting
     */
    select?: servicesettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesettingInclude<ExtArgs> | null
    /**
     * Filter which servicesetting to delete.
     */
    where: servicesettingWhereUniqueInput
  }

  /**
   * servicesetting deleteMany
   */
  export type servicesettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicesettings to delete
     */
    where?: servicesettingWhereInput
  }

  /**
   * servicesetting.insurers
   */
  export type servicesetting$insurersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insurers
     */
    select?: insurersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: insurersInclude<ExtArgs> | null
    where?: insurersWhereInput
  }

  /**
   * servicesetting without action
   */
  export type servicesettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicesetting
     */
    select?: servicesettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesettingInclude<ExtArgs> | null
  }


  /**
   * Model transactionclaim
   */

  export type AggregateTransactionclaim = {
    _count: TransactionclaimCountAggregateOutputType | null
    _avg: TransactionclaimAvgAggregateOutputType | null
    _sum: TransactionclaimSumAggregateOutputType | null
    _min: TransactionclaimMinAggregateOutputType | null
    _max: TransactionclaimMaxAggregateOutputType | null
  }

  export type TransactionclaimAvgAggregateOutputType = {
    id: number | null
    insurerid: number | null
    totalapprovedamount: Decimal | null
    totalexcessamount: Decimal | null
  }

  export type TransactionclaimSumAggregateOutputType = {
    id: number | null
    insurerid: number | null
    totalapprovedamount: Decimal | null
    totalexcessamount: Decimal | null
  }

  export type TransactionclaimMinAggregateOutputType = {
    id: number | null
    insurerid: number | null
    refid: string | null
    transactionno: string | null
    hn: string | null
    vn: string | null
    visitdate: string | null
    accidentdate: string | null
    messageclaim: string | null
    messageth: string | null
    claimno: string | null
    claimstatuscode: string | null
    status_changed_at: Date | null
    occurrenceno: string | null
    totalapprovedamount: Decimal | null
    totalexcessamount: Decimal | null
    isreimbursement: boolean | null
    batchnumber: string | null
    invoicenumber: string | null
    otherinsurer: boolean | null
    furtherclaimid: string | null
    furtherclaimno: string | null
    privatecase: boolean | null
    previoustreatmentdate: string | null
    previoustreatmentdetail: string | null
  }

  export type TransactionclaimMaxAggregateOutputType = {
    id: number | null
    insurerid: number | null
    refid: string | null
    transactionno: string | null
    hn: string | null
    vn: string | null
    visitdate: string | null
    accidentdate: string | null
    messageclaim: string | null
    messageth: string | null
    claimno: string | null
    claimstatuscode: string | null
    status_changed_at: Date | null
    occurrenceno: string | null
    totalapprovedamount: Decimal | null
    totalexcessamount: Decimal | null
    isreimbursement: boolean | null
    batchnumber: string | null
    invoicenumber: string | null
    otherinsurer: boolean | null
    furtherclaimid: string | null
    furtherclaimno: string | null
    privatecase: boolean | null
    previoustreatmentdate: string | null
    previoustreatmentdetail: string | null
  }

  export type TransactionclaimCountAggregateOutputType = {
    id: number
    insurerid: number
    refid: number
    transactionno: number
    hn: number
    vn: number
    visitdate: number
    accidentdate: number
    messageclaim: number
    messageth: number
    claimno: number
    claimstatuscode: number
    status_changed_at: number
    occurrenceno: number
    totalapprovedamount: number
    totalexcessamount: number
    isreimbursement: number
    batchnumber: number
    invoicenumber: number
    otherinsurer: number
    furtherclaimid: number
    furtherclaimno: number
    privatecase: number
    previoustreatmentdate: number
    previoustreatmentdetail: number
    _all: number
  }


  export type TransactionclaimAvgAggregateInputType = {
    id?: true
    insurerid?: true
    totalapprovedamount?: true
    totalexcessamount?: true
  }

  export type TransactionclaimSumAggregateInputType = {
    id?: true
    insurerid?: true
    totalapprovedamount?: true
    totalexcessamount?: true
  }

  export type TransactionclaimMinAggregateInputType = {
    id?: true
    insurerid?: true
    refid?: true
    transactionno?: true
    hn?: true
    vn?: true
    visitdate?: true
    accidentdate?: true
    messageclaim?: true
    messageth?: true
    claimno?: true
    claimstatuscode?: true
    status_changed_at?: true
    occurrenceno?: true
    totalapprovedamount?: true
    totalexcessamount?: true
    isreimbursement?: true
    batchnumber?: true
    invoicenumber?: true
    otherinsurer?: true
    furtherclaimid?: true
    furtherclaimno?: true
    privatecase?: true
    previoustreatmentdate?: true
    previoustreatmentdetail?: true
  }

  export type TransactionclaimMaxAggregateInputType = {
    id?: true
    insurerid?: true
    refid?: true
    transactionno?: true
    hn?: true
    vn?: true
    visitdate?: true
    accidentdate?: true
    messageclaim?: true
    messageth?: true
    claimno?: true
    claimstatuscode?: true
    status_changed_at?: true
    occurrenceno?: true
    totalapprovedamount?: true
    totalexcessamount?: true
    isreimbursement?: true
    batchnumber?: true
    invoicenumber?: true
    otherinsurer?: true
    furtherclaimid?: true
    furtherclaimno?: true
    privatecase?: true
    previoustreatmentdate?: true
    previoustreatmentdetail?: true
  }

  export type TransactionclaimCountAggregateInputType = {
    id?: true
    insurerid?: true
    refid?: true
    transactionno?: true
    hn?: true
    vn?: true
    visitdate?: true
    accidentdate?: true
    messageclaim?: true
    messageth?: true
    claimno?: true
    claimstatuscode?: true
    status_changed_at?: true
    occurrenceno?: true
    totalapprovedamount?: true
    totalexcessamount?: true
    isreimbursement?: true
    batchnumber?: true
    invoicenumber?: true
    otherinsurer?: true
    furtherclaimid?: true
    furtherclaimno?: true
    privatecase?: true
    previoustreatmentdate?: true
    previoustreatmentdetail?: true
    _all?: true
  }

  export type TransactionclaimAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transactionclaim to aggregate.
     */
    where?: transactionclaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactionclaims to fetch.
     */
    orderBy?: transactionclaimOrderByWithRelationInput | transactionclaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transactionclaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactionclaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactionclaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transactionclaims
    **/
    _count?: true | TransactionclaimCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionclaimAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionclaimSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionclaimMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionclaimMaxAggregateInputType
  }

  export type GetTransactionclaimAggregateType<T extends TransactionclaimAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionclaim]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionclaim[P]>
      : GetScalarType<T[P], AggregateTransactionclaim[P]>
  }




  export type transactionclaimGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionclaimWhereInput
    orderBy?: transactionclaimOrderByWithAggregationInput | transactionclaimOrderByWithAggregationInput[]
    by: TransactionclaimScalarFieldEnum[] | TransactionclaimScalarFieldEnum
    having?: transactionclaimScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionclaimCountAggregateInputType | true
    _avg?: TransactionclaimAvgAggregateInputType
    _sum?: TransactionclaimSumAggregateInputType
    _min?: TransactionclaimMinAggregateInputType
    _max?: TransactionclaimMaxAggregateInputType
  }

  export type TransactionclaimGroupByOutputType = {
    id: number
    insurerid: number | null
    refid: string | null
    transactionno: string | null
    hn: string | null
    vn: string | null
    visitdate: string | null
    accidentdate: string | null
    messageclaim: string | null
    messageth: string | null
    claimno: string | null
    claimstatuscode: string | null
    status_changed_at: Date | null
    occurrenceno: string | null
    totalapprovedamount: Decimal | null
    totalexcessamount: Decimal | null
    isreimbursement: boolean | null
    batchnumber: string | null
    invoicenumber: string | null
    otherinsurer: boolean | null
    furtherclaimid: string | null
    furtherclaimno: string | null
    privatecase: boolean | null
    previoustreatmentdate: string | null
    previoustreatmentdetail: string | null
    _count: TransactionclaimCountAggregateOutputType | null
    _avg: TransactionclaimAvgAggregateOutputType | null
    _sum: TransactionclaimSumAggregateOutputType | null
    _min: TransactionclaimMinAggregateOutputType | null
    _max: TransactionclaimMaxAggregateOutputType | null
  }

  type GetTransactionclaimGroupByPayload<T extends transactionclaimGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionclaimGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionclaimGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionclaimGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionclaimGroupByOutputType[P]>
        }
      >
    >


  export type transactionclaimSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insurerid?: boolean
    refid?: boolean
    transactionno?: boolean
    hn?: boolean
    vn?: boolean
    visitdate?: boolean
    accidentdate?: boolean
    messageclaim?: boolean
    messageth?: boolean
    claimno?: boolean
    claimstatuscode?: boolean
    status_changed_at?: boolean
    occurrenceno?: boolean
    totalapprovedamount?: boolean
    totalexcessamount?: boolean
    isreimbursement?: boolean
    batchnumber?: boolean
    invoicenumber?: boolean
    otherinsurer?: boolean
    furtherclaimid?: boolean
    furtherclaimno?: boolean
    privatecase?: boolean
    previoustreatmentdate?: boolean
    previoustreatmentdetail?: boolean
  }, ExtArgs["result"]["transactionclaim"]>

  export type transactionclaimSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insurerid?: boolean
    refid?: boolean
    transactionno?: boolean
    hn?: boolean
    vn?: boolean
    visitdate?: boolean
    accidentdate?: boolean
    messageclaim?: boolean
    messageth?: boolean
    claimno?: boolean
    claimstatuscode?: boolean
    status_changed_at?: boolean
    occurrenceno?: boolean
    totalapprovedamount?: boolean
    totalexcessamount?: boolean
    isreimbursement?: boolean
    batchnumber?: boolean
    invoicenumber?: boolean
    otherinsurer?: boolean
    furtherclaimid?: boolean
    furtherclaimno?: boolean
    privatecase?: boolean
    previoustreatmentdate?: boolean
    previoustreatmentdetail?: boolean
  }, ExtArgs["result"]["transactionclaim"]>

  export type transactionclaimSelectScalar = {
    id?: boolean
    insurerid?: boolean
    refid?: boolean
    transactionno?: boolean
    hn?: boolean
    vn?: boolean
    visitdate?: boolean
    accidentdate?: boolean
    messageclaim?: boolean
    messageth?: boolean
    claimno?: boolean
    claimstatuscode?: boolean
    status_changed_at?: boolean
    occurrenceno?: boolean
    totalapprovedamount?: boolean
    totalexcessamount?: boolean
    isreimbursement?: boolean
    batchnumber?: boolean
    invoicenumber?: boolean
    otherinsurer?: boolean
    furtherclaimid?: boolean
    furtherclaimno?: boolean
    privatecase?: boolean
    previoustreatmentdate?: boolean
    previoustreatmentdetail?: boolean
  }


  export type $transactionclaimPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "transactionclaim"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      insurerid: number | null
      refid: string | null
      transactionno: string | null
      hn: string | null
      vn: string | null
      visitdate: string | null
      accidentdate: string | null
      messageclaim: string | null
      messageth: string | null
      claimno: string | null
      claimstatuscode: string | null
      status_changed_at: Date | null
      occurrenceno: string | null
      totalapprovedamount: Prisma.Decimal | null
      totalexcessamount: Prisma.Decimal | null
      isreimbursement: boolean | null
      batchnumber: string | null
      invoicenumber: string | null
      otherinsurer: boolean | null
      furtherclaimid: string | null
      furtherclaimno: string | null
      privatecase: boolean | null
      previoustreatmentdate: string | null
      previoustreatmentdetail: string | null
    }, ExtArgs["result"]["transactionclaim"]>
    composites: {}
  }

  type transactionclaimGetPayload<S extends boolean | null | undefined | transactionclaimDefaultArgs> = $Result.GetResult<Prisma.$transactionclaimPayload, S>

  type transactionclaimCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<transactionclaimFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransactionclaimCountAggregateInputType | true
    }

  export interface transactionclaimDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['transactionclaim'], meta: { name: 'transactionclaim' } }
    /**
     * Find zero or one Transactionclaim that matches the filter.
     * @param {transactionclaimFindUniqueArgs} args - Arguments to find a Transactionclaim
     * @example
     * // Get one Transactionclaim
     * const transactionclaim = await prisma.transactionclaim.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends transactionclaimFindUniqueArgs>(args: SelectSubset<T, transactionclaimFindUniqueArgs<ExtArgs>>): Prisma__transactionclaimClient<$Result.GetResult<Prisma.$transactionclaimPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Transactionclaim that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {transactionclaimFindUniqueOrThrowArgs} args - Arguments to find a Transactionclaim
     * @example
     * // Get one Transactionclaim
     * const transactionclaim = await prisma.transactionclaim.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends transactionclaimFindUniqueOrThrowArgs>(args: SelectSubset<T, transactionclaimFindUniqueOrThrowArgs<ExtArgs>>): Prisma__transactionclaimClient<$Result.GetResult<Prisma.$transactionclaimPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Transactionclaim that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionclaimFindFirstArgs} args - Arguments to find a Transactionclaim
     * @example
     * // Get one Transactionclaim
     * const transactionclaim = await prisma.transactionclaim.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends transactionclaimFindFirstArgs>(args?: SelectSubset<T, transactionclaimFindFirstArgs<ExtArgs>>): Prisma__transactionclaimClient<$Result.GetResult<Prisma.$transactionclaimPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Transactionclaim that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionclaimFindFirstOrThrowArgs} args - Arguments to find a Transactionclaim
     * @example
     * // Get one Transactionclaim
     * const transactionclaim = await prisma.transactionclaim.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends transactionclaimFindFirstOrThrowArgs>(args?: SelectSubset<T, transactionclaimFindFirstOrThrowArgs<ExtArgs>>): Prisma__transactionclaimClient<$Result.GetResult<Prisma.$transactionclaimPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Transactionclaims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionclaimFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactionclaims
     * const transactionclaims = await prisma.transactionclaim.findMany()
     * 
     * // Get first 10 Transactionclaims
     * const transactionclaims = await prisma.transactionclaim.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionclaimWithIdOnly = await prisma.transactionclaim.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends transactionclaimFindManyArgs>(args?: SelectSubset<T, transactionclaimFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionclaimPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Transactionclaim.
     * @param {transactionclaimCreateArgs} args - Arguments to create a Transactionclaim.
     * @example
     * // Create one Transactionclaim
     * const Transactionclaim = await prisma.transactionclaim.create({
     *   data: {
     *     // ... data to create a Transactionclaim
     *   }
     * })
     * 
     */
    create<T extends transactionclaimCreateArgs>(args: SelectSubset<T, transactionclaimCreateArgs<ExtArgs>>): Prisma__transactionclaimClient<$Result.GetResult<Prisma.$transactionclaimPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Transactionclaims.
     * @param {transactionclaimCreateManyArgs} args - Arguments to create many Transactionclaims.
     * @example
     * // Create many Transactionclaims
     * const transactionclaim = await prisma.transactionclaim.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends transactionclaimCreateManyArgs>(args?: SelectSubset<T, transactionclaimCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactionclaims and returns the data saved in the database.
     * @param {transactionclaimCreateManyAndReturnArgs} args - Arguments to create many Transactionclaims.
     * @example
     * // Create many Transactionclaims
     * const transactionclaim = await prisma.transactionclaim.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactionclaims and only return the `id`
     * const transactionclaimWithIdOnly = await prisma.transactionclaim.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends transactionclaimCreateManyAndReturnArgs>(args?: SelectSubset<T, transactionclaimCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionclaimPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Transactionclaim.
     * @param {transactionclaimDeleteArgs} args - Arguments to delete one Transactionclaim.
     * @example
     * // Delete one Transactionclaim
     * const Transactionclaim = await prisma.transactionclaim.delete({
     *   where: {
     *     // ... filter to delete one Transactionclaim
     *   }
     * })
     * 
     */
    delete<T extends transactionclaimDeleteArgs>(args: SelectSubset<T, transactionclaimDeleteArgs<ExtArgs>>): Prisma__transactionclaimClient<$Result.GetResult<Prisma.$transactionclaimPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Transactionclaim.
     * @param {transactionclaimUpdateArgs} args - Arguments to update one Transactionclaim.
     * @example
     * // Update one Transactionclaim
     * const transactionclaim = await prisma.transactionclaim.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends transactionclaimUpdateArgs>(args: SelectSubset<T, transactionclaimUpdateArgs<ExtArgs>>): Prisma__transactionclaimClient<$Result.GetResult<Prisma.$transactionclaimPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Transactionclaims.
     * @param {transactionclaimDeleteManyArgs} args - Arguments to filter Transactionclaims to delete.
     * @example
     * // Delete a few Transactionclaims
     * const { count } = await prisma.transactionclaim.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends transactionclaimDeleteManyArgs>(args?: SelectSubset<T, transactionclaimDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactionclaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionclaimUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactionclaims
     * const transactionclaim = await prisma.transactionclaim.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends transactionclaimUpdateManyArgs>(args: SelectSubset<T, transactionclaimUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transactionclaim.
     * @param {transactionclaimUpsertArgs} args - Arguments to update or create a Transactionclaim.
     * @example
     * // Update or create a Transactionclaim
     * const transactionclaim = await prisma.transactionclaim.upsert({
     *   create: {
     *     // ... data to create a Transactionclaim
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transactionclaim we want to update
     *   }
     * })
     */
    upsert<T extends transactionclaimUpsertArgs>(args: SelectSubset<T, transactionclaimUpsertArgs<ExtArgs>>): Prisma__transactionclaimClient<$Result.GetResult<Prisma.$transactionclaimPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Transactionclaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionclaimCountArgs} args - Arguments to filter Transactionclaims to count.
     * @example
     * // Count the number of Transactionclaims
     * const count = await prisma.transactionclaim.count({
     *   where: {
     *     // ... the filter for the Transactionclaims we want to count
     *   }
     * })
    **/
    count<T extends transactionclaimCountArgs>(
      args?: Subset<T, transactionclaimCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionclaimCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transactionclaim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionclaimAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionclaimAggregateArgs>(args: Subset<T, TransactionclaimAggregateArgs>): Prisma.PrismaPromise<GetTransactionclaimAggregateType<T>>

    /**
     * Group by Transactionclaim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionclaimGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends transactionclaimGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: transactionclaimGroupByArgs['orderBy'] }
        : { orderBy?: transactionclaimGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, transactionclaimGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionclaimGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the transactionclaim model
   */
  readonly fields: transactionclaimFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for transactionclaim.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__transactionclaimClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the transactionclaim model
   */ 
  interface transactionclaimFieldRefs {
    readonly id: FieldRef<"transactionclaim", 'Int'>
    readonly insurerid: FieldRef<"transactionclaim", 'Int'>
    readonly refid: FieldRef<"transactionclaim", 'String'>
    readonly transactionno: FieldRef<"transactionclaim", 'String'>
    readonly hn: FieldRef<"transactionclaim", 'String'>
    readonly vn: FieldRef<"transactionclaim", 'String'>
    readonly visitdate: FieldRef<"transactionclaim", 'String'>
    readonly accidentdate: FieldRef<"transactionclaim", 'String'>
    readonly messageclaim: FieldRef<"transactionclaim", 'String'>
    readonly messageth: FieldRef<"transactionclaim", 'String'>
    readonly claimno: FieldRef<"transactionclaim", 'String'>
    readonly claimstatuscode: FieldRef<"transactionclaim", 'String'>
    readonly status_changed_at: FieldRef<"transactionclaim", 'DateTime'>
    readonly occurrenceno: FieldRef<"transactionclaim", 'String'>
    readonly totalapprovedamount: FieldRef<"transactionclaim", 'Decimal'>
    readonly totalexcessamount: FieldRef<"transactionclaim", 'Decimal'>
    readonly isreimbursement: FieldRef<"transactionclaim", 'Boolean'>
    readonly batchnumber: FieldRef<"transactionclaim", 'String'>
    readonly invoicenumber: FieldRef<"transactionclaim", 'String'>
    readonly otherinsurer: FieldRef<"transactionclaim", 'Boolean'>
    readonly furtherclaimid: FieldRef<"transactionclaim", 'String'>
    readonly furtherclaimno: FieldRef<"transactionclaim", 'String'>
    readonly privatecase: FieldRef<"transactionclaim", 'Boolean'>
    readonly previoustreatmentdate: FieldRef<"transactionclaim", 'String'>
    readonly previoustreatmentdetail: FieldRef<"transactionclaim", 'String'>
  }
    

  // Custom InputTypes
  /**
   * transactionclaim findUnique
   */
  export type transactionclaimFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionclaim
     */
    select?: transactionclaimSelect<ExtArgs> | null
    /**
     * Filter, which transactionclaim to fetch.
     */
    where: transactionclaimWhereUniqueInput
  }

  /**
   * transactionclaim findUniqueOrThrow
   */
  export type transactionclaimFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionclaim
     */
    select?: transactionclaimSelect<ExtArgs> | null
    /**
     * Filter, which transactionclaim to fetch.
     */
    where: transactionclaimWhereUniqueInput
  }

  /**
   * transactionclaim findFirst
   */
  export type transactionclaimFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionclaim
     */
    select?: transactionclaimSelect<ExtArgs> | null
    /**
     * Filter, which transactionclaim to fetch.
     */
    where?: transactionclaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactionclaims to fetch.
     */
    orderBy?: transactionclaimOrderByWithRelationInput | transactionclaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactionclaims.
     */
    cursor?: transactionclaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactionclaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactionclaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactionclaims.
     */
    distinct?: TransactionclaimScalarFieldEnum | TransactionclaimScalarFieldEnum[]
  }

  /**
   * transactionclaim findFirstOrThrow
   */
  export type transactionclaimFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionclaim
     */
    select?: transactionclaimSelect<ExtArgs> | null
    /**
     * Filter, which transactionclaim to fetch.
     */
    where?: transactionclaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactionclaims to fetch.
     */
    orderBy?: transactionclaimOrderByWithRelationInput | transactionclaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactionclaims.
     */
    cursor?: transactionclaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactionclaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactionclaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactionclaims.
     */
    distinct?: TransactionclaimScalarFieldEnum | TransactionclaimScalarFieldEnum[]
  }

  /**
   * transactionclaim findMany
   */
  export type transactionclaimFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionclaim
     */
    select?: transactionclaimSelect<ExtArgs> | null
    /**
     * Filter, which transactionclaims to fetch.
     */
    where?: transactionclaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactionclaims to fetch.
     */
    orderBy?: transactionclaimOrderByWithRelationInput | transactionclaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transactionclaims.
     */
    cursor?: transactionclaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactionclaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactionclaims.
     */
    skip?: number
    distinct?: TransactionclaimScalarFieldEnum | TransactionclaimScalarFieldEnum[]
  }

  /**
   * transactionclaim create
   */
  export type transactionclaimCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionclaim
     */
    select?: transactionclaimSelect<ExtArgs> | null
    /**
     * The data needed to create a transactionclaim.
     */
    data?: XOR<transactionclaimCreateInput, transactionclaimUncheckedCreateInput>
  }

  /**
   * transactionclaim createMany
   */
  export type transactionclaimCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many transactionclaims.
     */
    data: transactionclaimCreateManyInput | transactionclaimCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transactionclaim createManyAndReturn
   */
  export type transactionclaimCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionclaim
     */
    select?: transactionclaimSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many transactionclaims.
     */
    data: transactionclaimCreateManyInput | transactionclaimCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transactionclaim update
   */
  export type transactionclaimUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionclaim
     */
    select?: transactionclaimSelect<ExtArgs> | null
    /**
     * The data needed to update a transactionclaim.
     */
    data: XOR<transactionclaimUpdateInput, transactionclaimUncheckedUpdateInput>
    /**
     * Choose, which transactionclaim to update.
     */
    where: transactionclaimWhereUniqueInput
  }

  /**
   * transactionclaim updateMany
   */
  export type transactionclaimUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update transactionclaims.
     */
    data: XOR<transactionclaimUpdateManyMutationInput, transactionclaimUncheckedUpdateManyInput>
    /**
     * Filter which transactionclaims to update
     */
    where?: transactionclaimWhereInput
  }

  /**
   * transactionclaim upsert
   */
  export type transactionclaimUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionclaim
     */
    select?: transactionclaimSelect<ExtArgs> | null
    /**
     * The filter to search for the transactionclaim to update in case it exists.
     */
    where: transactionclaimWhereUniqueInput
    /**
     * In case the transactionclaim found by the `where` argument doesn't exist, create a new transactionclaim with this data.
     */
    create: XOR<transactionclaimCreateInput, transactionclaimUncheckedCreateInput>
    /**
     * In case the transactionclaim was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transactionclaimUpdateInput, transactionclaimUncheckedUpdateInput>
  }

  /**
   * transactionclaim delete
   */
  export type transactionclaimDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionclaim
     */
    select?: transactionclaimSelect<ExtArgs> | null
    /**
     * Filter which transactionclaim to delete.
     */
    where: transactionclaimWhereUniqueInput
  }

  /**
   * transactionclaim deleteMany
   */
  export type transactionclaimDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transactionclaims to delete
     */
    where?: transactionclaimWhereInput
  }

  /**
   * transactionclaim without action
   */
  export type transactionclaimDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionclaim
     */
    select?: transactionclaimSelect<ExtArgs> | null
  }


  /**
   * Model transactionclaimstatus
   */

  export type AggregateTransactionclaimstatus = {
    _count: TransactionclaimstatusCountAggregateOutputType | null
    _avg: TransactionclaimstatusAvgAggregateOutputType | null
    _sum: TransactionclaimstatusSumAggregateOutputType | null
    _min: TransactionclaimstatusMinAggregateOutputType | null
    _max: TransactionclaimstatusMaxAggregateOutputType | null
  }

  export type TransactionclaimstatusAvgAggregateOutputType = {
    id: number | null
    insurerid: number | null
  }

  export type TransactionclaimstatusSumAggregateOutputType = {
    id: number | null
    insurerid: number | null
  }

  export type TransactionclaimstatusMinAggregateOutputType = {
    id: number | null
    insurerid: number | null
    refid: string | null
    transactionno: string | null
    hn: string | null
    vn: string | null
    batchnumber: string | null
    claimno: string | null
    invoicenumber: string | null
    status_changed_at: Date | null
    note: string | null
    totalapproveamount: string | null
    paymentdate: string | null
    claimstatuscode: string | null
  }

  export type TransactionclaimstatusMaxAggregateOutputType = {
    id: number | null
    insurerid: number | null
    refid: string | null
    transactionno: string | null
    hn: string | null
    vn: string | null
    batchnumber: string | null
    claimno: string | null
    invoicenumber: string | null
    status_changed_at: Date | null
    note: string | null
    totalapproveamount: string | null
    paymentdate: string | null
    claimstatuscode: string | null
  }

  export type TransactionclaimstatusCountAggregateOutputType = {
    id: number
    insurerid: number
    refid: number
    transactionno: number
    hn: number
    vn: number
    batchnumber: number
    claimno: number
    invoicenumber: number
    status_changed_at: number
    note: number
    totalapproveamount: number
    paymentdate: number
    claimstatuscode: number
    _all: number
  }


  export type TransactionclaimstatusAvgAggregateInputType = {
    id?: true
    insurerid?: true
  }

  export type TransactionclaimstatusSumAggregateInputType = {
    id?: true
    insurerid?: true
  }

  export type TransactionclaimstatusMinAggregateInputType = {
    id?: true
    insurerid?: true
    refid?: true
    transactionno?: true
    hn?: true
    vn?: true
    batchnumber?: true
    claimno?: true
    invoicenumber?: true
    status_changed_at?: true
    note?: true
    totalapproveamount?: true
    paymentdate?: true
    claimstatuscode?: true
  }

  export type TransactionclaimstatusMaxAggregateInputType = {
    id?: true
    insurerid?: true
    refid?: true
    transactionno?: true
    hn?: true
    vn?: true
    batchnumber?: true
    claimno?: true
    invoicenumber?: true
    status_changed_at?: true
    note?: true
    totalapproveamount?: true
    paymentdate?: true
    claimstatuscode?: true
  }

  export type TransactionclaimstatusCountAggregateInputType = {
    id?: true
    insurerid?: true
    refid?: true
    transactionno?: true
    hn?: true
    vn?: true
    batchnumber?: true
    claimno?: true
    invoicenumber?: true
    status_changed_at?: true
    note?: true
    totalapproveamount?: true
    paymentdate?: true
    claimstatuscode?: true
    _all?: true
  }

  export type TransactionclaimstatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transactionclaimstatus to aggregate.
     */
    where?: transactionclaimstatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactionclaimstatuses to fetch.
     */
    orderBy?: transactionclaimstatusOrderByWithRelationInput | transactionclaimstatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transactionclaimstatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactionclaimstatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactionclaimstatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transactionclaimstatuses
    **/
    _count?: true | TransactionclaimstatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionclaimstatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionclaimstatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionclaimstatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionclaimstatusMaxAggregateInputType
  }

  export type GetTransactionclaimstatusAggregateType<T extends TransactionclaimstatusAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionclaimstatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionclaimstatus[P]>
      : GetScalarType<T[P], AggregateTransactionclaimstatus[P]>
  }




  export type transactionclaimstatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionclaimstatusWhereInput
    orderBy?: transactionclaimstatusOrderByWithAggregationInput | transactionclaimstatusOrderByWithAggregationInput[]
    by: TransactionclaimstatusScalarFieldEnum[] | TransactionclaimstatusScalarFieldEnum
    having?: transactionclaimstatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionclaimstatusCountAggregateInputType | true
    _avg?: TransactionclaimstatusAvgAggregateInputType
    _sum?: TransactionclaimstatusSumAggregateInputType
    _min?: TransactionclaimstatusMinAggregateInputType
    _max?: TransactionclaimstatusMaxAggregateInputType
  }

  export type TransactionclaimstatusGroupByOutputType = {
    id: number
    insurerid: number | null
    refid: string | null
    transactionno: string | null
    hn: string | null
    vn: string | null
    batchnumber: string | null
    claimno: string | null
    invoicenumber: string | null
    status_changed_at: Date | null
    note: string | null
    totalapproveamount: string | null
    paymentdate: string | null
    claimstatuscode: string | null
    _count: TransactionclaimstatusCountAggregateOutputType | null
    _avg: TransactionclaimstatusAvgAggregateOutputType | null
    _sum: TransactionclaimstatusSumAggregateOutputType | null
    _min: TransactionclaimstatusMinAggregateOutputType | null
    _max: TransactionclaimstatusMaxAggregateOutputType | null
  }

  type GetTransactionclaimstatusGroupByPayload<T extends transactionclaimstatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionclaimstatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionclaimstatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionclaimstatusGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionclaimstatusGroupByOutputType[P]>
        }
      >
    >


  export type transactionclaimstatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insurerid?: boolean
    refid?: boolean
    transactionno?: boolean
    hn?: boolean
    vn?: boolean
    batchnumber?: boolean
    claimno?: boolean
    invoicenumber?: boolean
    status_changed_at?: boolean
    note?: boolean
    totalapproveamount?: boolean
    paymentdate?: boolean
    claimstatuscode?: boolean
    claimstatus?: boolean | transactionclaimstatus$claimstatusArgs<ExtArgs>
  }, ExtArgs["result"]["transactionclaimstatus"]>

  export type transactionclaimstatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insurerid?: boolean
    refid?: boolean
    transactionno?: boolean
    hn?: boolean
    vn?: boolean
    batchnumber?: boolean
    claimno?: boolean
    invoicenumber?: boolean
    status_changed_at?: boolean
    note?: boolean
    totalapproveamount?: boolean
    paymentdate?: boolean
    claimstatuscode?: boolean
    claimstatus?: boolean | transactionclaimstatus$claimstatusArgs<ExtArgs>
  }, ExtArgs["result"]["transactionclaimstatus"]>

  export type transactionclaimstatusSelectScalar = {
    id?: boolean
    insurerid?: boolean
    refid?: boolean
    transactionno?: boolean
    hn?: boolean
    vn?: boolean
    batchnumber?: boolean
    claimno?: boolean
    invoicenumber?: boolean
    status_changed_at?: boolean
    note?: boolean
    totalapproveamount?: boolean
    paymentdate?: boolean
    claimstatuscode?: boolean
  }

  export type transactionclaimstatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claimstatus?: boolean | transactionclaimstatus$claimstatusArgs<ExtArgs>
  }
  export type transactionclaimstatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claimstatus?: boolean | transactionclaimstatus$claimstatusArgs<ExtArgs>
  }

  export type $transactionclaimstatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "transactionclaimstatus"
    objects: {
      claimstatus: Prisma.$claimstatusPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      insurerid: number | null
      refid: string | null
      transactionno: string | null
      hn: string | null
      vn: string | null
      batchnumber: string | null
      claimno: string | null
      invoicenumber: string | null
      status_changed_at: Date | null
      note: string | null
      totalapproveamount: string | null
      paymentdate: string | null
      claimstatuscode: string | null
    }, ExtArgs["result"]["transactionclaimstatus"]>
    composites: {}
  }

  type transactionclaimstatusGetPayload<S extends boolean | null | undefined | transactionclaimstatusDefaultArgs> = $Result.GetResult<Prisma.$transactionclaimstatusPayload, S>

  type transactionclaimstatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<transactionclaimstatusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransactionclaimstatusCountAggregateInputType | true
    }

  export interface transactionclaimstatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['transactionclaimstatus'], meta: { name: 'transactionclaimstatus' } }
    /**
     * Find zero or one Transactionclaimstatus that matches the filter.
     * @param {transactionclaimstatusFindUniqueArgs} args - Arguments to find a Transactionclaimstatus
     * @example
     * // Get one Transactionclaimstatus
     * const transactionclaimstatus = await prisma.transactionclaimstatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends transactionclaimstatusFindUniqueArgs>(args: SelectSubset<T, transactionclaimstatusFindUniqueArgs<ExtArgs>>): Prisma__transactionclaimstatusClient<$Result.GetResult<Prisma.$transactionclaimstatusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Transactionclaimstatus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {transactionclaimstatusFindUniqueOrThrowArgs} args - Arguments to find a Transactionclaimstatus
     * @example
     * // Get one Transactionclaimstatus
     * const transactionclaimstatus = await prisma.transactionclaimstatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends transactionclaimstatusFindUniqueOrThrowArgs>(args: SelectSubset<T, transactionclaimstatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__transactionclaimstatusClient<$Result.GetResult<Prisma.$transactionclaimstatusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Transactionclaimstatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionclaimstatusFindFirstArgs} args - Arguments to find a Transactionclaimstatus
     * @example
     * // Get one Transactionclaimstatus
     * const transactionclaimstatus = await prisma.transactionclaimstatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends transactionclaimstatusFindFirstArgs>(args?: SelectSubset<T, transactionclaimstatusFindFirstArgs<ExtArgs>>): Prisma__transactionclaimstatusClient<$Result.GetResult<Prisma.$transactionclaimstatusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Transactionclaimstatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionclaimstatusFindFirstOrThrowArgs} args - Arguments to find a Transactionclaimstatus
     * @example
     * // Get one Transactionclaimstatus
     * const transactionclaimstatus = await prisma.transactionclaimstatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends transactionclaimstatusFindFirstOrThrowArgs>(args?: SelectSubset<T, transactionclaimstatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__transactionclaimstatusClient<$Result.GetResult<Prisma.$transactionclaimstatusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Transactionclaimstatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionclaimstatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactionclaimstatuses
     * const transactionclaimstatuses = await prisma.transactionclaimstatus.findMany()
     * 
     * // Get first 10 Transactionclaimstatuses
     * const transactionclaimstatuses = await prisma.transactionclaimstatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionclaimstatusWithIdOnly = await prisma.transactionclaimstatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends transactionclaimstatusFindManyArgs>(args?: SelectSubset<T, transactionclaimstatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionclaimstatusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Transactionclaimstatus.
     * @param {transactionclaimstatusCreateArgs} args - Arguments to create a Transactionclaimstatus.
     * @example
     * // Create one Transactionclaimstatus
     * const Transactionclaimstatus = await prisma.transactionclaimstatus.create({
     *   data: {
     *     // ... data to create a Transactionclaimstatus
     *   }
     * })
     * 
     */
    create<T extends transactionclaimstatusCreateArgs>(args: SelectSubset<T, transactionclaimstatusCreateArgs<ExtArgs>>): Prisma__transactionclaimstatusClient<$Result.GetResult<Prisma.$transactionclaimstatusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Transactionclaimstatuses.
     * @param {transactionclaimstatusCreateManyArgs} args - Arguments to create many Transactionclaimstatuses.
     * @example
     * // Create many Transactionclaimstatuses
     * const transactionclaimstatus = await prisma.transactionclaimstatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends transactionclaimstatusCreateManyArgs>(args?: SelectSubset<T, transactionclaimstatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactionclaimstatuses and returns the data saved in the database.
     * @param {transactionclaimstatusCreateManyAndReturnArgs} args - Arguments to create many Transactionclaimstatuses.
     * @example
     * // Create many Transactionclaimstatuses
     * const transactionclaimstatus = await prisma.transactionclaimstatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactionclaimstatuses and only return the `id`
     * const transactionclaimstatusWithIdOnly = await prisma.transactionclaimstatus.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends transactionclaimstatusCreateManyAndReturnArgs>(args?: SelectSubset<T, transactionclaimstatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionclaimstatusPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Transactionclaimstatus.
     * @param {transactionclaimstatusDeleteArgs} args - Arguments to delete one Transactionclaimstatus.
     * @example
     * // Delete one Transactionclaimstatus
     * const Transactionclaimstatus = await prisma.transactionclaimstatus.delete({
     *   where: {
     *     // ... filter to delete one Transactionclaimstatus
     *   }
     * })
     * 
     */
    delete<T extends transactionclaimstatusDeleteArgs>(args: SelectSubset<T, transactionclaimstatusDeleteArgs<ExtArgs>>): Prisma__transactionclaimstatusClient<$Result.GetResult<Prisma.$transactionclaimstatusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Transactionclaimstatus.
     * @param {transactionclaimstatusUpdateArgs} args - Arguments to update one Transactionclaimstatus.
     * @example
     * // Update one Transactionclaimstatus
     * const transactionclaimstatus = await prisma.transactionclaimstatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends transactionclaimstatusUpdateArgs>(args: SelectSubset<T, transactionclaimstatusUpdateArgs<ExtArgs>>): Prisma__transactionclaimstatusClient<$Result.GetResult<Prisma.$transactionclaimstatusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Transactionclaimstatuses.
     * @param {transactionclaimstatusDeleteManyArgs} args - Arguments to filter Transactionclaimstatuses to delete.
     * @example
     * // Delete a few Transactionclaimstatuses
     * const { count } = await prisma.transactionclaimstatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends transactionclaimstatusDeleteManyArgs>(args?: SelectSubset<T, transactionclaimstatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactionclaimstatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionclaimstatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactionclaimstatuses
     * const transactionclaimstatus = await prisma.transactionclaimstatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends transactionclaimstatusUpdateManyArgs>(args: SelectSubset<T, transactionclaimstatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transactionclaimstatus.
     * @param {transactionclaimstatusUpsertArgs} args - Arguments to update or create a Transactionclaimstatus.
     * @example
     * // Update or create a Transactionclaimstatus
     * const transactionclaimstatus = await prisma.transactionclaimstatus.upsert({
     *   create: {
     *     // ... data to create a Transactionclaimstatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transactionclaimstatus we want to update
     *   }
     * })
     */
    upsert<T extends transactionclaimstatusUpsertArgs>(args: SelectSubset<T, transactionclaimstatusUpsertArgs<ExtArgs>>): Prisma__transactionclaimstatusClient<$Result.GetResult<Prisma.$transactionclaimstatusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Transactionclaimstatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionclaimstatusCountArgs} args - Arguments to filter Transactionclaimstatuses to count.
     * @example
     * // Count the number of Transactionclaimstatuses
     * const count = await prisma.transactionclaimstatus.count({
     *   where: {
     *     // ... the filter for the Transactionclaimstatuses we want to count
     *   }
     * })
    **/
    count<T extends transactionclaimstatusCountArgs>(
      args?: Subset<T, transactionclaimstatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionclaimstatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transactionclaimstatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionclaimstatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionclaimstatusAggregateArgs>(args: Subset<T, TransactionclaimstatusAggregateArgs>): Prisma.PrismaPromise<GetTransactionclaimstatusAggregateType<T>>

    /**
     * Group by Transactionclaimstatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionclaimstatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends transactionclaimstatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: transactionclaimstatusGroupByArgs['orderBy'] }
        : { orderBy?: transactionclaimstatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, transactionclaimstatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionclaimstatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the transactionclaimstatus model
   */
  readonly fields: transactionclaimstatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for transactionclaimstatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__transactionclaimstatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    claimstatus<T extends transactionclaimstatus$claimstatusArgs<ExtArgs> = {}>(args?: Subset<T, transactionclaimstatus$claimstatusArgs<ExtArgs>>): Prisma__claimstatusClient<$Result.GetResult<Prisma.$claimstatusPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the transactionclaimstatus model
   */ 
  interface transactionclaimstatusFieldRefs {
    readonly id: FieldRef<"transactionclaimstatus", 'Int'>
    readonly insurerid: FieldRef<"transactionclaimstatus", 'Int'>
    readonly refid: FieldRef<"transactionclaimstatus", 'String'>
    readonly transactionno: FieldRef<"transactionclaimstatus", 'String'>
    readonly hn: FieldRef<"transactionclaimstatus", 'String'>
    readonly vn: FieldRef<"transactionclaimstatus", 'String'>
    readonly batchnumber: FieldRef<"transactionclaimstatus", 'String'>
    readonly claimno: FieldRef<"transactionclaimstatus", 'String'>
    readonly invoicenumber: FieldRef<"transactionclaimstatus", 'String'>
    readonly status_changed_at: FieldRef<"transactionclaimstatus", 'DateTime'>
    readonly note: FieldRef<"transactionclaimstatus", 'String'>
    readonly totalapproveamount: FieldRef<"transactionclaimstatus", 'String'>
    readonly paymentdate: FieldRef<"transactionclaimstatus", 'String'>
    readonly claimstatuscode: FieldRef<"transactionclaimstatus", 'String'>
  }
    

  // Custom InputTypes
  /**
   * transactionclaimstatus findUnique
   */
  export type transactionclaimstatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionclaimstatus
     */
    select?: transactionclaimstatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionclaimstatusInclude<ExtArgs> | null
    /**
     * Filter, which transactionclaimstatus to fetch.
     */
    where: transactionclaimstatusWhereUniqueInput
  }

  /**
   * transactionclaimstatus findUniqueOrThrow
   */
  export type transactionclaimstatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionclaimstatus
     */
    select?: transactionclaimstatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionclaimstatusInclude<ExtArgs> | null
    /**
     * Filter, which transactionclaimstatus to fetch.
     */
    where: transactionclaimstatusWhereUniqueInput
  }

  /**
   * transactionclaimstatus findFirst
   */
  export type transactionclaimstatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionclaimstatus
     */
    select?: transactionclaimstatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionclaimstatusInclude<ExtArgs> | null
    /**
     * Filter, which transactionclaimstatus to fetch.
     */
    where?: transactionclaimstatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactionclaimstatuses to fetch.
     */
    orderBy?: transactionclaimstatusOrderByWithRelationInput | transactionclaimstatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactionclaimstatuses.
     */
    cursor?: transactionclaimstatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactionclaimstatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactionclaimstatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactionclaimstatuses.
     */
    distinct?: TransactionclaimstatusScalarFieldEnum | TransactionclaimstatusScalarFieldEnum[]
  }

  /**
   * transactionclaimstatus findFirstOrThrow
   */
  export type transactionclaimstatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionclaimstatus
     */
    select?: transactionclaimstatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionclaimstatusInclude<ExtArgs> | null
    /**
     * Filter, which transactionclaimstatus to fetch.
     */
    where?: transactionclaimstatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactionclaimstatuses to fetch.
     */
    orderBy?: transactionclaimstatusOrderByWithRelationInput | transactionclaimstatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactionclaimstatuses.
     */
    cursor?: transactionclaimstatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactionclaimstatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactionclaimstatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactionclaimstatuses.
     */
    distinct?: TransactionclaimstatusScalarFieldEnum | TransactionclaimstatusScalarFieldEnum[]
  }

  /**
   * transactionclaimstatus findMany
   */
  export type transactionclaimstatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionclaimstatus
     */
    select?: transactionclaimstatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionclaimstatusInclude<ExtArgs> | null
    /**
     * Filter, which transactionclaimstatuses to fetch.
     */
    where?: transactionclaimstatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactionclaimstatuses to fetch.
     */
    orderBy?: transactionclaimstatusOrderByWithRelationInput | transactionclaimstatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transactionclaimstatuses.
     */
    cursor?: transactionclaimstatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactionclaimstatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactionclaimstatuses.
     */
    skip?: number
    distinct?: TransactionclaimstatusScalarFieldEnum | TransactionclaimstatusScalarFieldEnum[]
  }

  /**
   * transactionclaimstatus create
   */
  export type transactionclaimstatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionclaimstatus
     */
    select?: transactionclaimstatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionclaimstatusInclude<ExtArgs> | null
    /**
     * The data needed to create a transactionclaimstatus.
     */
    data?: XOR<transactionclaimstatusCreateInput, transactionclaimstatusUncheckedCreateInput>
  }

  /**
   * transactionclaimstatus createMany
   */
  export type transactionclaimstatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many transactionclaimstatuses.
     */
    data: transactionclaimstatusCreateManyInput | transactionclaimstatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transactionclaimstatus createManyAndReturn
   */
  export type transactionclaimstatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionclaimstatus
     */
    select?: transactionclaimstatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many transactionclaimstatuses.
     */
    data: transactionclaimstatusCreateManyInput | transactionclaimstatusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionclaimstatusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * transactionclaimstatus update
   */
  export type transactionclaimstatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionclaimstatus
     */
    select?: transactionclaimstatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionclaimstatusInclude<ExtArgs> | null
    /**
     * The data needed to update a transactionclaimstatus.
     */
    data: XOR<transactionclaimstatusUpdateInput, transactionclaimstatusUncheckedUpdateInput>
    /**
     * Choose, which transactionclaimstatus to update.
     */
    where: transactionclaimstatusWhereUniqueInput
  }

  /**
   * transactionclaimstatus updateMany
   */
  export type transactionclaimstatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update transactionclaimstatuses.
     */
    data: XOR<transactionclaimstatusUpdateManyMutationInput, transactionclaimstatusUncheckedUpdateManyInput>
    /**
     * Filter which transactionclaimstatuses to update
     */
    where?: transactionclaimstatusWhereInput
  }

  /**
   * transactionclaimstatus upsert
   */
  export type transactionclaimstatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionclaimstatus
     */
    select?: transactionclaimstatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionclaimstatusInclude<ExtArgs> | null
    /**
     * The filter to search for the transactionclaimstatus to update in case it exists.
     */
    where: transactionclaimstatusWhereUniqueInput
    /**
     * In case the transactionclaimstatus found by the `where` argument doesn't exist, create a new transactionclaimstatus with this data.
     */
    create: XOR<transactionclaimstatusCreateInput, transactionclaimstatusUncheckedCreateInput>
    /**
     * In case the transactionclaimstatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transactionclaimstatusUpdateInput, transactionclaimstatusUncheckedUpdateInput>
  }

  /**
   * transactionclaimstatus delete
   */
  export type transactionclaimstatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionclaimstatus
     */
    select?: transactionclaimstatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionclaimstatusInclude<ExtArgs> | null
    /**
     * Filter which transactionclaimstatus to delete.
     */
    where: transactionclaimstatusWhereUniqueInput
  }

  /**
   * transactionclaimstatus deleteMany
   */
  export type transactionclaimstatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transactionclaimstatuses to delete
     */
    where?: transactionclaimstatusWhereInput
  }

  /**
   * transactionclaimstatus.claimstatus
   */
  export type transactionclaimstatus$claimstatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the claimstatus
     */
    select?: claimstatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: claimstatusInclude<ExtArgs> | null
    where?: claimstatusWhereInput
  }

  /**
   * transactionclaimstatus without action
   */
  export type transactionclaimstatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionclaimstatus
     */
    select?: transactionclaimstatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionclaimstatusInclude<ExtArgs> | null
  }


  /**
   * Model accidenttransactions
   */

  export type AggregateAccidenttransactions = {
    _count: AccidenttransactionsCountAggregateOutputType | null
    _avg: AccidenttransactionsAvgAggregateOutputType | null
    _sum: AccidenttransactionsSumAggregateOutputType | null
    _min: AccidenttransactionsMinAggregateOutputType | null
    _max: AccidenttransactionsMaxAggregateOutputType | null
  }

  export type AccidenttransactionsAvgAggregateOutputType = {
    id: number | null
    insurerid: number | null
  }

  export type AccidenttransactionsSumAggregateOutputType = {
    id: number | null
    insurerid: number | null
  }

  export type AccidenttransactionsMinAggregateOutputType = {
    id: number | null
    insurerid: number | null
    refid: string | null
    transactionno: string | null
    hn: string | null
    vn: string | null
    accidentplace: string | null
    accidentdate: string | null
  }

  export type AccidenttransactionsMaxAggregateOutputType = {
    id: number | null
    insurerid: number | null
    refid: string | null
    transactionno: string | null
    hn: string | null
    vn: string | null
    accidentplace: string | null
    accidentdate: string | null
  }

  export type AccidenttransactionsCountAggregateOutputType = {
    id: number
    insurerid: number
    refid: number
    transactionno: number
    hn: number
    vn: number
    accidentplace: number
    accidentdate: number
    _all: number
  }


  export type AccidenttransactionsAvgAggregateInputType = {
    id?: true
    insurerid?: true
  }

  export type AccidenttransactionsSumAggregateInputType = {
    id?: true
    insurerid?: true
  }

  export type AccidenttransactionsMinAggregateInputType = {
    id?: true
    insurerid?: true
    refid?: true
    transactionno?: true
    hn?: true
    vn?: true
    accidentplace?: true
    accidentdate?: true
  }

  export type AccidenttransactionsMaxAggregateInputType = {
    id?: true
    insurerid?: true
    refid?: true
    transactionno?: true
    hn?: true
    vn?: true
    accidentplace?: true
    accidentdate?: true
  }

  export type AccidenttransactionsCountAggregateInputType = {
    id?: true
    insurerid?: true
    refid?: true
    transactionno?: true
    hn?: true
    vn?: true
    accidentplace?: true
    accidentdate?: true
    _all?: true
  }

  export type AccidenttransactionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accidenttransactions to aggregate.
     */
    where?: accidenttransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accidenttransactions to fetch.
     */
    orderBy?: accidenttransactionsOrderByWithRelationInput | accidenttransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: accidenttransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accidenttransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accidenttransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned accidenttransactions
    **/
    _count?: true | AccidenttransactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccidenttransactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccidenttransactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccidenttransactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccidenttransactionsMaxAggregateInputType
  }

  export type GetAccidenttransactionsAggregateType<T extends AccidenttransactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateAccidenttransactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccidenttransactions[P]>
      : GetScalarType<T[P], AggregateAccidenttransactions[P]>
  }




  export type accidenttransactionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: accidenttransactionsWhereInput
    orderBy?: accidenttransactionsOrderByWithAggregationInput | accidenttransactionsOrderByWithAggregationInput[]
    by: AccidenttransactionsScalarFieldEnum[] | AccidenttransactionsScalarFieldEnum
    having?: accidenttransactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccidenttransactionsCountAggregateInputType | true
    _avg?: AccidenttransactionsAvgAggregateInputType
    _sum?: AccidenttransactionsSumAggregateInputType
    _min?: AccidenttransactionsMinAggregateInputType
    _max?: AccidenttransactionsMaxAggregateInputType
  }

  export type AccidenttransactionsGroupByOutputType = {
    id: number
    insurerid: number | null
    refid: string | null
    transactionno: string | null
    hn: string | null
    vn: string | null
    accidentplace: string | null
    accidentdate: string | null
    _count: AccidenttransactionsCountAggregateOutputType | null
    _avg: AccidenttransactionsAvgAggregateOutputType | null
    _sum: AccidenttransactionsSumAggregateOutputType | null
    _min: AccidenttransactionsMinAggregateOutputType | null
    _max: AccidenttransactionsMaxAggregateOutputType | null
  }

  type GetAccidenttransactionsGroupByPayload<T extends accidenttransactionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccidenttransactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccidenttransactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccidenttransactionsGroupByOutputType[P]>
            : GetScalarType<T[P], AccidenttransactionsGroupByOutputType[P]>
        }
      >
    >


  export type accidenttransactionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insurerid?: boolean
    refid?: boolean
    transactionno?: boolean
    hn?: boolean
    vn?: boolean
    accidentplace?: boolean
    accidentdate?: boolean
    insurers?: boolean | accidenttransactions$insurersArgs<ExtArgs>
    causeofinjurydetail?: boolean | accidenttransactions$causeofinjurydetailArgs<ExtArgs>
    injurydetail?: boolean | accidenttransactions$injurydetailArgs<ExtArgs>
    _count?: boolean | AccidenttransactionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accidenttransactions"]>

  export type accidenttransactionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insurerid?: boolean
    refid?: boolean
    transactionno?: boolean
    hn?: boolean
    vn?: boolean
    accidentplace?: boolean
    accidentdate?: boolean
    insurers?: boolean | accidenttransactions$insurersArgs<ExtArgs>
  }, ExtArgs["result"]["accidenttransactions"]>

  export type accidenttransactionsSelectScalar = {
    id?: boolean
    insurerid?: boolean
    refid?: boolean
    transactionno?: boolean
    hn?: boolean
    vn?: boolean
    accidentplace?: boolean
    accidentdate?: boolean
  }

  export type accidenttransactionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurers?: boolean | accidenttransactions$insurersArgs<ExtArgs>
    causeofinjurydetail?: boolean | accidenttransactions$causeofinjurydetailArgs<ExtArgs>
    injurydetail?: boolean | accidenttransactions$injurydetailArgs<ExtArgs>
    _count?: boolean | AccidenttransactionsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type accidenttransactionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurers?: boolean | accidenttransactions$insurersArgs<ExtArgs>
  }

  export type $accidenttransactionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "accidenttransactions"
    objects: {
      insurers: Prisma.$insurersPayload<ExtArgs> | null
      causeofinjurydetail: Prisma.$causeofinjurydetailPayload<ExtArgs>[]
      injurydetail: Prisma.$injurydetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      insurerid: number | null
      refid: string | null
      transactionno: string | null
      hn: string | null
      vn: string | null
      accidentplace: string | null
      accidentdate: string | null
    }, ExtArgs["result"]["accidenttransactions"]>
    composites: {}
  }

  type accidenttransactionsGetPayload<S extends boolean | null | undefined | accidenttransactionsDefaultArgs> = $Result.GetResult<Prisma.$accidenttransactionsPayload, S>

  type accidenttransactionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<accidenttransactionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccidenttransactionsCountAggregateInputType | true
    }

  export interface accidenttransactionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['accidenttransactions'], meta: { name: 'accidenttransactions' } }
    /**
     * Find zero or one Accidenttransactions that matches the filter.
     * @param {accidenttransactionsFindUniqueArgs} args - Arguments to find a Accidenttransactions
     * @example
     * // Get one Accidenttransactions
     * const accidenttransactions = await prisma.accidenttransactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends accidenttransactionsFindUniqueArgs>(args: SelectSubset<T, accidenttransactionsFindUniqueArgs<ExtArgs>>): Prisma__accidenttransactionsClient<$Result.GetResult<Prisma.$accidenttransactionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Accidenttransactions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {accidenttransactionsFindUniqueOrThrowArgs} args - Arguments to find a Accidenttransactions
     * @example
     * // Get one Accidenttransactions
     * const accidenttransactions = await prisma.accidenttransactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends accidenttransactionsFindUniqueOrThrowArgs>(args: SelectSubset<T, accidenttransactionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__accidenttransactionsClient<$Result.GetResult<Prisma.$accidenttransactionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Accidenttransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accidenttransactionsFindFirstArgs} args - Arguments to find a Accidenttransactions
     * @example
     * // Get one Accidenttransactions
     * const accidenttransactions = await prisma.accidenttransactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends accidenttransactionsFindFirstArgs>(args?: SelectSubset<T, accidenttransactionsFindFirstArgs<ExtArgs>>): Prisma__accidenttransactionsClient<$Result.GetResult<Prisma.$accidenttransactionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Accidenttransactions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accidenttransactionsFindFirstOrThrowArgs} args - Arguments to find a Accidenttransactions
     * @example
     * // Get one Accidenttransactions
     * const accidenttransactions = await prisma.accidenttransactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends accidenttransactionsFindFirstOrThrowArgs>(args?: SelectSubset<T, accidenttransactionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__accidenttransactionsClient<$Result.GetResult<Prisma.$accidenttransactionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Accidenttransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accidenttransactionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accidenttransactions
     * const accidenttransactions = await prisma.accidenttransactions.findMany()
     * 
     * // Get first 10 Accidenttransactions
     * const accidenttransactions = await prisma.accidenttransactions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accidenttransactionsWithIdOnly = await prisma.accidenttransactions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends accidenttransactionsFindManyArgs>(args?: SelectSubset<T, accidenttransactionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accidenttransactionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Accidenttransactions.
     * @param {accidenttransactionsCreateArgs} args - Arguments to create a Accidenttransactions.
     * @example
     * // Create one Accidenttransactions
     * const Accidenttransactions = await prisma.accidenttransactions.create({
     *   data: {
     *     // ... data to create a Accidenttransactions
     *   }
     * })
     * 
     */
    create<T extends accidenttransactionsCreateArgs>(args: SelectSubset<T, accidenttransactionsCreateArgs<ExtArgs>>): Prisma__accidenttransactionsClient<$Result.GetResult<Prisma.$accidenttransactionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Accidenttransactions.
     * @param {accidenttransactionsCreateManyArgs} args - Arguments to create many Accidenttransactions.
     * @example
     * // Create many Accidenttransactions
     * const accidenttransactions = await prisma.accidenttransactions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends accidenttransactionsCreateManyArgs>(args?: SelectSubset<T, accidenttransactionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accidenttransactions and returns the data saved in the database.
     * @param {accidenttransactionsCreateManyAndReturnArgs} args - Arguments to create many Accidenttransactions.
     * @example
     * // Create many Accidenttransactions
     * const accidenttransactions = await prisma.accidenttransactions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accidenttransactions and only return the `id`
     * const accidenttransactionsWithIdOnly = await prisma.accidenttransactions.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends accidenttransactionsCreateManyAndReturnArgs>(args?: SelectSubset<T, accidenttransactionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accidenttransactionsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Accidenttransactions.
     * @param {accidenttransactionsDeleteArgs} args - Arguments to delete one Accidenttransactions.
     * @example
     * // Delete one Accidenttransactions
     * const Accidenttransactions = await prisma.accidenttransactions.delete({
     *   where: {
     *     // ... filter to delete one Accidenttransactions
     *   }
     * })
     * 
     */
    delete<T extends accidenttransactionsDeleteArgs>(args: SelectSubset<T, accidenttransactionsDeleteArgs<ExtArgs>>): Prisma__accidenttransactionsClient<$Result.GetResult<Prisma.$accidenttransactionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Accidenttransactions.
     * @param {accidenttransactionsUpdateArgs} args - Arguments to update one Accidenttransactions.
     * @example
     * // Update one Accidenttransactions
     * const accidenttransactions = await prisma.accidenttransactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends accidenttransactionsUpdateArgs>(args: SelectSubset<T, accidenttransactionsUpdateArgs<ExtArgs>>): Prisma__accidenttransactionsClient<$Result.GetResult<Prisma.$accidenttransactionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Accidenttransactions.
     * @param {accidenttransactionsDeleteManyArgs} args - Arguments to filter Accidenttransactions to delete.
     * @example
     * // Delete a few Accidenttransactions
     * const { count } = await prisma.accidenttransactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends accidenttransactionsDeleteManyArgs>(args?: SelectSubset<T, accidenttransactionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accidenttransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accidenttransactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accidenttransactions
     * const accidenttransactions = await prisma.accidenttransactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends accidenttransactionsUpdateManyArgs>(args: SelectSubset<T, accidenttransactionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Accidenttransactions.
     * @param {accidenttransactionsUpsertArgs} args - Arguments to update or create a Accidenttransactions.
     * @example
     * // Update or create a Accidenttransactions
     * const accidenttransactions = await prisma.accidenttransactions.upsert({
     *   create: {
     *     // ... data to create a Accidenttransactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Accidenttransactions we want to update
     *   }
     * })
     */
    upsert<T extends accidenttransactionsUpsertArgs>(args: SelectSubset<T, accidenttransactionsUpsertArgs<ExtArgs>>): Prisma__accidenttransactionsClient<$Result.GetResult<Prisma.$accidenttransactionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Accidenttransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accidenttransactionsCountArgs} args - Arguments to filter Accidenttransactions to count.
     * @example
     * // Count the number of Accidenttransactions
     * const count = await prisma.accidenttransactions.count({
     *   where: {
     *     // ... the filter for the Accidenttransactions we want to count
     *   }
     * })
    **/
    count<T extends accidenttransactionsCountArgs>(
      args?: Subset<T, accidenttransactionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccidenttransactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Accidenttransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccidenttransactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccidenttransactionsAggregateArgs>(args: Subset<T, AccidenttransactionsAggregateArgs>): Prisma.PrismaPromise<GetAccidenttransactionsAggregateType<T>>

    /**
     * Group by Accidenttransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accidenttransactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends accidenttransactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: accidenttransactionsGroupByArgs['orderBy'] }
        : { orderBy?: accidenttransactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, accidenttransactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccidenttransactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the accidenttransactions model
   */
  readonly fields: accidenttransactionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for accidenttransactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__accidenttransactionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    insurers<T extends accidenttransactions$insurersArgs<ExtArgs> = {}>(args?: Subset<T, accidenttransactions$insurersArgs<ExtArgs>>): Prisma__insurersClient<$Result.GetResult<Prisma.$insurersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    causeofinjurydetail<T extends accidenttransactions$causeofinjurydetailArgs<ExtArgs> = {}>(args?: Subset<T, accidenttransactions$causeofinjurydetailArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$causeofinjurydetailPayload<ExtArgs>, T, "findMany"> | Null>
    injurydetail<T extends accidenttransactions$injurydetailArgs<ExtArgs> = {}>(args?: Subset<T, accidenttransactions$injurydetailArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$injurydetailPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the accidenttransactions model
   */ 
  interface accidenttransactionsFieldRefs {
    readonly id: FieldRef<"accidenttransactions", 'Int'>
    readonly insurerid: FieldRef<"accidenttransactions", 'Int'>
    readonly refid: FieldRef<"accidenttransactions", 'String'>
    readonly transactionno: FieldRef<"accidenttransactions", 'String'>
    readonly hn: FieldRef<"accidenttransactions", 'String'>
    readonly vn: FieldRef<"accidenttransactions", 'String'>
    readonly accidentplace: FieldRef<"accidenttransactions", 'String'>
    readonly accidentdate: FieldRef<"accidenttransactions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * accidenttransactions findUnique
   */
  export type accidenttransactionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidenttransactions
     */
    select?: accidenttransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidenttransactionsInclude<ExtArgs> | null
    /**
     * Filter, which accidenttransactions to fetch.
     */
    where: accidenttransactionsWhereUniqueInput
  }

  /**
   * accidenttransactions findUniqueOrThrow
   */
  export type accidenttransactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidenttransactions
     */
    select?: accidenttransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidenttransactionsInclude<ExtArgs> | null
    /**
     * Filter, which accidenttransactions to fetch.
     */
    where: accidenttransactionsWhereUniqueInput
  }

  /**
   * accidenttransactions findFirst
   */
  export type accidenttransactionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidenttransactions
     */
    select?: accidenttransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidenttransactionsInclude<ExtArgs> | null
    /**
     * Filter, which accidenttransactions to fetch.
     */
    where?: accidenttransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accidenttransactions to fetch.
     */
    orderBy?: accidenttransactionsOrderByWithRelationInput | accidenttransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accidenttransactions.
     */
    cursor?: accidenttransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accidenttransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accidenttransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accidenttransactions.
     */
    distinct?: AccidenttransactionsScalarFieldEnum | AccidenttransactionsScalarFieldEnum[]
  }

  /**
   * accidenttransactions findFirstOrThrow
   */
  export type accidenttransactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidenttransactions
     */
    select?: accidenttransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidenttransactionsInclude<ExtArgs> | null
    /**
     * Filter, which accidenttransactions to fetch.
     */
    where?: accidenttransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accidenttransactions to fetch.
     */
    orderBy?: accidenttransactionsOrderByWithRelationInput | accidenttransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accidenttransactions.
     */
    cursor?: accidenttransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accidenttransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accidenttransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accidenttransactions.
     */
    distinct?: AccidenttransactionsScalarFieldEnum | AccidenttransactionsScalarFieldEnum[]
  }

  /**
   * accidenttransactions findMany
   */
  export type accidenttransactionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidenttransactions
     */
    select?: accidenttransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidenttransactionsInclude<ExtArgs> | null
    /**
     * Filter, which accidenttransactions to fetch.
     */
    where?: accidenttransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accidenttransactions to fetch.
     */
    orderBy?: accidenttransactionsOrderByWithRelationInput | accidenttransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing accidenttransactions.
     */
    cursor?: accidenttransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accidenttransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accidenttransactions.
     */
    skip?: number
    distinct?: AccidenttransactionsScalarFieldEnum | AccidenttransactionsScalarFieldEnum[]
  }

  /**
   * accidenttransactions create
   */
  export type accidenttransactionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidenttransactions
     */
    select?: accidenttransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidenttransactionsInclude<ExtArgs> | null
    /**
     * The data needed to create a accidenttransactions.
     */
    data?: XOR<accidenttransactionsCreateInput, accidenttransactionsUncheckedCreateInput>
  }

  /**
   * accidenttransactions createMany
   */
  export type accidenttransactionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many accidenttransactions.
     */
    data: accidenttransactionsCreateManyInput | accidenttransactionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * accidenttransactions createManyAndReturn
   */
  export type accidenttransactionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidenttransactions
     */
    select?: accidenttransactionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many accidenttransactions.
     */
    data: accidenttransactionsCreateManyInput | accidenttransactionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidenttransactionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * accidenttransactions update
   */
  export type accidenttransactionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidenttransactions
     */
    select?: accidenttransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidenttransactionsInclude<ExtArgs> | null
    /**
     * The data needed to update a accidenttransactions.
     */
    data: XOR<accidenttransactionsUpdateInput, accidenttransactionsUncheckedUpdateInput>
    /**
     * Choose, which accidenttransactions to update.
     */
    where: accidenttransactionsWhereUniqueInput
  }

  /**
   * accidenttransactions updateMany
   */
  export type accidenttransactionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update accidenttransactions.
     */
    data: XOR<accidenttransactionsUpdateManyMutationInput, accidenttransactionsUncheckedUpdateManyInput>
    /**
     * Filter which accidenttransactions to update
     */
    where?: accidenttransactionsWhereInput
  }

  /**
   * accidenttransactions upsert
   */
  export type accidenttransactionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidenttransactions
     */
    select?: accidenttransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidenttransactionsInclude<ExtArgs> | null
    /**
     * The filter to search for the accidenttransactions to update in case it exists.
     */
    where: accidenttransactionsWhereUniqueInput
    /**
     * In case the accidenttransactions found by the `where` argument doesn't exist, create a new accidenttransactions with this data.
     */
    create: XOR<accidenttransactionsCreateInput, accidenttransactionsUncheckedCreateInput>
    /**
     * In case the accidenttransactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<accidenttransactionsUpdateInput, accidenttransactionsUncheckedUpdateInput>
  }

  /**
   * accidenttransactions delete
   */
  export type accidenttransactionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidenttransactions
     */
    select?: accidenttransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidenttransactionsInclude<ExtArgs> | null
    /**
     * Filter which accidenttransactions to delete.
     */
    where: accidenttransactionsWhereUniqueInput
  }

  /**
   * accidenttransactions deleteMany
   */
  export type accidenttransactionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accidenttransactions to delete
     */
    where?: accidenttransactionsWhereInput
  }

  /**
   * accidenttransactions.insurers
   */
  export type accidenttransactions$insurersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insurers
     */
    select?: insurersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: insurersInclude<ExtArgs> | null
    where?: insurersWhereInput
  }

  /**
   * accidenttransactions.causeofinjurydetail
   */
  export type accidenttransactions$causeofinjurydetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjurydetail
     */
    select?: causeofinjurydetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurydetailInclude<ExtArgs> | null
    where?: causeofinjurydetailWhereInput
    orderBy?: causeofinjurydetailOrderByWithRelationInput | causeofinjurydetailOrderByWithRelationInput[]
    cursor?: causeofinjurydetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CauseofinjurydetailScalarFieldEnum | CauseofinjurydetailScalarFieldEnum[]
  }

  /**
   * accidenttransactions.injurydetail
   */
  export type accidenttransactions$injurydetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the injurydetail
     */
    select?: injurydetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: injurydetailInclude<ExtArgs> | null
    where?: injurydetailWhereInput
    orderBy?: injurydetailOrderByWithRelationInput | injurydetailOrderByWithRelationInput[]
    cursor?: injurydetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InjurydetailScalarFieldEnum | InjurydetailScalarFieldEnum[]
  }

  /**
   * accidenttransactions without action
   */
  export type accidenttransactionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidenttransactions
     */
    select?: accidenttransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidenttransactionsInclude<ExtArgs> | null
  }


  /**
   * Model proceduretransactions
   */

  export type AggregateProceduretransactions = {
    _count: ProceduretransactionsCountAggregateOutputType | null
    _avg: ProceduretransactionsAvgAggregateOutputType | null
    _sum: ProceduretransactionsSumAggregateOutputType | null
    _min: ProceduretransactionsMinAggregateOutputType | null
    _max: ProceduretransactionsMaxAggregateOutputType | null
  }

  export type ProceduretransactionsAvgAggregateOutputType = {
    id: number | null
    insurerid: number | null
  }

  export type ProceduretransactionsSumAggregateOutputType = {
    id: number | null
    insurerid: number | null
  }

  export type ProceduretransactionsMinAggregateOutputType = {
    id: number | null
    insurerid: number | null
    refid: string | null
    transactionno: string | null
    hn: string | null
    vn: string | null
    icd9: string | null
    procedurename: string | null
    proceduredate: string | null
  }

  export type ProceduretransactionsMaxAggregateOutputType = {
    id: number | null
    insurerid: number | null
    refid: string | null
    transactionno: string | null
    hn: string | null
    vn: string | null
    icd9: string | null
    procedurename: string | null
    proceduredate: string | null
  }

  export type ProceduretransactionsCountAggregateOutputType = {
    id: number
    insurerid: number
    refid: number
    transactionno: number
    hn: number
    vn: number
    icd9: number
    procedurename: number
    proceduredate: number
    _all: number
  }


  export type ProceduretransactionsAvgAggregateInputType = {
    id?: true
    insurerid?: true
  }

  export type ProceduretransactionsSumAggregateInputType = {
    id?: true
    insurerid?: true
  }

  export type ProceduretransactionsMinAggregateInputType = {
    id?: true
    insurerid?: true
    refid?: true
    transactionno?: true
    hn?: true
    vn?: true
    icd9?: true
    procedurename?: true
    proceduredate?: true
  }

  export type ProceduretransactionsMaxAggregateInputType = {
    id?: true
    insurerid?: true
    refid?: true
    transactionno?: true
    hn?: true
    vn?: true
    icd9?: true
    procedurename?: true
    proceduredate?: true
  }

  export type ProceduretransactionsCountAggregateInputType = {
    id?: true
    insurerid?: true
    refid?: true
    transactionno?: true
    hn?: true
    vn?: true
    icd9?: true
    procedurename?: true
    proceduredate?: true
    _all?: true
  }

  export type ProceduretransactionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which proceduretransactions to aggregate.
     */
    where?: proceduretransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proceduretransactions to fetch.
     */
    orderBy?: proceduretransactionsOrderByWithRelationInput | proceduretransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: proceduretransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proceduretransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proceduretransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned proceduretransactions
    **/
    _count?: true | ProceduretransactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProceduretransactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProceduretransactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProceduretransactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProceduretransactionsMaxAggregateInputType
  }

  export type GetProceduretransactionsAggregateType<T extends ProceduretransactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateProceduretransactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProceduretransactions[P]>
      : GetScalarType<T[P], AggregateProceduretransactions[P]>
  }




  export type proceduretransactionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: proceduretransactionsWhereInput
    orderBy?: proceduretransactionsOrderByWithAggregationInput | proceduretransactionsOrderByWithAggregationInput[]
    by: ProceduretransactionsScalarFieldEnum[] | ProceduretransactionsScalarFieldEnum
    having?: proceduretransactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProceduretransactionsCountAggregateInputType | true
    _avg?: ProceduretransactionsAvgAggregateInputType
    _sum?: ProceduretransactionsSumAggregateInputType
    _min?: ProceduretransactionsMinAggregateInputType
    _max?: ProceduretransactionsMaxAggregateInputType
  }

  export type ProceduretransactionsGroupByOutputType = {
    id: number
    insurerid: number | null
    refid: string | null
    transactionno: string | null
    hn: string | null
    vn: string | null
    icd9: string | null
    procedurename: string | null
    proceduredate: string | null
    _count: ProceduretransactionsCountAggregateOutputType | null
    _avg: ProceduretransactionsAvgAggregateOutputType | null
    _sum: ProceduretransactionsSumAggregateOutputType | null
    _min: ProceduretransactionsMinAggregateOutputType | null
    _max: ProceduretransactionsMaxAggregateOutputType | null
  }

  type GetProceduretransactionsGroupByPayload<T extends proceduretransactionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProceduretransactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProceduretransactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProceduretransactionsGroupByOutputType[P]>
            : GetScalarType<T[P], ProceduretransactionsGroupByOutputType[P]>
        }
      >
    >


  export type proceduretransactionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insurerid?: boolean
    refid?: boolean
    transactionno?: boolean
    hn?: boolean
    vn?: boolean
    icd9?: boolean
    procedurename?: boolean
    proceduredate?: boolean
    insurers?: boolean | proceduretransactions$insurersArgs<ExtArgs>
  }, ExtArgs["result"]["proceduretransactions"]>

  export type proceduretransactionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insurerid?: boolean
    refid?: boolean
    transactionno?: boolean
    hn?: boolean
    vn?: boolean
    icd9?: boolean
    procedurename?: boolean
    proceduredate?: boolean
    insurers?: boolean | proceduretransactions$insurersArgs<ExtArgs>
  }, ExtArgs["result"]["proceduretransactions"]>

  export type proceduretransactionsSelectScalar = {
    id?: boolean
    insurerid?: boolean
    refid?: boolean
    transactionno?: boolean
    hn?: boolean
    vn?: boolean
    icd9?: boolean
    procedurename?: boolean
    proceduredate?: boolean
  }

  export type proceduretransactionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurers?: boolean | proceduretransactions$insurersArgs<ExtArgs>
  }
  export type proceduretransactionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurers?: boolean | proceduretransactions$insurersArgs<ExtArgs>
  }

  export type $proceduretransactionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "proceduretransactions"
    objects: {
      insurers: Prisma.$insurersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      insurerid: number | null
      refid: string | null
      transactionno: string | null
      hn: string | null
      vn: string | null
      icd9: string | null
      procedurename: string | null
      proceduredate: string | null
    }, ExtArgs["result"]["proceduretransactions"]>
    composites: {}
  }

  type proceduretransactionsGetPayload<S extends boolean | null | undefined | proceduretransactionsDefaultArgs> = $Result.GetResult<Prisma.$proceduretransactionsPayload, S>

  type proceduretransactionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<proceduretransactionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProceduretransactionsCountAggregateInputType | true
    }

  export interface proceduretransactionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['proceduretransactions'], meta: { name: 'proceduretransactions' } }
    /**
     * Find zero or one Proceduretransactions that matches the filter.
     * @param {proceduretransactionsFindUniqueArgs} args - Arguments to find a Proceduretransactions
     * @example
     * // Get one Proceduretransactions
     * const proceduretransactions = await prisma.proceduretransactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends proceduretransactionsFindUniqueArgs>(args: SelectSubset<T, proceduretransactionsFindUniqueArgs<ExtArgs>>): Prisma__proceduretransactionsClient<$Result.GetResult<Prisma.$proceduretransactionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Proceduretransactions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {proceduretransactionsFindUniqueOrThrowArgs} args - Arguments to find a Proceduretransactions
     * @example
     * // Get one Proceduretransactions
     * const proceduretransactions = await prisma.proceduretransactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends proceduretransactionsFindUniqueOrThrowArgs>(args: SelectSubset<T, proceduretransactionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__proceduretransactionsClient<$Result.GetResult<Prisma.$proceduretransactionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Proceduretransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proceduretransactionsFindFirstArgs} args - Arguments to find a Proceduretransactions
     * @example
     * // Get one Proceduretransactions
     * const proceduretransactions = await prisma.proceduretransactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends proceduretransactionsFindFirstArgs>(args?: SelectSubset<T, proceduretransactionsFindFirstArgs<ExtArgs>>): Prisma__proceduretransactionsClient<$Result.GetResult<Prisma.$proceduretransactionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Proceduretransactions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proceduretransactionsFindFirstOrThrowArgs} args - Arguments to find a Proceduretransactions
     * @example
     * // Get one Proceduretransactions
     * const proceduretransactions = await prisma.proceduretransactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends proceduretransactionsFindFirstOrThrowArgs>(args?: SelectSubset<T, proceduretransactionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__proceduretransactionsClient<$Result.GetResult<Prisma.$proceduretransactionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Proceduretransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proceduretransactionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Proceduretransactions
     * const proceduretransactions = await prisma.proceduretransactions.findMany()
     * 
     * // Get first 10 Proceduretransactions
     * const proceduretransactions = await prisma.proceduretransactions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proceduretransactionsWithIdOnly = await prisma.proceduretransactions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends proceduretransactionsFindManyArgs>(args?: SelectSubset<T, proceduretransactionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$proceduretransactionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Proceduretransactions.
     * @param {proceduretransactionsCreateArgs} args - Arguments to create a Proceduretransactions.
     * @example
     * // Create one Proceduretransactions
     * const Proceduretransactions = await prisma.proceduretransactions.create({
     *   data: {
     *     // ... data to create a Proceduretransactions
     *   }
     * })
     * 
     */
    create<T extends proceduretransactionsCreateArgs>(args: SelectSubset<T, proceduretransactionsCreateArgs<ExtArgs>>): Prisma__proceduretransactionsClient<$Result.GetResult<Prisma.$proceduretransactionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Proceduretransactions.
     * @param {proceduretransactionsCreateManyArgs} args - Arguments to create many Proceduretransactions.
     * @example
     * // Create many Proceduretransactions
     * const proceduretransactions = await prisma.proceduretransactions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends proceduretransactionsCreateManyArgs>(args?: SelectSubset<T, proceduretransactionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Proceduretransactions and returns the data saved in the database.
     * @param {proceduretransactionsCreateManyAndReturnArgs} args - Arguments to create many Proceduretransactions.
     * @example
     * // Create many Proceduretransactions
     * const proceduretransactions = await prisma.proceduretransactions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Proceduretransactions and only return the `id`
     * const proceduretransactionsWithIdOnly = await prisma.proceduretransactions.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends proceduretransactionsCreateManyAndReturnArgs>(args?: SelectSubset<T, proceduretransactionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$proceduretransactionsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Proceduretransactions.
     * @param {proceduretransactionsDeleteArgs} args - Arguments to delete one Proceduretransactions.
     * @example
     * // Delete one Proceduretransactions
     * const Proceduretransactions = await prisma.proceduretransactions.delete({
     *   where: {
     *     // ... filter to delete one Proceduretransactions
     *   }
     * })
     * 
     */
    delete<T extends proceduretransactionsDeleteArgs>(args: SelectSubset<T, proceduretransactionsDeleteArgs<ExtArgs>>): Prisma__proceduretransactionsClient<$Result.GetResult<Prisma.$proceduretransactionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Proceduretransactions.
     * @param {proceduretransactionsUpdateArgs} args - Arguments to update one Proceduretransactions.
     * @example
     * // Update one Proceduretransactions
     * const proceduretransactions = await prisma.proceduretransactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends proceduretransactionsUpdateArgs>(args: SelectSubset<T, proceduretransactionsUpdateArgs<ExtArgs>>): Prisma__proceduretransactionsClient<$Result.GetResult<Prisma.$proceduretransactionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Proceduretransactions.
     * @param {proceduretransactionsDeleteManyArgs} args - Arguments to filter Proceduretransactions to delete.
     * @example
     * // Delete a few Proceduretransactions
     * const { count } = await prisma.proceduretransactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends proceduretransactionsDeleteManyArgs>(args?: SelectSubset<T, proceduretransactionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proceduretransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proceduretransactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Proceduretransactions
     * const proceduretransactions = await prisma.proceduretransactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends proceduretransactionsUpdateManyArgs>(args: SelectSubset<T, proceduretransactionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Proceduretransactions.
     * @param {proceduretransactionsUpsertArgs} args - Arguments to update or create a Proceduretransactions.
     * @example
     * // Update or create a Proceduretransactions
     * const proceduretransactions = await prisma.proceduretransactions.upsert({
     *   create: {
     *     // ... data to create a Proceduretransactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proceduretransactions we want to update
     *   }
     * })
     */
    upsert<T extends proceduretransactionsUpsertArgs>(args: SelectSubset<T, proceduretransactionsUpsertArgs<ExtArgs>>): Prisma__proceduretransactionsClient<$Result.GetResult<Prisma.$proceduretransactionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Proceduretransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proceduretransactionsCountArgs} args - Arguments to filter Proceduretransactions to count.
     * @example
     * // Count the number of Proceduretransactions
     * const count = await prisma.proceduretransactions.count({
     *   where: {
     *     // ... the filter for the Proceduretransactions we want to count
     *   }
     * })
    **/
    count<T extends proceduretransactionsCountArgs>(
      args?: Subset<T, proceduretransactionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProceduretransactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proceduretransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProceduretransactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProceduretransactionsAggregateArgs>(args: Subset<T, ProceduretransactionsAggregateArgs>): Prisma.PrismaPromise<GetProceduretransactionsAggregateType<T>>

    /**
     * Group by Proceduretransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proceduretransactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends proceduretransactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: proceduretransactionsGroupByArgs['orderBy'] }
        : { orderBy?: proceduretransactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, proceduretransactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProceduretransactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the proceduretransactions model
   */
  readonly fields: proceduretransactionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for proceduretransactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__proceduretransactionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    insurers<T extends proceduretransactions$insurersArgs<ExtArgs> = {}>(args?: Subset<T, proceduretransactions$insurersArgs<ExtArgs>>): Prisma__insurersClient<$Result.GetResult<Prisma.$insurersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the proceduretransactions model
   */ 
  interface proceduretransactionsFieldRefs {
    readonly id: FieldRef<"proceduretransactions", 'Int'>
    readonly insurerid: FieldRef<"proceduretransactions", 'Int'>
    readonly refid: FieldRef<"proceduretransactions", 'String'>
    readonly transactionno: FieldRef<"proceduretransactions", 'String'>
    readonly hn: FieldRef<"proceduretransactions", 'String'>
    readonly vn: FieldRef<"proceduretransactions", 'String'>
    readonly icd9: FieldRef<"proceduretransactions", 'String'>
    readonly procedurename: FieldRef<"proceduretransactions", 'String'>
    readonly proceduredate: FieldRef<"proceduretransactions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * proceduretransactions findUnique
   */
  export type proceduretransactionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proceduretransactions
     */
    select?: proceduretransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proceduretransactionsInclude<ExtArgs> | null
    /**
     * Filter, which proceduretransactions to fetch.
     */
    where: proceduretransactionsWhereUniqueInput
  }

  /**
   * proceduretransactions findUniqueOrThrow
   */
  export type proceduretransactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proceduretransactions
     */
    select?: proceduretransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proceduretransactionsInclude<ExtArgs> | null
    /**
     * Filter, which proceduretransactions to fetch.
     */
    where: proceduretransactionsWhereUniqueInput
  }

  /**
   * proceduretransactions findFirst
   */
  export type proceduretransactionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proceduretransactions
     */
    select?: proceduretransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proceduretransactionsInclude<ExtArgs> | null
    /**
     * Filter, which proceduretransactions to fetch.
     */
    where?: proceduretransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proceduretransactions to fetch.
     */
    orderBy?: proceduretransactionsOrderByWithRelationInput | proceduretransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for proceduretransactions.
     */
    cursor?: proceduretransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proceduretransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proceduretransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of proceduretransactions.
     */
    distinct?: ProceduretransactionsScalarFieldEnum | ProceduretransactionsScalarFieldEnum[]
  }

  /**
   * proceduretransactions findFirstOrThrow
   */
  export type proceduretransactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proceduretransactions
     */
    select?: proceduretransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proceduretransactionsInclude<ExtArgs> | null
    /**
     * Filter, which proceduretransactions to fetch.
     */
    where?: proceduretransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proceduretransactions to fetch.
     */
    orderBy?: proceduretransactionsOrderByWithRelationInput | proceduretransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for proceduretransactions.
     */
    cursor?: proceduretransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proceduretransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proceduretransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of proceduretransactions.
     */
    distinct?: ProceduretransactionsScalarFieldEnum | ProceduretransactionsScalarFieldEnum[]
  }

  /**
   * proceduretransactions findMany
   */
  export type proceduretransactionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proceduretransactions
     */
    select?: proceduretransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proceduretransactionsInclude<ExtArgs> | null
    /**
     * Filter, which proceduretransactions to fetch.
     */
    where?: proceduretransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proceduretransactions to fetch.
     */
    orderBy?: proceduretransactionsOrderByWithRelationInput | proceduretransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing proceduretransactions.
     */
    cursor?: proceduretransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proceduretransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proceduretransactions.
     */
    skip?: number
    distinct?: ProceduretransactionsScalarFieldEnum | ProceduretransactionsScalarFieldEnum[]
  }

  /**
   * proceduretransactions create
   */
  export type proceduretransactionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proceduretransactions
     */
    select?: proceduretransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proceduretransactionsInclude<ExtArgs> | null
    /**
     * The data needed to create a proceduretransactions.
     */
    data?: XOR<proceduretransactionsCreateInput, proceduretransactionsUncheckedCreateInput>
  }

  /**
   * proceduretransactions createMany
   */
  export type proceduretransactionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many proceduretransactions.
     */
    data: proceduretransactionsCreateManyInput | proceduretransactionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * proceduretransactions createManyAndReturn
   */
  export type proceduretransactionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proceduretransactions
     */
    select?: proceduretransactionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many proceduretransactions.
     */
    data: proceduretransactionsCreateManyInput | proceduretransactionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proceduretransactionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * proceduretransactions update
   */
  export type proceduretransactionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proceduretransactions
     */
    select?: proceduretransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proceduretransactionsInclude<ExtArgs> | null
    /**
     * The data needed to update a proceduretransactions.
     */
    data: XOR<proceduretransactionsUpdateInput, proceduretransactionsUncheckedUpdateInput>
    /**
     * Choose, which proceduretransactions to update.
     */
    where: proceduretransactionsWhereUniqueInput
  }

  /**
   * proceduretransactions updateMany
   */
  export type proceduretransactionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update proceduretransactions.
     */
    data: XOR<proceduretransactionsUpdateManyMutationInput, proceduretransactionsUncheckedUpdateManyInput>
    /**
     * Filter which proceduretransactions to update
     */
    where?: proceduretransactionsWhereInput
  }

  /**
   * proceduretransactions upsert
   */
  export type proceduretransactionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proceduretransactions
     */
    select?: proceduretransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proceduretransactionsInclude<ExtArgs> | null
    /**
     * The filter to search for the proceduretransactions to update in case it exists.
     */
    where: proceduretransactionsWhereUniqueInput
    /**
     * In case the proceduretransactions found by the `where` argument doesn't exist, create a new proceduretransactions with this data.
     */
    create: XOR<proceduretransactionsCreateInput, proceduretransactionsUncheckedCreateInput>
    /**
     * In case the proceduretransactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<proceduretransactionsUpdateInput, proceduretransactionsUncheckedUpdateInput>
  }

  /**
   * proceduretransactions delete
   */
  export type proceduretransactionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proceduretransactions
     */
    select?: proceduretransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proceduretransactionsInclude<ExtArgs> | null
    /**
     * Filter which proceduretransactions to delete.
     */
    where: proceduretransactionsWhereUniqueInput
  }

  /**
   * proceduretransactions deleteMany
   */
  export type proceduretransactionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which proceduretransactions to delete
     */
    where?: proceduretransactionsWhereInput
  }

  /**
   * proceduretransactions.insurers
   */
  export type proceduretransactions$insurersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insurers
     */
    select?: insurersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: insurersInclude<ExtArgs> | null
    where?: insurersWhereInput
  }

  /**
   * proceduretransactions without action
   */
  export type proceduretransactionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proceduretransactions
     */
    select?: proceduretransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proceduretransactionsInclude<ExtArgs> | null
  }


  /**
   * Model accidenttransactions22
   */

  export type AggregateAccidenttransactions22 = {
    _count: Accidenttransactions22CountAggregateOutputType | null
    _avg: Accidenttransactions22AvgAggregateOutputType | null
    _sum: Accidenttransactions22SumAggregateOutputType | null
    _min: Accidenttransactions22MinAggregateOutputType | null
    _max: Accidenttransactions22MaxAggregateOutputType | null
  }

  export type Accidenttransactions22AvgAggregateOutputType = {
    id: number | null
    insurerid: number | null
  }

  export type Accidenttransactions22SumAggregateOutputType = {
    id: number | null
    insurerid: number | null
  }

  export type Accidenttransactions22MinAggregateOutputType = {
    id: number | null
    insurerid: number | null
    refid: string | null
    transactionno: string | null
    hn: string | null
    vn: string | null
    accidentplace: string | null
    accidentdate: string | null
    causeofinjury: string | null
    commentofinjury: string | null
    woundtype: string | null
    injuryside: string | null
    injuryarea: string | null
  }

  export type Accidenttransactions22MaxAggregateOutputType = {
    id: number | null
    insurerid: number | null
    refid: string | null
    transactionno: string | null
    hn: string | null
    vn: string | null
    accidentplace: string | null
    accidentdate: string | null
    causeofinjury: string | null
    commentofinjury: string | null
    woundtype: string | null
    injuryside: string | null
    injuryarea: string | null
  }

  export type Accidenttransactions22CountAggregateOutputType = {
    id: number
    insurerid: number
    refid: number
    transactionno: number
    hn: number
    vn: number
    accidentplace: number
    accidentdate: number
    causeofinjury: number
    commentofinjury: number
    woundtype: number
    injuryside: number
    injuryarea: number
    _all: number
  }


  export type Accidenttransactions22AvgAggregateInputType = {
    id?: true
    insurerid?: true
  }

  export type Accidenttransactions22SumAggregateInputType = {
    id?: true
    insurerid?: true
  }

  export type Accidenttransactions22MinAggregateInputType = {
    id?: true
    insurerid?: true
    refid?: true
    transactionno?: true
    hn?: true
    vn?: true
    accidentplace?: true
    accidentdate?: true
    causeofinjury?: true
    commentofinjury?: true
    woundtype?: true
    injuryside?: true
    injuryarea?: true
  }

  export type Accidenttransactions22MaxAggregateInputType = {
    id?: true
    insurerid?: true
    refid?: true
    transactionno?: true
    hn?: true
    vn?: true
    accidentplace?: true
    accidentdate?: true
    causeofinjury?: true
    commentofinjury?: true
    woundtype?: true
    injuryside?: true
    injuryarea?: true
  }

  export type Accidenttransactions22CountAggregateInputType = {
    id?: true
    insurerid?: true
    refid?: true
    transactionno?: true
    hn?: true
    vn?: true
    accidentplace?: true
    accidentdate?: true
    causeofinjury?: true
    commentofinjury?: true
    woundtype?: true
    injuryside?: true
    injuryarea?: true
    _all?: true
  }

  export type Accidenttransactions22AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accidenttransactions22 to aggregate.
     */
    where?: accidenttransactions22WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accidenttransactions22s to fetch.
     */
    orderBy?: accidenttransactions22OrderByWithRelationInput | accidenttransactions22OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: accidenttransactions22WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accidenttransactions22s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accidenttransactions22s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned accidenttransactions22s
    **/
    _count?: true | Accidenttransactions22CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Accidenttransactions22AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Accidenttransactions22SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Accidenttransactions22MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Accidenttransactions22MaxAggregateInputType
  }

  export type GetAccidenttransactions22AggregateType<T extends Accidenttransactions22AggregateArgs> = {
        [P in keyof T & keyof AggregateAccidenttransactions22]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccidenttransactions22[P]>
      : GetScalarType<T[P], AggregateAccidenttransactions22[P]>
  }




  export type accidenttransactions22GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: accidenttransactions22WhereInput
    orderBy?: accidenttransactions22OrderByWithAggregationInput | accidenttransactions22OrderByWithAggregationInput[]
    by: Accidenttransactions22ScalarFieldEnum[] | Accidenttransactions22ScalarFieldEnum
    having?: accidenttransactions22ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Accidenttransactions22CountAggregateInputType | true
    _avg?: Accidenttransactions22AvgAggregateInputType
    _sum?: Accidenttransactions22SumAggregateInputType
    _min?: Accidenttransactions22MinAggregateInputType
    _max?: Accidenttransactions22MaxAggregateInputType
  }

  export type Accidenttransactions22GroupByOutputType = {
    id: number
    insurerid: number | null
    refid: string | null
    transactionno: string | null
    hn: string | null
    vn: string | null
    accidentplace: string | null
    accidentdate: string | null
    causeofinjury: string | null
    commentofinjury: string | null
    woundtype: string | null
    injuryside: string | null
    injuryarea: string | null
    _count: Accidenttransactions22CountAggregateOutputType | null
    _avg: Accidenttransactions22AvgAggregateOutputType | null
    _sum: Accidenttransactions22SumAggregateOutputType | null
    _min: Accidenttransactions22MinAggregateOutputType | null
    _max: Accidenttransactions22MaxAggregateOutputType | null
  }

  type GetAccidenttransactions22GroupByPayload<T extends accidenttransactions22GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Accidenttransactions22GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Accidenttransactions22GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Accidenttransactions22GroupByOutputType[P]>
            : GetScalarType<T[P], Accidenttransactions22GroupByOutputType[P]>
        }
      >
    >


  export type accidenttransactions22Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insurerid?: boolean
    refid?: boolean
    transactionno?: boolean
    hn?: boolean
    vn?: boolean
    accidentplace?: boolean
    accidentdate?: boolean
    causeofinjury?: boolean
    commentofinjury?: boolean
    woundtype?: boolean
    injuryside?: boolean
    injuryarea?: boolean
    insurers?: boolean | accidenttransactions22$insurersArgs<ExtArgs>
  }, ExtArgs["result"]["accidenttransactions22"]>

  export type accidenttransactions22SelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insurerid?: boolean
    refid?: boolean
    transactionno?: boolean
    hn?: boolean
    vn?: boolean
    accidentplace?: boolean
    accidentdate?: boolean
    causeofinjury?: boolean
    commentofinjury?: boolean
    woundtype?: boolean
    injuryside?: boolean
    injuryarea?: boolean
    insurers?: boolean | accidenttransactions22$insurersArgs<ExtArgs>
  }, ExtArgs["result"]["accidenttransactions22"]>

  export type accidenttransactions22SelectScalar = {
    id?: boolean
    insurerid?: boolean
    refid?: boolean
    transactionno?: boolean
    hn?: boolean
    vn?: boolean
    accidentplace?: boolean
    accidentdate?: boolean
    causeofinjury?: boolean
    commentofinjury?: boolean
    woundtype?: boolean
    injuryside?: boolean
    injuryarea?: boolean
  }

  export type accidenttransactions22Include<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurers?: boolean | accidenttransactions22$insurersArgs<ExtArgs>
  }
  export type accidenttransactions22IncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurers?: boolean | accidenttransactions22$insurersArgs<ExtArgs>
  }

  export type $accidenttransactions22Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "accidenttransactions22"
    objects: {
      insurers: Prisma.$insurersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      insurerid: number | null
      refid: string | null
      transactionno: string | null
      hn: string | null
      vn: string | null
      accidentplace: string | null
      accidentdate: string | null
      causeofinjury: string | null
      commentofinjury: string | null
      woundtype: string | null
      injuryside: string | null
      injuryarea: string | null
    }, ExtArgs["result"]["accidenttransactions22"]>
    composites: {}
  }

  type accidenttransactions22GetPayload<S extends boolean | null | undefined | accidenttransactions22DefaultArgs> = $Result.GetResult<Prisma.$accidenttransactions22Payload, S>

  type accidenttransactions22CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<accidenttransactions22FindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Accidenttransactions22CountAggregateInputType | true
    }

  export interface accidenttransactions22Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['accidenttransactions22'], meta: { name: 'accidenttransactions22' } }
    /**
     * Find zero or one Accidenttransactions22 that matches the filter.
     * @param {accidenttransactions22FindUniqueArgs} args - Arguments to find a Accidenttransactions22
     * @example
     * // Get one Accidenttransactions22
     * const accidenttransactions22 = await prisma.accidenttransactions22.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends accidenttransactions22FindUniqueArgs>(args: SelectSubset<T, accidenttransactions22FindUniqueArgs<ExtArgs>>): Prisma__accidenttransactions22Client<$Result.GetResult<Prisma.$accidenttransactions22Payload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Accidenttransactions22 that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {accidenttransactions22FindUniqueOrThrowArgs} args - Arguments to find a Accidenttransactions22
     * @example
     * // Get one Accidenttransactions22
     * const accidenttransactions22 = await prisma.accidenttransactions22.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends accidenttransactions22FindUniqueOrThrowArgs>(args: SelectSubset<T, accidenttransactions22FindUniqueOrThrowArgs<ExtArgs>>): Prisma__accidenttransactions22Client<$Result.GetResult<Prisma.$accidenttransactions22Payload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Accidenttransactions22 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accidenttransactions22FindFirstArgs} args - Arguments to find a Accidenttransactions22
     * @example
     * // Get one Accidenttransactions22
     * const accidenttransactions22 = await prisma.accidenttransactions22.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends accidenttransactions22FindFirstArgs>(args?: SelectSubset<T, accidenttransactions22FindFirstArgs<ExtArgs>>): Prisma__accidenttransactions22Client<$Result.GetResult<Prisma.$accidenttransactions22Payload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Accidenttransactions22 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accidenttransactions22FindFirstOrThrowArgs} args - Arguments to find a Accidenttransactions22
     * @example
     * // Get one Accidenttransactions22
     * const accidenttransactions22 = await prisma.accidenttransactions22.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends accidenttransactions22FindFirstOrThrowArgs>(args?: SelectSubset<T, accidenttransactions22FindFirstOrThrowArgs<ExtArgs>>): Prisma__accidenttransactions22Client<$Result.GetResult<Prisma.$accidenttransactions22Payload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Accidenttransactions22s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accidenttransactions22FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accidenttransactions22s
     * const accidenttransactions22s = await prisma.accidenttransactions22.findMany()
     * 
     * // Get first 10 Accidenttransactions22s
     * const accidenttransactions22s = await prisma.accidenttransactions22.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accidenttransactions22WithIdOnly = await prisma.accidenttransactions22.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends accidenttransactions22FindManyArgs>(args?: SelectSubset<T, accidenttransactions22FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accidenttransactions22Payload<ExtArgs>, T, "findMany">>

    /**
     * Create a Accidenttransactions22.
     * @param {accidenttransactions22CreateArgs} args - Arguments to create a Accidenttransactions22.
     * @example
     * // Create one Accidenttransactions22
     * const Accidenttransactions22 = await prisma.accidenttransactions22.create({
     *   data: {
     *     // ... data to create a Accidenttransactions22
     *   }
     * })
     * 
     */
    create<T extends accidenttransactions22CreateArgs>(args: SelectSubset<T, accidenttransactions22CreateArgs<ExtArgs>>): Prisma__accidenttransactions22Client<$Result.GetResult<Prisma.$accidenttransactions22Payload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Accidenttransactions22s.
     * @param {accidenttransactions22CreateManyArgs} args - Arguments to create many Accidenttransactions22s.
     * @example
     * // Create many Accidenttransactions22s
     * const accidenttransactions22 = await prisma.accidenttransactions22.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends accidenttransactions22CreateManyArgs>(args?: SelectSubset<T, accidenttransactions22CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accidenttransactions22s and returns the data saved in the database.
     * @param {accidenttransactions22CreateManyAndReturnArgs} args - Arguments to create many Accidenttransactions22s.
     * @example
     * // Create many Accidenttransactions22s
     * const accidenttransactions22 = await prisma.accidenttransactions22.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accidenttransactions22s and only return the `id`
     * const accidenttransactions22WithIdOnly = await prisma.accidenttransactions22.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends accidenttransactions22CreateManyAndReturnArgs>(args?: SelectSubset<T, accidenttransactions22CreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accidenttransactions22Payload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Accidenttransactions22.
     * @param {accidenttransactions22DeleteArgs} args - Arguments to delete one Accidenttransactions22.
     * @example
     * // Delete one Accidenttransactions22
     * const Accidenttransactions22 = await prisma.accidenttransactions22.delete({
     *   where: {
     *     // ... filter to delete one Accidenttransactions22
     *   }
     * })
     * 
     */
    delete<T extends accidenttransactions22DeleteArgs>(args: SelectSubset<T, accidenttransactions22DeleteArgs<ExtArgs>>): Prisma__accidenttransactions22Client<$Result.GetResult<Prisma.$accidenttransactions22Payload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Accidenttransactions22.
     * @param {accidenttransactions22UpdateArgs} args - Arguments to update one Accidenttransactions22.
     * @example
     * // Update one Accidenttransactions22
     * const accidenttransactions22 = await prisma.accidenttransactions22.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends accidenttransactions22UpdateArgs>(args: SelectSubset<T, accidenttransactions22UpdateArgs<ExtArgs>>): Prisma__accidenttransactions22Client<$Result.GetResult<Prisma.$accidenttransactions22Payload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Accidenttransactions22s.
     * @param {accidenttransactions22DeleteManyArgs} args - Arguments to filter Accidenttransactions22s to delete.
     * @example
     * // Delete a few Accidenttransactions22s
     * const { count } = await prisma.accidenttransactions22.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends accidenttransactions22DeleteManyArgs>(args?: SelectSubset<T, accidenttransactions22DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accidenttransactions22s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accidenttransactions22UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accidenttransactions22s
     * const accidenttransactions22 = await prisma.accidenttransactions22.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends accidenttransactions22UpdateManyArgs>(args: SelectSubset<T, accidenttransactions22UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Accidenttransactions22.
     * @param {accidenttransactions22UpsertArgs} args - Arguments to update or create a Accidenttransactions22.
     * @example
     * // Update or create a Accidenttransactions22
     * const accidenttransactions22 = await prisma.accidenttransactions22.upsert({
     *   create: {
     *     // ... data to create a Accidenttransactions22
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Accidenttransactions22 we want to update
     *   }
     * })
     */
    upsert<T extends accidenttransactions22UpsertArgs>(args: SelectSubset<T, accidenttransactions22UpsertArgs<ExtArgs>>): Prisma__accidenttransactions22Client<$Result.GetResult<Prisma.$accidenttransactions22Payload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Accidenttransactions22s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accidenttransactions22CountArgs} args - Arguments to filter Accidenttransactions22s to count.
     * @example
     * // Count the number of Accidenttransactions22s
     * const count = await prisma.accidenttransactions22.count({
     *   where: {
     *     // ... the filter for the Accidenttransactions22s we want to count
     *   }
     * })
    **/
    count<T extends accidenttransactions22CountArgs>(
      args?: Subset<T, accidenttransactions22CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Accidenttransactions22CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Accidenttransactions22.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Accidenttransactions22AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Accidenttransactions22AggregateArgs>(args: Subset<T, Accidenttransactions22AggregateArgs>): Prisma.PrismaPromise<GetAccidenttransactions22AggregateType<T>>

    /**
     * Group by Accidenttransactions22.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accidenttransactions22GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends accidenttransactions22GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: accidenttransactions22GroupByArgs['orderBy'] }
        : { orderBy?: accidenttransactions22GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, accidenttransactions22GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccidenttransactions22GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the accidenttransactions22 model
   */
  readonly fields: accidenttransactions22FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for accidenttransactions22.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__accidenttransactions22Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    insurers<T extends accidenttransactions22$insurersArgs<ExtArgs> = {}>(args?: Subset<T, accidenttransactions22$insurersArgs<ExtArgs>>): Prisma__insurersClient<$Result.GetResult<Prisma.$insurersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the accidenttransactions22 model
   */ 
  interface accidenttransactions22FieldRefs {
    readonly id: FieldRef<"accidenttransactions22", 'Int'>
    readonly insurerid: FieldRef<"accidenttransactions22", 'Int'>
    readonly refid: FieldRef<"accidenttransactions22", 'String'>
    readonly transactionno: FieldRef<"accidenttransactions22", 'String'>
    readonly hn: FieldRef<"accidenttransactions22", 'String'>
    readonly vn: FieldRef<"accidenttransactions22", 'String'>
    readonly accidentplace: FieldRef<"accidenttransactions22", 'String'>
    readonly accidentdate: FieldRef<"accidenttransactions22", 'String'>
    readonly causeofinjury: FieldRef<"accidenttransactions22", 'String'>
    readonly commentofinjury: FieldRef<"accidenttransactions22", 'String'>
    readonly woundtype: FieldRef<"accidenttransactions22", 'String'>
    readonly injuryside: FieldRef<"accidenttransactions22", 'String'>
    readonly injuryarea: FieldRef<"accidenttransactions22", 'String'>
  }
    

  // Custom InputTypes
  /**
   * accidenttransactions22 findUnique
   */
  export type accidenttransactions22FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidenttransactions22
     */
    select?: accidenttransactions22Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidenttransactions22Include<ExtArgs> | null
    /**
     * Filter, which accidenttransactions22 to fetch.
     */
    where: accidenttransactions22WhereUniqueInput
  }

  /**
   * accidenttransactions22 findUniqueOrThrow
   */
  export type accidenttransactions22FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidenttransactions22
     */
    select?: accidenttransactions22Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidenttransactions22Include<ExtArgs> | null
    /**
     * Filter, which accidenttransactions22 to fetch.
     */
    where: accidenttransactions22WhereUniqueInput
  }

  /**
   * accidenttransactions22 findFirst
   */
  export type accidenttransactions22FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidenttransactions22
     */
    select?: accidenttransactions22Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidenttransactions22Include<ExtArgs> | null
    /**
     * Filter, which accidenttransactions22 to fetch.
     */
    where?: accidenttransactions22WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accidenttransactions22s to fetch.
     */
    orderBy?: accidenttransactions22OrderByWithRelationInput | accidenttransactions22OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accidenttransactions22s.
     */
    cursor?: accidenttransactions22WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accidenttransactions22s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accidenttransactions22s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accidenttransactions22s.
     */
    distinct?: Accidenttransactions22ScalarFieldEnum | Accidenttransactions22ScalarFieldEnum[]
  }

  /**
   * accidenttransactions22 findFirstOrThrow
   */
  export type accidenttransactions22FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidenttransactions22
     */
    select?: accidenttransactions22Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidenttransactions22Include<ExtArgs> | null
    /**
     * Filter, which accidenttransactions22 to fetch.
     */
    where?: accidenttransactions22WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accidenttransactions22s to fetch.
     */
    orderBy?: accidenttransactions22OrderByWithRelationInput | accidenttransactions22OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accidenttransactions22s.
     */
    cursor?: accidenttransactions22WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accidenttransactions22s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accidenttransactions22s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accidenttransactions22s.
     */
    distinct?: Accidenttransactions22ScalarFieldEnum | Accidenttransactions22ScalarFieldEnum[]
  }

  /**
   * accidenttransactions22 findMany
   */
  export type accidenttransactions22FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidenttransactions22
     */
    select?: accidenttransactions22Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidenttransactions22Include<ExtArgs> | null
    /**
     * Filter, which accidenttransactions22s to fetch.
     */
    where?: accidenttransactions22WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accidenttransactions22s to fetch.
     */
    orderBy?: accidenttransactions22OrderByWithRelationInput | accidenttransactions22OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing accidenttransactions22s.
     */
    cursor?: accidenttransactions22WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accidenttransactions22s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accidenttransactions22s.
     */
    skip?: number
    distinct?: Accidenttransactions22ScalarFieldEnum | Accidenttransactions22ScalarFieldEnum[]
  }

  /**
   * accidenttransactions22 create
   */
  export type accidenttransactions22CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidenttransactions22
     */
    select?: accidenttransactions22Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidenttransactions22Include<ExtArgs> | null
    /**
     * The data needed to create a accidenttransactions22.
     */
    data?: XOR<accidenttransactions22CreateInput, accidenttransactions22UncheckedCreateInput>
  }

  /**
   * accidenttransactions22 createMany
   */
  export type accidenttransactions22CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many accidenttransactions22s.
     */
    data: accidenttransactions22CreateManyInput | accidenttransactions22CreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * accidenttransactions22 createManyAndReturn
   */
  export type accidenttransactions22CreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidenttransactions22
     */
    select?: accidenttransactions22SelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many accidenttransactions22s.
     */
    data: accidenttransactions22CreateManyInput | accidenttransactions22CreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidenttransactions22IncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * accidenttransactions22 update
   */
  export type accidenttransactions22UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidenttransactions22
     */
    select?: accidenttransactions22Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidenttransactions22Include<ExtArgs> | null
    /**
     * The data needed to update a accidenttransactions22.
     */
    data: XOR<accidenttransactions22UpdateInput, accidenttransactions22UncheckedUpdateInput>
    /**
     * Choose, which accidenttransactions22 to update.
     */
    where: accidenttransactions22WhereUniqueInput
  }

  /**
   * accidenttransactions22 updateMany
   */
  export type accidenttransactions22UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update accidenttransactions22s.
     */
    data: XOR<accidenttransactions22UpdateManyMutationInput, accidenttransactions22UncheckedUpdateManyInput>
    /**
     * Filter which accidenttransactions22s to update
     */
    where?: accidenttransactions22WhereInput
  }

  /**
   * accidenttransactions22 upsert
   */
  export type accidenttransactions22UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidenttransactions22
     */
    select?: accidenttransactions22Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidenttransactions22Include<ExtArgs> | null
    /**
     * The filter to search for the accidenttransactions22 to update in case it exists.
     */
    where: accidenttransactions22WhereUniqueInput
    /**
     * In case the accidenttransactions22 found by the `where` argument doesn't exist, create a new accidenttransactions22 with this data.
     */
    create: XOR<accidenttransactions22CreateInput, accidenttransactions22UncheckedCreateInput>
    /**
     * In case the accidenttransactions22 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<accidenttransactions22UpdateInput, accidenttransactions22UncheckedUpdateInput>
  }

  /**
   * accidenttransactions22 delete
   */
  export type accidenttransactions22DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidenttransactions22
     */
    select?: accidenttransactions22Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidenttransactions22Include<ExtArgs> | null
    /**
     * Filter which accidenttransactions22 to delete.
     */
    where: accidenttransactions22WhereUniqueInput
  }

  /**
   * accidenttransactions22 deleteMany
   */
  export type accidenttransactions22DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accidenttransactions22s to delete
     */
    where?: accidenttransactions22WhereInput
  }

  /**
   * accidenttransactions22.insurers
   */
  export type accidenttransactions22$insurersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the insurers
     */
    select?: insurersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: insurersInclude<ExtArgs> | null
    where?: insurersWhereInput
  }

  /**
   * accidenttransactions22 without action
   */
  export type accidenttransactions22DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidenttransactions22
     */
    select?: accidenttransactions22Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidenttransactions22Include<ExtArgs> | null
  }


  /**
   * Model causeofinjurydetail
   */

  export type AggregateCauseofinjurydetail = {
    _count: CauseofinjurydetailCountAggregateOutputType | null
    _avg: CauseofinjurydetailAvgAggregateOutputType | null
    _sum: CauseofinjurydetailSumAggregateOutputType | null
    _min: CauseofinjurydetailMinAggregateOutputType | null
    _max: CauseofinjurydetailMaxAggregateOutputType | null
  }

  export type CauseofinjurydetailAvgAggregateOutputType = {
    id: number | null
    accidentid: number | null
  }

  export type CauseofinjurydetailSumAggregateOutputType = {
    id: number | null
    accidentid: number | null
  }

  export type CauseofinjurydetailMinAggregateOutputType = {
    id: number | null
    accidentid: number | null
    causeofinjury: string | null
    commentofinjury: string | null
  }

  export type CauseofinjurydetailMaxAggregateOutputType = {
    id: number | null
    accidentid: number | null
    causeofinjury: string | null
    commentofinjury: string | null
  }

  export type CauseofinjurydetailCountAggregateOutputType = {
    id: number
    accidentid: number
    causeofinjury: number
    commentofinjury: number
    _all: number
  }


  export type CauseofinjurydetailAvgAggregateInputType = {
    id?: true
    accidentid?: true
  }

  export type CauseofinjurydetailSumAggregateInputType = {
    id?: true
    accidentid?: true
  }

  export type CauseofinjurydetailMinAggregateInputType = {
    id?: true
    accidentid?: true
    causeofinjury?: true
    commentofinjury?: true
  }

  export type CauseofinjurydetailMaxAggregateInputType = {
    id?: true
    accidentid?: true
    causeofinjury?: true
    commentofinjury?: true
  }

  export type CauseofinjurydetailCountAggregateInputType = {
    id?: true
    accidentid?: true
    causeofinjury?: true
    commentofinjury?: true
    _all?: true
  }

  export type CauseofinjurydetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which causeofinjurydetail to aggregate.
     */
    where?: causeofinjurydetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of causeofinjurydetails to fetch.
     */
    orderBy?: causeofinjurydetailOrderByWithRelationInput | causeofinjurydetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: causeofinjurydetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` causeofinjurydetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` causeofinjurydetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned causeofinjurydetails
    **/
    _count?: true | CauseofinjurydetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CauseofinjurydetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CauseofinjurydetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CauseofinjurydetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CauseofinjurydetailMaxAggregateInputType
  }

  export type GetCauseofinjurydetailAggregateType<T extends CauseofinjurydetailAggregateArgs> = {
        [P in keyof T & keyof AggregateCauseofinjurydetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCauseofinjurydetail[P]>
      : GetScalarType<T[P], AggregateCauseofinjurydetail[P]>
  }




  export type causeofinjurydetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: causeofinjurydetailWhereInput
    orderBy?: causeofinjurydetailOrderByWithAggregationInput | causeofinjurydetailOrderByWithAggregationInput[]
    by: CauseofinjurydetailScalarFieldEnum[] | CauseofinjurydetailScalarFieldEnum
    having?: causeofinjurydetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CauseofinjurydetailCountAggregateInputType | true
    _avg?: CauseofinjurydetailAvgAggregateInputType
    _sum?: CauseofinjurydetailSumAggregateInputType
    _min?: CauseofinjurydetailMinAggregateInputType
    _max?: CauseofinjurydetailMaxAggregateInputType
  }

  export type CauseofinjurydetailGroupByOutputType = {
    id: number
    accidentid: number | null
    causeofinjury: string | null
    commentofinjury: string | null
    _count: CauseofinjurydetailCountAggregateOutputType | null
    _avg: CauseofinjurydetailAvgAggregateOutputType | null
    _sum: CauseofinjurydetailSumAggregateOutputType | null
    _min: CauseofinjurydetailMinAggregateOutputType | null
    _max: CauseofinjurydetailMaxAggregateOutputType | null
  }

  type GetCauseofinjurydetailGroupByPayload<T extends causeofinjurydetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CauseofinjurydetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CauseofinjurydetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CauseofinjurydetailGroupByOutputType[P]>
            : GetScalarType<T[P], CauseofinjurydetailGroupByOutputType[P]>
        }
      >
    >


  export type causeofinjurydetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accidentid?: boolean
    causeofinjury?: boolean
    commentofinjury?: boolean
    accidenttransactions?: boolean | causeofinjurydetail$accidenttransactionsArgs<ExtArgs>
  }, ExtArgs["result"]["causeofinjurydetail"]>

  export type causeofinjurydetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accidentid?: boolean
    causeofinjury?: boolean
    commentofinjury?: boolean
    accidenttransactions?: boolean | causeofinjurydetail$accidenttransactionsArgs<ExtArgs>
  }, ExtArgs["result"]["causeofinjurydetail"]>

  export type causeofinjurydetailSelectScalar = {
    id?: boolean
    accidentid?: boolean
    causeofinjury?: boolean
    commentofinjury?: boolean
  }

  export type causeofinjurydetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accidenttransactions?: boolean | causeofinjurydetail$accidenttransactionsArgs<ExtArgs>
  }
  export type causeofinjurydetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accidenttransactions?: boolean | causeofinjurydetail$accidenttransactionsArgs<ExtArgs>
  }

  export type $causeofinjurydetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "causeofinjurydetail"
    objects: {
      accidenttransactions: Prisma.$accidenttransactionsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      accidentid: number | null
      causeofinjury: string | null
      commentofinjury: string | null
    }, ExtArgs["result"]["causeofinjurydetail"]>
    composites: {}
  }

  type causeofinjurydetailGetPayload<S extends boolean | null | undefined | causeofinjurydetailDefaultArgs> = $Result.GetResult<Prisma.$causeofinjurydetailPayload, S>

  type causeofinjurydetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<causeofinjurydetailFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CauseofinjurydetailCountAggregateInputType | true
    }

  export interface causeofinjurydetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['causeofinjurydetail'], meta: { name: 'causeofinjurydetail' } }
    /**
     * Find zero or one Causeofinjurydetail that matches the filter.
     * @param {causeofinjurydetailFindUniqueArgs} args - Arguments to find a Causeofinjurydetail
     * @example
     * // Get one Causeofinjurydetail
     * const causeofinjurydetail = await prisma.causeofinjurydetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends causeofinjurydetailFindUniqueArgs>(args: SelectSubset<T, causeofinjurydetailFindUniqueArgs<ExtArgs>>): Prisma__causeofinjurydetailClient<$Result.GetResult<Prisma.$causeofinjurydetailPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Causeofinjurydetail that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {causeofinjurydetailFindUniqueOrThrowArgs} args - Arguments to find a Causeofinjurydetail
     * @example
     * // Get one Causeofinjurydetail
     * const causeofinjurydetail = await prisma.causeofinjurydetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends causeofinjurydetailFindUniqueOrThrowArgs>(args: SelectSubset<T, causeofinjurydetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__causeofinjurydetailClient<$Result.GetResult<Prisma.$causeofinjurydetailPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Causeofinjurydetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {causeofinjurydetailFindFirstArgs} args - Arguments to find a Causeofinjurydetail
     * @example
     * // Get one Causeofinjurydetail
     * const causeofinjurydetail = await prisma.causeofinjurydetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends causeofinjurydetailFindFirstArgs>(args?: SelectSubset<T, causeofinjurydetailFindFirstArgs<ExtArgs>>): Prisma__causeofinjurydetailClient<$Result.GetResult<Prisma.$causeofinjurydetailPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Causeofinjurydetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {causeofinjurydetailFindFirstOrThrowArgs} args - Arguments to find a Causeofinjurydetail
     * @example
     * // Get one Causeofinjurydetail
     * const causeofinjurydetail = await prisma.causeofinjurydetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends causeofinjurydetailFindFirstOrThrowArgs>(args?: SelectSubset<T, causeofinjurydetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__causeofinjurydetailClient<$Result.GetResult<Prisma.$causeofinjurydetailPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Causeofinjurydetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {causeofinjurydetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Causeofinjurydetails
     * const causeofinjurydetails = await prisma.causeofinjurydetail.findMany()
     * 
     * // Get first 10 Causeofinjurydetails
     * const causeofinjurydetails = await prisma.causeofinjurydetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const causeofinjurydetailWithIdOnly = await prisma.causeofinjurydetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends causeofinjurydetailFindManyArgs>(args?: SelectSubset<T, causeofinjurydetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$causeofinjurydetailPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Causeofinjurydetail.
     * @param {causeofinjurydetailCreateArgs} args - Arguments to create a Causeofinjurydetail.
     * @example
     * // Create one Causeofinjurydetail
     * const Causeofinjurydetail = await prisma.causeofinjurydetail.create({
     *   data: {
     *     // ... data to create a Causeofinjurydetail
     *   }
     * })
     * 
     */
    create<T extends causeofinjurydetailCreateArgs>(args: SelectSubset<T, causeofinjurydetailCreateArgs<ExtArgs>>): Prisma__causeofinjurydetailClient<$Result.GetResult<Prisma.$causeofinjurydetailPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Causeofinjurydetails.
     * @param {causeofinjurydetailCreateManyArgs} args - Arguments to create many Causeofinjurydetails.
     * @example
     * // Create many Causeofinjurydetails
     * const causeofinjurydetail = await prisma.causeofinjurydetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends causeofinjurydetailCreateManyArgs>(args?: SelectSubset<T, causeofinjurydetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Causeofinjurydetails and returns the data saved in the database.
     * @param {causeofinjurydetailCreateManyAndReturnArgs} args - Arguments to create many Causeofinjurydetails.
     * @example
     * // Create many Causeofinjurydetails
     * const causeofinjurydetail = await prisma.causeofinjurydetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Causeofinjurydetails and only return the `id`
     * const causeofinjurydetailWithIdOnly = await prisma.causeofinjurydetail.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends causeofinjurydetailCreateManyAndReturnArgs>(args?: SelectSubset<T, causeofinjurydetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$causeofinjurydetailPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Causeofinjurydetail.
     * @param {causeofinjurydetailDeleteArgs} args - Arguments to delete one Causeofinjurydetail.
     * @example
     * // Delete one Causeofinjurydetail
     * const Causeofinjurydetail = await prisma.causeofinjurydetail.delete({
     *   where: {
     *     // ... filter to delete one Causeofinjurydetail
     *   }
     * })
     * 
     */
    delete<T extends causeofinjurydetailDeleteArgs>(args: SelectSubset<T, causeofinjurydetailDeleteArgs<ExtArgs>>): Prisma__causeofinjurydetailClient<$Result.GetResult<Prisma.$causeofinjurydetailPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Causeofinjurydetail.
     * @param {causeofinjurydetailUpdateArgs} args - Arguments to update one Causeofinjurydetail.
     * @example
     * // Update one Causeofinjurydetail
     * const causeofinjurydetail = await prisma.causeofinjurydetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends causeofinjurydetailUpdateArgs>(args: SelectSubset<T, causeofinjurydetailUpdateArgs<ExtArgs>>): Prisma__causeofinjurydetailClient<$Result.GetResult<Prisma.$causeofinjurydetailPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Causeofinjurydetails.
     * @param {causeofinjurydetailDeleteManyArgs} args - Arguments to filter Causeofinjurydetails to delete.
     * @example
     * // Delete a few Causeofinjurydetails
     * const { count } = await prisma.causeofinjurydetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends causeofinjurydetailDeleteManyArgs>(args?: SelectSubset<T, causeofinjurydetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Causeofinjurydetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {causeofinjurydetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Causeofinjurydetails
     * const causeofinjurydetail = await prisma.causeofinjurydetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends causeofinjurydetailUpdateManyArgs>(args: SelectSubset<T, causeofinjurydetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Causeofinjurydetail.
     * @param {causeofinjurydetailUpsertArgs} args - Arguments to update or create a Causeofinjurydetail.
     * @example
     * // Update or create a Causeofinjurydetail
     * const causeofinjurydetail = await prisma.causeofinjurydetail.upsert({
     *   create: {
     *     // ... data to create a Causeofinjurydetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Causeofinjurydetail we want to update
     *   }
     * })
     */
    upsert<T extends causeofinjurydetailUpsertArgs>(args: SelectSubset<T, causeofinjurydetailUpsertArgs<ExtArgs>>): Prisma__causeofinjurydetailClient<$Result.GetResult<Prisma.$causeofinjurydetailPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Causeofinjurydetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {causeofinjurydetailCountArgs} args - Arguments to filter Causeofinjurydetails to count.
     * @example
     * // Count the number of Causeofinjurydetails
     * const count = await prisma.causeofinjurydetail.count({
     *   where: {
     *     // ... the filter for the Causeofinjurydetails we want to count
     *   }
     * })
    **/
    count<T extends causeofinjurydetailCountArgs>(
      args?: Subset<T, causeofinjurydetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CauseofinjurydetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Causeofinjurydetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CauseofinjurydetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CauseofinjurydetailAggregateArgs>(args: Subset<T, CauseofinjurydetailAggregateArgs>): Prisma.PrismaPromise<GetCauseofinjurydetailAggregateType<T>>

    /**
     * Group by Causeofinjurydetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {causeofinjurydetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends causeofinjurydetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: causeofinjurydetailGroupByArgs['orderBy'] }
        : { orderBy?: causeofinjurydetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, causeofinjurydetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCauseofinjurydetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the causeofinjurydetail model
   */
  readonly fields: causeofinjurydetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for causeofinjurydetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__causeofinjurydetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accidenttransactions<T extends causeofinjurydetail$accidenttransactionsArgs<ExtArgs> = {}>(args?: Subset<T, causeofinjurydetail$accidenttransactionsArgs<ExtArgs>>): Prisma__accidenttransactionsClient<$Result.GetResult<Prisma.$accidenttransactionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the causeofinjurydetail model
   */ 
  interface causeofinjurydetailFieldRefs {
    readonly id: FieldRef<"causeofinjurydetail", 'Int'>
    readonly accidentid: FieldRef<"causeofinjurydetail", 'Int'>
    readonly causeofinjury: FieldRef<"causeofinjurydetail", 'String'>
    readonly commentofinjury: FieldRef<"causeofinjurydetail", 'String'>
  }
    

  // Custom InputTypes
  /**
   * causeofinjurydetail findUnique
   */
  export type causeofinjurydetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjurydetail
     */
    select?: causeofinjurydetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurydetailInclude<ExtArgs> | null
    /**
     * Filter, which causeofinjurydetail to fetch.
     */
    where: causeofinjurydetailWhereUniqueInput
  }

  /**
   * causeofinjurydetail findUniqueOrThrow
   */
  export type causeofinjurydetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjurydetail
     */
    select?: causeofinjurydetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurydetailInclude<ExtArgs> | null
    /**
     * Filter, which causeofinjurydetail to fetch.
     */
    where: causeofinjurydetailWhereUniqueInput
  }

  /**
   * causeofinjurydetail findFirst
   */
  export type causeofinjurydetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjurydetail
     */
    select?: causeofinjurydetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurydetailInclude<ExtArgs> | null
    /**
     * Filter, which causeofinjurydetail to fetch.
     */
    where?: causeofinjurydetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of causeofinjurydetails to fetch.
     */
    orderBy?: causeofinjurydetailOrderByWithRelationInput | causeofinjurydetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for causeofinjurydetails.
     */
    cursor?: causeofinjurydetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` causeofinjurydetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` causeofinjurydetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of causeofinjurydetails.
     */
    distinct?: CauseofinjurydetailScalarFieldEnum | CauseofinjurydetailScalarFieldEnum[]
  }

  /**
   * causeofinjurydetail findFirstOrThrow
   */
  export type causeofinjurydetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjurydetail
     */
    select?: causeofinjurydetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurydetailInclude<ExtArgs> | null
    /**
     * Filter, which causeofinjurydetail to fetch.
     */
    where?: causeofinjurydetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of causeofinjurydetails to fetch.
     */
    orderBy?: causeofinjurydetailOrderByWithRelationInput | causeofinjurydetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for causeofinjurydetails.
     */
    cursor?: causeofinjurydetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` causeofinjurydetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` causeofinjurydetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of causeofinjurydetails.
     */
    distinct?: CauseofinjurydetailScalarFieldEnum | CauseofinjurydetailScalarFieldEnum[]
  }

  /**
   * causeofinjurydetail findMany
   */
  export type causeofinjurydetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjurydetail
     */
    select?: causeofinjurydetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurydetailInclude<ExtArgs> | null
    /**
     * Filter, which causeofinjurydetails to fetch.
     */
    where?: causeofinjurydetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of causeofinjurydetails to fetch.
     */
    orderBy?: causeofinjurydetailOrderByWithRelationInput | causeofinjurydetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing causeofinjurydetails.
     */
    cursor?: causeofinjurydetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` causeofinjurydetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` causeofinjurydetails.
     */
    skip?: number
    distinct?: CauseofinjurydetailScalarFieldEnum | CauseofinjurydetailScalarFieldEnum[]
  }

  /**
   * causeofinjurydetail create
   */
  export type causeofinjurydetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjurydetail
     */
    select?: causeofinjurydetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurydetailInclude<ExtArgs> | null
    /**
     * The data needed to create a causeofinjurydetail.
     */
    data?: XOR<causeofinjurydetailCreateInput, causeofinjurydetailUncheckedCreateInput>
  }

  /**
   * causeofinjurydetail createMany
   */
  export type causeofinjurydetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many causeofinjurydetails.
     */
    data: causeofinjurydetailCreateManyInput | causeofinjurydetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * causeofinjurydetail createManyAndReturn
   */
  export type causeofinjurydetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjurydetail
     */
    select?: causeofinjurydetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many causeofinjurydetails.
     */
    data: causeofinjurydetailCreateManyInput | causeofinjurydetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurydetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * causeofinjurydetail update
   */
  export type causeofinjurydetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjurydetail
     */
    select?: causeofinjurydetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurydetailInclude<ExtArgs> | null
    /**
     * The data needed to update a causeofinjurydetail.
     */
    data: XOR<causeofinjurydetailUpdateInput, causeofinjurydetailUncheckedUpdateInput>
    /**
     * Choose, which causeofinjurydetail to update.
     */
    where: causeofinjurydetailWhereUniqueInput
  }

  /**
   * causeofinjurydetail updateMany
   */
  export type causeofinjurydetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update causeofinjurydetails.
     */
    data: XOR<causeofinjurydetailUpdateManyMutationInput, causeofinjurydetailUncheckedUpdateManyInput>
    /**
     * Filter which causeofinjurydetails to update
     */
    where?: causeofinjurydetailWhereInput
  }

  /**
   * causeofinjurydetail upsert
   */
  export type causeofinjurydetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjurydetail
     */
    select?: causeofinjurydetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurydetailInclude<ExtArgs> | null
    /**
     * The filter to search for the causeofinjurydetail to update in case it exists.
     */
    where: causeofinjurydetailWhereUniqueInput
    /**
     * In case the causeofinjurydetail found by the `where` argument doesn't exist, create a new causeofinjurydetail with this data.
     */
    create: XOR<causeofinjurydetailCreateInput, causeofinjurydetailUncheckedCreateInput>
    /**
     * In case the causeofinjurydetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<causeofinjurydetailUpdateInput, causeofinjurydetailUncheckedUpdateInput>
  }

  /**
   * causeofinjurydetail delete
   */
  export type causeofinjurydetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjurydetail
     */
    select?: causeofinjurydetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurydetailInclude<ExtArgs> | null
    /**
     * Filter which causeofinjurydetail to delete.
     */
    where: causeofinjurydetailWhereUniqueInput
  }

  /**
   * causeofinjurydetail deleteMany
   */
  export type causeofinjurydetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which causeofinjurydetails to delete
     */
    where?: causeofinjurydetailWhereInput
  }

  /**
   * causeofinjurydetail.accidenttransactions
   */
  export type causeofinjurydetail$accidenttransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidenttransactions
     */
    select?: accidenttransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidenttransactionsInclude<ExtArgs> | null
    where?: accidenttransactionsWhereInput
  }

  /**
   * causeofinjurydetail without action
   */
  export type causeofinjurydetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the causeofinjurydetail
     */
    select?: causeofinjurydetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: causeofinjurydetailInclude<ExtArgs> | null
  }


  /**
   * Model injurydetail
   */

  export type AggregateInjurydetail = {
    _count: InjurydetailCountAggregateOutputType | null
    _avg: InjurydetailAvgAggregateOutputType | null
    _sum: InjurydetailSumAggregateOutputType | null
    _min: InjurydetailMinAggregateOutputType | null
    _max: InjurydetailMaxAggregateOutputType | null
  }

  export type InjurydetailAvgAggregateOutputType = {
    id: number | null
    accidentid: number | null
  }

  export type InjurydetailSumAggregateOutputType = {
    id: number | null
    accidentid: number | null
  }

  export type InjurydetailMinAggregateOutputType = {
    id: number | null
    accidentid: number | null
    woundtype: string | null
    injuryside: string | null
    injuryarea: string | null
  }

  export type InjurydetailMaxAggregateOutputType = {
    id: number | null
    accidentid: number | null
    woundtype: string | null
    injuryside: string | null
    injuryarea: string | null
  }

  export type InjurydetailCountAggregateOutputType = {
    id: number
    accidentid: number
    woundtype: number
    injuryside: number
    injuryarea: number
    _all: number
  }


  export type InjurydetailAvgAggregateInputType = {
    id?: true
    accidentid?: true
  }

  export type InjurydetailSumAggregateInputType = {
    id?: true
    accidentid?: true
  }

  export type InjurydetailMinAggregateInputType = {
    id?: true
    accidentid?: true
    woundtype?: true
    injuryside?: true
    injuryarea?: true
  }

  export type InjurydetailMaxAggregateInputType = {
    id?: true
    accidentid?: true
    woundtype?: true
    injuryside?: true
    injuryarea?: true
  }

  export type InjurydetailCountAggregateInputType = {
    id?: true
    accidentid?: true
    woundtype?: true
    injuryside?: true
    injuryarea?: true
    _all?: true
  }

  export type InjurydetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which injurydetail to aggregate.
     */
    where?: injurydetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of injurydetails to fetch.
     */
    orderBy?: injurydetailOrderByWithRelationInput | injurydetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: injurydetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` injurydetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` injurydetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned injurydetails
    **/
    _count?: true | InjurydetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InjurydetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InjurydetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InjurydetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InjurydetailMaxAggregateInputType
  }

  export type GetInjurydetailAggregateType<T extends InjurydetailAggregateArgs> = {
        [P in keyof T & keyof AggregateInjurydetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInjurydetail[P]>
      : GetScalarType<T[P], AggregateInjurydetail[P]>
  }




  export type injurydetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: injurydetailWhereInput
    orderBy?: injurydetailOrderByWithAggregationInput | injurydetailOrderByWithAggregationInput[]
    by: InjurydetailScalarFieldEnum[] | InjurydetailScalarFieldEnum
    having?: injurydetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InjurydetailCountAggregateInputType | true
    _avg?: InjurydetailAvgAggregateInputType
    _sum?: InjurydetailSumAggregateInputType
    _min?: InjurydetailMinAggregateInputType
    _max?: InjurydetailMaxAggregateInputType
  }

  export type InjurydetailGroupByOutputType = {
    id: number
    accidentid: number | null
    woundtype: string | null
    injuryside: string | null
    injuryarea: string | null
    _count: InjurydetailCountAggregateOutputType | null
    _avg: InjurydetailAvgAggregateOutputType | null
    _sum: InjurydetailSumAggregateOutputType | null
    _min: InjurydetailMinAggregateOutputType | null
    _max: InjurydetailMaxAggregateOutputType | null
  }

  type GetInjurydetailGroupByPayload<T extends injurydetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InjurydetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InjurydetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InjurydetailGroupByOutputType[P]>
            : GetScalarType<T[P], InjurydetailGroupByOutputType[P]>
        }
      >
    >


  export type injurydetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accidentid?: boolean
    woundtype?: boolean
    injuryside?: boolean
    injuryarea?: boolean
    accidenttransactions?: boolean | injurydetail$accidenttransactionsArgs<ExtArgs>
  }, ExtArgs["result"]["injurydetail"]>

  export type injurydetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accidentid?: boolean
    woundtype?: boolean
    injuryside?: boolean
    injuryarea?: boolean
    accidenttransactions?: boolean | injurydetail$accidenttransactionsArgs<ExtArgs>
  }, ExtArgs["result"]["injurydetail"]>

  export type injurydetailSelectScalar = {
    id?: boolean
    accidentid?: boolean
    woundtype?: boolean
    injuryside?: boolean
    injuryarea?: boolean
  }

  export type injurydetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accidenttransactions?: boolean | injurydetail$accidenttransactionsArgs<ExtArgs>
  }
  export type injurydetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accidenttransactions?: boolean | injurydetail$accidenttransactionsArgs<ExtArgs>
  }

  export type $injurydetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "injurydetail"
    objects: {
      accidenttransactions: Prisma.$accidenttransactionsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      accidentid: number | null
      woundtype: string | null
      injuryside: string | null
      injuryarea: string | null
    }, ExtArgs["result"]["injurydetail"]>
    composites: {}
  }

  type injurydetailGetPayload<S extends boolean | null | undefined | injurydetailDefaultArgs> = $Result.GetResult<Prisma.$injurydetailPayload, S>

  type injurydetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<injurydetailFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InjurydetailCountAggregateInputType | true
    }

  export interface injurydetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['injurydetail'], meta: { name: 'injurydetail' } }
    /**
     * Find zero or one Injurydetail that matches the filter.
     * @param {injurydetailFindUniqueArgs} args - Arguments to find a Injurydetail
     * @example
     * // Get one Injurydetail
     * const injurydetail = await prisma.injurydetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends injurydetailFindUniqueArgs>(args: SelectSubset<T, injurydetailFindUniqueArgs<ExtArgs>>): Prisma__injurydetailClient<$Result.GetResult<Prisma.$injurydetailPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Injurydetail that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {injurydetailFindUniqueOrThrowArgs} args - Arguments to find a Injurydetail
     * @example
     * // Get one Injurydetail
     * const injurydetail = await prisma.injurydetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends injurydetailFindUniqueOrThrowArgs>(args: SelectSubset<T, injurydetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__injurydetailClient<$Result.GetResult<Prisma.$injurydetailPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Injurydetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {injurydetailFindFirstArgs} args - Arguments to find a Injurydetail
     * @example
     * // Get one Injurydetail
     * const injurydetail = await prisma.injurydetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends injurydetailFindFirstArgs>(args?: SelectSubset<T, injurydetailFindFirstArgs<ExtArgs>>): Prisma__injurydetailClient<$Result.GetResult<Prisma.$injurydetailPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Injurydetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {injurydetailFindFirstOrThrowArgs} args - Arguments to find a Injurydetail
     * @example
     * // Get one Injurydetail
     * const injurydetail = await prisma.injurydetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends injurydetailFindFirstOrThrowArgs>(args?: SelectSubset<T, injurydetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__injurydetailClient<$Result.GetResult<Prisma.$injurydetailPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Injurydetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {injurydetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Injurydetails
     * const injurydetails = await prisma.injurydetail.findMany()
     * 
     * // Get first 10 Injurydetails
     * const injurydetails = await prisma.injurydetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const injurydetailWithIdOnly = await prisma.injurydetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends injurydetailFindManyArgs>(args?: SelectSubset<T, injurydetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$injurydetailPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Injurydetail.
     * @param {injurydetailCreateArgs} args - Arguments to create a Injurydetail.
     * @example
     * // Create one Injurydetail
     * const Injurydetail = await prisma.injurydetail.create({
     *   data: {
     *     // ... data to create a Injurydetail
     *   }
     * })
     * 
     */
    create<T extends injurydetailCreateArgs>(args: SelectSubset<T, injurydetailCreateArgs<ExtArgs>>): Prisma__injurydetailClient<$Result.GetResult<Prisma.$injurydetailPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Injurydetails.
     * @param {injurydetailCreateManyArgs} args - Arguments to create many Injurydetails.
     * @example
     * // Create many Injurydetails
     * const injurydetail = await prisma.injurydetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends injurydetailCreateManyArgs>(args?: SelectSubset<T, injurydetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Injurydetails and returns the data saved in the database.
     * @param {injurydetailCreateManyAndReturnArgs} args - Arguments to create many Injurydetails.
     * @example
     * // Create many Injurydetails
     * const injurydetail = await prisma.injurydetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Injurydetails and only return the `id`
     * const injurydetailWithIdOnly = await prisma.injurydetail.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends injurydetailCreateManyAndReturnArgs>(args?: SelectSubset<T, injurydetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$injurydetailPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Injurydetail.
     * @param {injurydetailDeleteArgs} args - Arguments to delete one Injurydetail.
     * @example
     * // Delete one Injurydetail
     * const Injurydetail = await prisma.injurydetail.delete({
     *   where: {
     *     // ... filter to delete one Injurydetail
     *   }
     * })
     * 
     */
    delete<T extends injurydetailDeleteArgs>(args: SelectSubset<T, injurydetailDeleteArgs<ExtArgs>>): Prisma__injurydetailClient<$Result.GetResult<Prisma.$injurydetailPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Injurydetail.
     * @param {injurydetailUpdateArgs} args - Arguments to update one Injurydetail.
     * @example
     * // Update one Injurydetail
     * const injurydetail = await prisma.injurydetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends injurydetailUpdateArgs>(args: SelectSubset<T, injurydetailUpdateArgs<ExtArgs>>): Prisma__injurydetailClient<$Result.GetResult<Prisma.$injurydetailPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Injurydetails.
     * @param {injurydetailDeleteManyArgs} args - Arguments to filter Injurydetails to delete.
     * @example
     * // Delete a few Injurydetails
     * const { count } = await prisma.injurydetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends injurydetailDeleteManyArgs>(args?: SelectSubset<T, injurydetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Injurydetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {injurydetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Injurydetails
     * const injurydetail = await prisma.injurydetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends injurydetailUpdateManyArgs>(args: SelectSubset<T, injurydetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Injurydetail.
     * @param {injurydetailUpsertArgs} args - Arguments to update or create a Injurydetail.
     * @example
     * // Update or create a Injurydetail
     * const injurydetail = await prisma.injurydetail.upsert({
     *   create: {
     *     // ... data to create a Injurydetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Injurydetail we want to update
     *   }
     * })
     */
    upsert<T extends injurydetailUpsertArgs>(args: SelectSubset<T, injurydetailUpsertArgs<ExtArgs>>): Prisma__injurydetailClient<$Result.GetResult<Prisma.$injurydetailPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Injurydetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {injurydetailCountArgs} args - Arguments to filter Injurydetails to count.
     * @example
     * // Count the number of Injurydetails
     * const count = await prisma.injurydetail.count({
     *   where: {
     *     // ... the filter for the Injurydetails we want to count
     *   }
     * })
    **/
    count<T extends injurydetailCountArgs>(
      args?: Subset<T, injurydetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InjurydetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Injurydetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InjurydetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InjurydetailAggregateArgs>(args: Subset<T, InjurydetailAggregateArgs>): Prisma.PrismaPromise<GetInjurydetailAggregateType<T>>

    /**
     * Group by Injurydetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {injurydetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends injurydetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: injurydetailGroupByArgs['orderBy'] }
        : { orderBy?: injurydetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, injurydetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInjurydetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the injurydetail model
   */
  readonly fields: injurydetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for injurydetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__injurydetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accidenttransactions<T extends injurydetail$accidenttransactionsArgs<ExtArgs> = {}>(args?: Subset<T, injurydetail$accidenttransactionsArgs<ExtArgs>>): Prisma__accidenttransactionsClient<$Result.GetResult<Prisma.$accidenttransactionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the injurydetail model
   */ 
  interface injurydetailFieldRefs {
    readonly id: FieldRef<"injurydetail", 'Int'>
    readonly accidentid: FieldRef<"injurydetail", 'Int'>
    readonly woundtype: FieldRef<"injurydetail", 'String'>
    readonly injuryside: FieldRef<"injurydetail", 'String'>
    readonly injuryarea: FieldRef<"injurydetail", 'String'>
  }
    

  // Custom InputTypes
  /**
   * injurydetail findUnique
   */
  export type injurydetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the injurydetail
     */
    select?: injurydetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: injurydetailInclude<ExtArgs> | null
    /**
     * Filter, which injurydetail to fetch.
     */
    where: injurydetailWhereUniqueInput
  }

  /**
   * injurydetail findUniqueOrThrow
   */
  export type injurydetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the injurydetail
     */
    select?: injurydetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: injurydetailInclude<ExtArgs> | null
    /**
     * Filter, which injurydetail to fetch.
     */
    where: injurydetailWhereUniqueInput
  }

  /**
   * injurydetail findFirst
   */
  export type injurydetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the injurydetail
     */
    select?: injurydetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: injurydetailInclude<ExtArgs> | null
    /**
     * Filter, which injurydetail to fetch.
     */
    where?: injurydetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of injurydetails to fetch.
     */
    orderBy?: injurydetailOrderByWithRelationInput | injurydetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for injurydetails.
     */
    cursor?: injurydetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` injurydetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` injurydetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of injurydetails.
     */
    distinct?: InjurydetailScalarFieldEnum | InjurydetailScalarFieldEnum[]
  }

  /**
   * injurydetail findFirstOrThrow
   */
  export type injurydetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the injurydetail
     */
    select?: injurydetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: injurydetailInclude<ExtArgs> | null
    /**
     * Filter, which injurydetail to fetch.
     */
    where?: injurydetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of injurydetails to fetch.
     */
    orderBy?: injurydetailOrderByWithRelationInput | injurydetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for injurydetails.
     */
    cursor?: injurydetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` injurydetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` injurydetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of injurydetails.
     */
    distinct?: InjurydetailScalarFieldEnum | InjurydetailScalarFieldEnum[]
  }

  /**
   * injurydetail findMany
   */
  export type injurydetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the injurydetail
     */
    select?: injurydetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: injurydetailInclude<ExtArgs> | null
    /**
     * Filter, which injurydetails to fetch.
     */
    where?: injurydetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of injurydetails to fetch.
     */
    orderBy?: injurydetailOrderByWithRelationInput | injurydetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing injurydetails.
     */
    cursor?: injurydetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` injurydetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` injurydetails.
     */
    skip?: number
    distinct?: InjurydetailScalarFieldEnum | InjurydetailScalarFieldEnum[]
  }

  /**
   * injurydetail create
   */
  export type injurydetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the injurydetail
     */
    select?: injurydetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: injurydetailInclude<ExtArgs> | null
    /**
     * The data needed to create a injurydetail.
     */
    data?: XOR<injurydetailCreateInput, injurydetailUncheckedCreateInput>
  }

  /**
   * injurydetail createMany
   */
  export type injurydetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many injurydetails.
     */
    data: injurydetailCreateManyInput | injurydetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * injurydetail createManyAndReturn
   */
  export type injurydetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the injurydetail
     */
    select?: injurydetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many injurydetails.
     */
    data: injurydetailCreateManyInput | injurydetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: injurydetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * injurydetail update
   */
  export type injurydetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the injurydetail
     */
    select?: injurydetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: injurydetailInclude<ExtArgs> | null
    /**
     * The data needed to update a injurydetail.
     */
    data: XOR<injurydetailUpdateInput, injurydetailUncheckedUpdateInput>
    /**
     * Choose, which injurydetail to update.
     */
    where: injurydetailWhereUniqueInput
  }

  /**
   * injurydetail updateMany
   */
  export type injurydetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update injurydetails.
     */
    data: XOR<injurydetailUpdateManyMutationInput, injurydetailUncheckedUpdateManyInput>
    /**
     * Filter which injurydetails to update
     */
    where?: injurydetailWhereInput
  }

  /**
   * injurydetail upsert
   */
  export type injurydetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the injurydetail
     */
    select?: injurydetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: injurydetailInclude<ExtArgs> | null
    /**
     * The filter to search for the injurydetail to update in case it exists.
     */
    where: injurydetailWhereUniqueInput
    /**
     * In case the injurydetail found by the `where` argument doesn't exist, create a new injurydetail with this data.
     */
    create: XOR<injurydetailCreateInput, injurydetailUncheckedCreateInput>
    /**
     * In case the injurydetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<injurydetailUpdateInput, injurydetailUncheckedUpdateInput>
  }

  /**
   * injurydetail delete
   */
  export type injurydetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the injurydetail
     */
    select?: injurydetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: injurydetailInclude<ExtArgs> | null
    /**
     * Filter which injurydetail to delete.
     */
    where: injurydetailWhereUniqueInput
  }

  /**
   * injurydetail deleteMany
   */
  export type injurydetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which injurydetails to delete
     */
    where?: injurydetailWhereInput
  }

  /**
   * injurydetail.accidenttransactions
   */
  export type injurydetail$accidenttransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accidenttransactions
     */
    select?: accidenttransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accidenttransactionsInclude<ExtArgs> | null
    where?: accidenttransactionsWhereInput
  }

  /**
   * injurydetail without action
   */
  export type injurydetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the injurydetail
     */
    select?: injurydetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: injurydetailInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Accidentcauseover45daysScalarFieldEnum: {
    id: 'id',
    causeovercode: 'causeovercode',
    causeoverdesc: 'causeoverdesc',
    insurerid: 'insurerid'
  };

  export type Accidentcauseover45daysScalarFieldEnum = (typeof Accidentcauseover45daysScalarFieldEnum)[keyof typeof Accidentcauseover45daysScalarFieldEnum]


  export const AccidentplaceScalarFieldEnum: {
    id: 'id',
    accidentplacecode: 'accidentplacecode',
    accidentplacename: 'accidentplacename',
    insurerid: 'insurerid'
  };

  export type AccidentplaceScalarFieldEnum = (typeof AccidentplaceScalarFieldEnum)[keyof typeof AccidentplaceScalarFieldEnum]


  export const CauseofinjurysideScalarFieldEnum: {
    id: 'id',
    injurysidename: 'injurysidename',
    injurysidecode: 'injurysidecode',
    insurerid: 'insurerid'
  };

  export type CauseofinjurysideScalarFieldEnum = (typeof CauseofinjurysideScalarFieldEnum)[keyof typeof CauseofinjurysideScalarFieldEnum]


  export const CauseofinjurywoundtypeScalarFieldEnum: {
    id: 'id',
    woundtypename: 'woundtypename',
    woundtypecode: 'woundtypecode',
    insurerid: 'insurerid'
  };

  export type CauseofinjurywoundtypeScalarFieldEnum = (typeof CauseofinjurywoundtypeScalarFieldEnum)[keyof typeof CauseofinjurywoundtypeScalarFieldEnum]


  export const ClaimantsScalarFieldEnum: {
    id: 'id',
    national_id: 'national_id',
    passportnumber: 'passportnumber',
    hn: 'hn',
    patientid: 'patientid',
    title_th: 'title_th',
    givenname_th: 'givenname_th',
    surname_th: 'surname_th',
    title_en: 'title_en',
    givenname_en: 'givenname_en',
    surname_en: 'surname_en',
    mobilephone: 'mobilephone',
    statusactive: 'statusactive',
    dateofbirth: 'dateofbirth',
    gender: 'gender',
    registrationdate: 'registrationdate',
    insurerid: 'insurerid'
  };

  export type ClaimantsScalarFieldEnum = (typeof ClaimantsScalarFieldEnum)[keyof typeof ClaimantsScalarFieldEnum]


  export const ClaimdocumentsScalarFieldEnum: {
    id: 'id',
    insurerid: 'insurerid',
    refid: 'refid',
    transactionno: 'transactionno',
    hn: 'hn',
    vn: 'vn',
    documentname: 'documentname',
    documenttypecode: 'documenttypecode',
    documenttypename: 'documenttypename',
    serverpath: 'serverpath',
    filepath: 'filepath',
    filesize: 'filesize',
    filemimetype: 'filemimetype',
    uploaddate: 'uploaddate',
    uploadedby: 'uploadedby'
  };

  export type ClaimdocumentsScalarFieldEnum = (typeof ClaimdocumentsScalarFieldEnum)[keyof typeof ClaimdocumentsScalarFieldEnum]


  export const ClaimstatusScalarFieldEnum: {
    id: 'id',
    claimstatuscode: 'claimstatuscode',
    claimstatusdesc_th: 'claimstatusdesc_th',
    claimstatusdesc_en: 'claimstatusdesc_en',
    insurerid: 'insurerid'
  };

  export type ClaimstatusScalarFieldEnum = (typeof ClaimstatusScalarFieldEnum)[keyof typeof ClaimstatusScalarFieldEnum]


  export const DiagnosistypemappingScalarFieldEnum: {
    id: 'id',
    dxtypecodetrakcare: 'dxtypecodetrakcare',
    dxtypenametrakcare: 'dxtypenametrakcare',
    dxtypecodeinsurance: 'dxtypecodeinsurance',
    dxtypenameinsurance: 'dxtypenameinsurance',
    insurerid: 'insurerid'
  };

  export type DiagnosistypemappingScalarFieldEnum = (typeof DiagnosistypemappingScalarFieldEnum)[keyof typeof DiagnosistypemappingScalarFieldEnum]


  export const DocumenttypeScalarFieldEnum: {
    id: 'id',
    documenttypecode: 'documenttypecode',
    documenttypename: 'documenttypename',
    insurerid: 'insurerid'
  };

  export type DocumenttypeScalarFieldEnum = (typeof DocumenttypeScalarFieldEnum)[keyof typeof DocumenttypeScalarFieldEnum]


  export const IllnesssurgeryScalarFieldEnum: {
    id: 'id',
    iscode: 'iscode',
    isdesc: 'isdesc',
    insurerid: 'insurerid'
  };

  export type IllnesssurgeryScalarFieldEnum = (typeof IllnesssurgeryScalarFieldEnum)[keyof typeof IllnesssurgeryScalarFieldEnum]


  export const IllnesstypeScalarFieldEnum: {
    id: 'id',
    illnesstypecode: 'illnesstypecode',
    illnesstypedesc: 'illnesstypedesc',
    insurerid: 'insurerid'
  };

  export type IllnesstypeScalarFieldEnum = (typeof IllnesstypeScalarFieldEnum)[keyof typeof IllnesstypeScalarFieldEnum]


  export const InsurersScalarFieldEnum: {
    id: 'id',
    insurerid: 'insurerid',
    insurercode: 'insurercode',
    insurername: 'insurername'
  };

  export type InsurersScalarFieldEnum = (typeof InsurersScalarFieldEnum)[keyof typeof InsurersScalarFieldEnum]


  export const MedicaltransactionsScalarFieldEnum: {
    id: 'id',
    insurerid: 'insurerid',
    refid: 'refid',
    transactionno: 'transactionno',
    hn: 'hn',
    vn: 'vn',
    dxfreetext: 'dxfreetext',
    presentillness: 'presentillness',
    chiefcomplaint: 'chiefcomplaint',
    accidentcauseover45days: 'accidentcauseover45days',
    underlyingcondition: 'underlyingcondition',
    physicalexam: 'physicalexam',
    planoftreatment: 'planoftreatment',
    procedurefreetext: 'procedurefreetext',
    additionalnote: 'additionalnote',
    signsymptomsdate: 'signsymptomsdate',
    comascore: 'comascore',
    expecteddayofrecovery: 'expecteddayofrecovery',
    pregnant: 'pregnant',
    alcoholrelated: 'alcoholrelated',
    haveaccidentinjurydetail: 'haveaccidentinjurydetail',
    haveaccidentcauseofinjurydetail: 'haveaccidentcauseofinjurydetail',
    haveprocedure: 'haveprocedure',
    privatecase: 'privatecase'
  };

  export type MedicaltransactionsScalarFieldEnum = (typeof MedicaltransactionsScalarFieldEnum)[keyof typeof MedicaltransactionsScalarFieldEnum]


  export const PolicytypeScalarFieldEnum: {
    id: 'id',
    policytypecode: 'policytypecode',
    policytypedesc: 'policytypedesc',
    insurerid: 'insurerid'
  };

  export type PolicytypeScalarFieldEnum = (typeof PolicytypeScalarFieldEnum)[keyof typeof PolicytypeScalarFieldEnum]


  export const ServicesettingScalarFieldEnum: {
    id: 'id',
    servicesettingcode: 'servicesettingcode',
    servicesettingdesc: 'servicesettingdesc',
    insurerid: 'insurerid'
  };

  export type ServicesettingScalarFieldEnum = (typeof ServicesettingScalarFieldEnum)[keyof typeof ServicesettingScalarFieldEnum]


  export const TransactionclaimScalarFieldEnum: {
    id: 'id',
    insurerid: 'insurerid',
    refid: 'refid',
    transactionno: 'transactionno',
    hn: 'hn',
    vn: 'vn',
    visitdate: 'visitdate',
    accidentdate: 'accidentdate',
    messageclaim: 'messageclaim',
    messageth: 'messageth',
    claimno: 'claimno',
    claimstatuscode: 'claimstatuscode',
    status_changed_at: 'status_changed_at',
    occurrenceno: 'occurrenceno',
    totalapprovedamount: 'totalapprovedamount',
    totalexcessamount: 'totalexcessamount',
    isreimbursement: 'isreimbursement',
    batchnumber: 'batchnumber',
    invoicenumber: 'invoicenumber',
    otherinsurer: 'otherinsurer',
    furtherclaimid: 'furtherclaimid',
    furtherclaimno: 'furtherclaimno',
    privatecase: 'privatecase',
    previoustreatmentdate: 'previoustreatmentdate',
    previoustreatmentdetail: 'previoustreatmentdetail'
  };

  export type TransactionclaimScalarFieldEnum = (typeof TransactionclaimScalarFieldEnum)[keyof typeof TransactionclaimScalarFieldEnum]


  export const TransactionclaimstatusScalarFieldEnum: {
    id: 'id',
    insurerid: 'insurerid',
    refid: 'refid',
    transactionno: 'transactionno',
    hn: 'hn',
    vn: 'vn',
    batchnumber: 'batchnumber',
    claimno: 'claimno',
    invoicenumber: 'invoicenumber',
    status_changed_at: 'status_changed_at',
    note: 'note',
    totalapproveamount: 'totalapproveamount',
    paymentdate: 'paymentdate',
    claimstatuscode: 'claimstatuscode'
  };

  export type TransactionclaimstatusScalarFieldEnum = (typeof TransactionclaimstatusScalarFieldEnum)[keyof typeof TransactionclaimstatusScalarFieldEnum]


  export const AccidenttransactionsScalarFieldEnum: {
    id: 'id',
    insurerid: 'insurerid',
    refid: 'refid',
    transactionno: 'transactionno',
    hn: 'hn',
    vn: 'vn',
    accidentplace: 'accidentplace',
    accidentdate: 'accidentdate'
  };

  export type AccidenttransactionsScalarFieldEnum = (typeof AccidenttransactionsScalarFieldEnum)[keyof typeof AccidenttransactionsScalarFieldEnum]


  export const ProceduretransactionsScalarFieldEnum: {
    id: 'id',
    insurerid: 'insurerid',
    refid: 'refid',
    transactionno: 'transactionno',
    hn: 'hn',
    vn: 'vn',
    icd9: 'icd9',
    procedurename: 'procedurename',
    proceduredate: 'proceduredate'
  };

  export type ProceduretransactionsScalarFieldEnum = (typeof ProceduretransactionsScalarFieldEnum)[keyof typeof ProceduretransactionsScalarFieldEnum]


  export const Accidenttransactions22ScalarFieldEnum: {
    id: 'id',
    insurerid: 'insurerid',
    refid: 'refid',
    transactionno: 'transactionno',
    hn: 'hn',
    vn: 'vn',
    accidentplace: 'accidentplace',
    accidentdate: 'accidentdate',
    causeofinjury: 'causeofinjury',
    commentofinjury: 'commentofinjury',
    woundtype: 'woundtype',
    injuryside: 'injuryside',
    injuryarea: 'injuryarea'
  };

  export type Accidenttransactions22ScalarFieldEnum = (typeof Accidenttransactions22ScalarFieldEnum)[keyof typeof Accidenttransactions22ScalarFieldEnum]


  export const CauseofinjurydetailScalarFieldEnum: {
    id: 'id',
    accidentid: 'accidentid',
    causeofinjury: 'causeofinjury',
    commentofinjury: 'commentofinjury'
  };

  export type CauseofinjurydetailScalarFieldEnum = (typeof CauseofinjurydetailScalarFieldEnum)[keyof typeof CauseofinjurydetailScalarFieldEnum]


  export const InjurydetailScalarFieldEnum: {
    id: 'id',
    accidentid: 'accidentid',
    woundtype: 'woundtype',
    injuryside: 'injuryside',
    injuryarea: 'injuryarea'
  };

  export type InjurydetailScalarFieldEnum = (typeof InjurydetailScalarFieldEnum)[keyof typeof InjurydetailScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type accidentcauseover45daysWhereInput = {
    AND?: accidentcauseover45daysWhereInput | accidentcauseover45daysWhereInput[]
    OR?: accidentcauseover45daysWhereInput[]
    NOT?: accidentcauseover45daysWhereInput | accidentcauseover45daysWhereInput[]
    id?: IntFilter<"accidentcauseover45days"> | number
    causeovercode?: StringFilter<"accidentcauseover45days"> | string
    causeoverdesc?: StringNullableFilter<"accidentcauseover45days"> | string | null
    insurerid?: IntNullableFilter<"accidentcauseover45days"> | number | null
    insurers?: XOR<InsurersNullableRelationFilter, insurersWhereInput> | null
  }

  export type accidentcauseover45daysOrderByWithRelationInput = {
    id?: SortOrder
    causeovercode?: SortOrder
    causeoverdesc?: SortOrderInput | SortOrder
    insurerid?: SortOrderInput | SortOrder
    insurers?: insurersOrderByWithRelationInput
  }

  export type accidentcauseover45daysWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: accidentcauseover45daysWhereInput | accidentcauseover45daysWhereInput[]
    OR?: accidentcauseover45daysWhereInput[]
    NOT?: accidentcauseover45daysWhereInput | accidentcauseover45daysWhereInput[]
    causeovercode?: StringFilter<"accidentcauseover45days"> | string
    causeoverdesc?: StringNullableFilter<"accidentcauseover45days"> | string | null
    insurerid?: IntNullableFilter<"accidentcauseover45days"> | number | null
    insurers?: XOR<InsurersNullableRelationFilter, insurersWhereInput> | null
  }, "id">

  export type accidentcauseover45daysOrderByWithAggregationInput = {
    id?: SortOrder
    causeovercode?: SortOrder
    causeoverdesc?: SortOrderInput | SortOrder
    insurerid?: SortOrderInput | SortOrder
    _count?: accidentcauseover45daysCountOrderByAggregateInput
    _avg?: accidentcauseover45daysAvgOrderByAggregateInput
    _max?: accidentcauseover45daysMaxOrderByAggregateInput
    _min?: accidentcauseover45daysMinOrderByAggregateInput
    _sum?: accidentcauseover45daysSumOrderByAggregateInput
  }

  export type accidentcauseover45daysScalarWhereWithAggregatesInput = {
    AND?: accidentcauseover45daysScalarWhereWithAggregatesInput | accidentcauseover45daysScalarWhereWithAggregatesInput[]
    OR?: accidentcauseover45daysScalarWhereWithAggregatesInput[]
    NOT?: accidentcauseover45daysScalarWhereWithAggregatesInput | accidentcauseover45daysScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"accidentcauseover45days"> | number
    causeovercode?: StringWithAggregatesFilter<"accidentcauseover45days"> | string
    causeoverdesc?: StringNullableWithAggregatesFilter<"accidentcauseover45days"> | string | null
    insurerid?: IntNullableWithAggregatesFilter<"accidentcauseover45days"> | number | null
  }

  export type accidentplaceWhereInput = {
    AND?: accidentplaceWhereInput | accidentplaceWhereInput[]
    OR?: accidentplaceWhereInput[]
    NOT?: accidentplaceWhereInput | accidentplaceWhereInput[]
    id?: IntFilter<"accidentplace"> | number
    accidentplacecode?: StringFilter<"accidentplace"> | string
    accidentplacename?: StringNullableFilter<"accidentplace"> | string | null
    insurerid?: IntNullableFilter<"accidentplace"> | number | null
    insurers?: XOR<InsurersNullableRelationFilter, insurersWhereInput> | null
  }

  export type accidentplaceOrderByWithRelationInput = {
    id?: SortOrder
    accidentplacecode?: SortOrder
    accidentplacename?: SortOrderInput | SortOrder
    insurerid?: SortOrderInput | SortOrder
    insurers?: insurersOrderByWithRelationInput
  }

  export type accidentplaceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: accidentplaceWhereInput | accidentplaceWhereInput[]
    OR?: accidentplaceWhereInput[]
    NOT?: accidentplaceWhereInput | accidentplaceWhereInput[]
    accidentplacecode?: StringFilter<"accidentplace"> | string
    accidentplacename?: StringNullableFilter<"accidentplace"> | string | null
    insurerid?: IntNullableFilter<"accidentplace"> | number | null
    insurers?: XOR<InsurersNullableRelationFilter, insurersWhereInput> | null
  }, "id">

  export type accidentplaceOrderByWithAggregationInput = {
    id?: SortOrder
    accidentplacecode?: SortOrder
    accidentplacename?: SortOrderInput | SortOrder
    insurerid?: SortOrderInput | SortOrder
    _count?: accidentplaceCountOrderByAggregateInput
    _avg?: accidentplaceAvgOrderByAggregateInput
    _max?: accidentplaceMaxOrderByAggregateInput
    _min?: accidentplaceMinOrderByAggregateInput
    _sum?: accidentplaceSumOrderByAggregateInput
  }

  export type accidentplaceScalarWhereWithAggregatesInput = {
    AND?: accidentplaceScalarWhereWithAggregatesInput | accidentplaceScalarWhereWithAggregatesInput[]
    OR?: accidentplaceScalarWhereWithAggregatesInput[]
    NOT?: accidentplaceScalarWhereWithAggregatesInput | accidentplaceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"accidentplace"> | number
    accidentplacecode?: StringWithAggregatesFilter<"accidentplace"> | string
    accidentplacename?: StringNullableWithAggregatesFilter<"accidentplace"> | string | null
    insurerid?: IntNullableWithAggregatesFilter<"accidentplace"> | number | null
  }

  export type causeofinjurysideWhereInput = {
    AND?: causeofinjurysideWhereInput | causeofinjurysideWhereInput[]
    OR?: causeofinjurysideWhereInput[]
    NOT?: causeofinjurysideWhereInput | causeofinjurysideWhereInput[]
    id?: IntFilter<"causeofinjuryside"> | number
    injurysidename?: StringFilter<"causeofinjuryside"> | string
    injurysidecode?: StringNullableFilter<"causeofinjuryside"> | string | null
    insurerid?: IntNullableFilter<"causeofinjuryside"> | number | null
    insurers?: XOR<InsurersNullableRelationFilter, insurersWhereInput> | null
  }

  export type causeofinjurysideOrderByWithRelationInput = {
    id?: SortOrder
    injurysidename?: SortOrder
    injurysidecode?: SortOrderInput | SortOrder
    insurerid?: SortOrderInput | SortOrder
    insurers?: insurersOrderByWithRelationInput
  }

  export type causeofinjurysideWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: causeofinjurysideWhereInput | causeofinjurysideWhereInput[]
    OR?: causeofinjurysideWhereInput[]
    NOT?: causeofinjurysideWhereInput | causeofinjurysideWhereInput[]
    injurysidename?: StringFilter<"causeofinjuryside"> | string
    injurysidecode?: StringNullableFilter<"causeofinjuryside"> | string | null
    insurerid?: IntNullableFilter<"causeofinjuryside"> | number | null
    insurers?: XOR<InsurersNullableRelationFilter, insurersWhereInput> | null
  }, "id">

  export type causeofinjurysideOrderByWithAggregationInput = {
    id?: SortOrder
    injurysidename?: SortOrder
    injurysidecode?: SortOrderInput | SortOrder
    insurerid?: SortOrderInput | SortOrder
    _count?: causeofinjurysideCountOrderByAggregateInput
    _avg?: causeofinjurysideAvgOrderByAggregateInput
    _max?: causeofinjurysideMaxOrderByAggregateInput
    _min?: causeofinjurysideMinOrderByAggregateInput
    _sum?: causeofinjurysideSumOrderByAggregateInput
  }

  export type causeofinjurysideScalarWhereWithAggregatesInput = {
    AND?: causeofinjurysideScalarWhereWithAggregatesInput | causeofinjurysideScalarWhereWithAggregatesInput[]
    OR?: causeofinjurysideScalarWhereWithAggregatesInput[]
    NOT?: causeofinjurysideScalarWhereWithAggregatesInput | causeofinjurysideScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"causeofinjuryside"> | number
    injurysidename?: StringWithAggregatesFilter<"causeofinjuryside"> | string
    injurysidecode?: StringNullableWithAggregatesFilter<"causeofinjuryside"> | string | null
    insurerid?: IntNullableWithAggregatesFilter<"causeofinjuryside"> | number | null
  }

  export type causeofinjurywoundtypeWhereInput = {
    AND?: causeofinjurywoundtypeWhereInput | causeofinjurywoundtypeWhereInput[]
    OR?: causeofinjurywoundtypeWhereInput[]
    NOT?: causeofinjurywoundtypeWhereInput | causeofinjurywoundtypeWhereInput[]
    id?: IntFilter<"causeofinjurywoundtype"> | number
    woundtypename?: StringFilter<"causeofinjurywoundtype"> | string
    woundtypecode?: StringNullableFilter<"causeofinjurywoundtype"> | string | null
    insurerid?: IntNullableFilter<"causeofinjurywoundtype"> | number | null
    insurers?: XOR<InsurersNullableRelationFilter, insurersWhereInput> | null
  }

  export type causeofinjurywoundtypeOrderByWithRelationInput = {
    id?: SortOrder
    woundtypename?: SortOrder
    woundtypecode?: SortOrderInput | SortOrder
    insurerid?: SortOrderInput | SortOrder
    insurers?: insurersOrderByWithRelationInput
  }

  export type causeofinjurywoundtypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: causeofinjurywoundtypeWhereInput | causeofinjurywoundtypeWhereInput[]
    OR?: causeofinjurywoundtypeWhereInput[]
    NOT?: causeofinjurywoundtypeWhereInput | causeofinjurywoundtypeWhereInput[]
    woundtypename?: StringFilter<"causeofinjurywoundtype"> | string
    woundtypecode?: StringNullableFilter<"causeofinjurywoundtype"> | string | null
    insurerid?: IntNullableFilter<"causeofinjurywoundtype"> | number | null
    insurers?: XOR<InsurersNullableRelationFilter, insurersWhereInput> | null
  }, "id">

  export type causeofinjurywoundtypeOrderByWithAggregationInput = {
    id?: SortOrder
    woundtypename?: SortOrder
    woundtypecode?: SortOrderInput | SortOrder
    insurerid?: SortOrderInput | SortOrder
    _count?: causeofinjurywoundtypeCountOrderByAggregateInput
    _avg?: causeofinjurywoundtypeAvgOrderByAggregateInput
    _max?: causeofinjurywoundtypeMaxOrderByAggregateInput
    _min?: causeofinjurywoundtypeMinOrderByAggregateInput
    _sum?: causeofinjurywoundtypeSumOrderByAggregateInput
  }

  export type causeofinjurywoundtypeScalarWhereWithAggregatesInput = {
    AND?: causeofinjurywoundtypeScalarWhereWithAggregatesInput | causeofinjurywoundtypeScalarWhereWithAggregatesInput[]
    OR?: causeofinjurywoundtypeScalarWhereWithAggregatesInput[]
    NOT?: causeofinjurywoundtypeScalarWhereWithAggregatesInput | causeofinjurywoundtypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"causeofinjurywoundtype"> | number
    woundtypename?: StringWithAggregatesFilter<"causeofinjurywoundtype"> | string
    woundtypecode?: StringNullableWithAggregatesFilter<"causeofinjurywoundtype"> | string | null
    insurerid?: IntNullableWithAggregatesFilter<"causeofinjurywoundtype"> | number | null
  }

  export type claimantsWhereInput = {
    AND?: claimantsWhereInput | claimantsWhereInput[]
    OR?: claimantsWhereInput[]
    NOT?: claimantsWhereInput | claimantsWhereInput[]
    id?: IntFilter<"claimants"> | number
    national_id?: StringNullableFilter<"claimants"> | string | null
    passportnumber?: StringNullableFilter<"claimants"> | string | null
    hn?: StringNullableFilter<"claimants"> | string | null
    patientid?: IntNullableFilter<"claimants"> | number | null
    title_th?: StringNullableFilter<"claimants"> | string | null
    givenname_th?: StringNullableFilter<"claimants"> | string | null
    surname_th?: StringNullableFilter<"claimants"> | string | null
    title_en?: StringNullableFilter<"claimants"> | string | null
    givenname_en?: StringNullableFilter<"claimants"> | string | null
    surname_en?: StringNullableFilter<"claimants"> | string | null
    mobilephone?: StringNullableFilter<"claimants"> | string | null
    statusactive?: BoolNullableFilter<"claimants"> | boolean | null
    dateofbirth?: StringNullableFilter<"claimants"> | string | null
    gender?: StringNullableFilter<"claimants"> | string | null
    registrationdate?: DateTimeNullableFilter<"claimants"> | Date | string | null
    insurerid?: IntNullableFilter<"claimants"> | number | null
    insurers?: XOR<InsurersNullableRelationFilter, insurersWhereInput> | null
  }

  export type claimantsOrderByWithRelationInput = {
    id?: SortOrder
    national_id?: SortOrderInput | SortOrder
    passportnumber?: SortOrderInput | SortOrder
    hn?: SortOrderInput | SortOrder
    patientid?: SortOrderInput | SortOrder
    title_th?: SortOrderInput | SortOrder
    givenname_th?: SortOrderInput | SortOrder
    surname_th?: SortOrderInput | SortOrder
    title_en?: SortOrderInput | SortOrder
    givenname_en?: SortOrderInput | SortOrder
    surname_en?: SortOrderInput | SortOrder
    mobilephone?: SortOrderInput | SortOrder
    statusactive?: SortOrderInput | SortOrder
    dateofbirth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    registrationdate?: SortOrderInput | SortOrder
    insurerid?: SortOrderInput | SortOrder
    insurers?: insurersOrderByWithRelationInput
  }

  export type claimantsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    hn_insurerid?: claimantsHnInsureridCompoundUniqueInput
    AND?: claimantsWhereInput | claimantsWhereInput[]
    OR?: claimantsWhereInput[]
    NOT?: claimantsWhereInput | claimantsWhereInput[]
    national_id?: StringNullableFilter<"claimants"> | string | null
    passportnumber?: StringNullableFilter<"claimants"> | string | null
    hn?: StringNullableFilter<"claimants"> | string | null
    patientid?: IntNullableFilter<"claimants"> | number | null
    title_th?: StringNullableFilter<"claimants"> | string | null
    givenname_th?: StringNullableFilter<"claimants"> | string | null
    surname_th?: StringNullableFilter<"claimants"> | string | null
    title_en?: StringNullableFilter<"claimants"> | string | null
    givenname_en?: StringNullableFilter<"claimants"> | string | null
    surname_en?: StringNullableFilter<"claimants"> | string | null
    mobilephone?: StringNullableFilter<"claimants"> | string | null
    statusactive?: BoolNullableFilter<"claimants"> | boolean | null
    dateofbirth?: StringNullableFilter<"claimants"> | string | null
    gender?: StringNullableFilter<"claimants"> | string | null
    registrationdate?: DateTimeNullableFilter<"claimants"> | Date | string | null
    insurerid?: IntNullableFilter<"claimants"> | number | null
    insurers?: XOR<InsurersNullableRelationFilter, insurersWhereInput> | null
  }, "id" | "hn_insurerid">

  export type claimantsOrderByWithAggregationInput = {
    id?: SortOrder
    national_id?: SortOrderInput | SortOrder
    passportnumber?: SortOrderInput | SortOrder
    hn?: SortOrderInput | SortOrder
    patientid?: SortOrderInput | SortOrder
    title_th?: SortOrderInput | SortOrder
    givenname_th?: SortOrderInput | SortOrder
    surname_th?: SortOrderInput | SortOrder
    title_en?: SortOrderInput | SortOrder
    givenname_en?: SortOrderInput | SortOrder
    surname_en?: SortOrderInput | SortOrder
    mobilephone?: SortOrderInput | SortOrder
    statusactive?: SortOrderInput | SortOrder
    dateofbirth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    registrationdate?: SortOrderInput | SortOrder
    insurerid?: SortOrderInput | SortOrder
    _count?: claimantsCountOrderByAggregateInput
    _avg?: claimantsAvgOrderByAggregateInput
    _max?: claimantsMaxOrderByAggregateInput
    _min?: claimantsMinOrderByAggregateInput
    _sum?: claimantsSumOrderByAggregateInput
  }

  export type claimantsScalarWhereWithAggregatesInput = {
    AND?: claimantsScalarWhereWithAggregatesInput | claimantsScalarWhereWithAggregatesInput[]
    OR?: claimantsScalarWhereWithAggregatesInput[]
    NOT?: claimantsScalarWhereWithAggregatesInput | claimantsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"claimants"> | number
    national_id?: StringNullableWithAggregatesFilter<"claimants"> | string | null
    passportnumber?: StringNullableWithAggregatesFilter<"claimants"> | string | null
    hn?: StringNullableWithAggregatesFilter<"claimants"> | string | null
    patientid?: IntNullableWithAggregatesFilter<"claimants"> | number | null
    title_th?: StringNullableWithAggregatesFilter<"claimants"> | string | null
    givenname_th?: StringNullableWithAggregatesFilter<"claimants"> | string | null
    surname_th?: StringNullableWithAggregatesFilter<"claimants"> | string | null
    title_en?: StringNullableWithAggregatesFilter<"claimants"> | string | null
    givenname_en?: StringNullableWithAggregatesFilter<"claimants"> | string | null
    surname_en?: StringNullableWithAggregatesFilter<"claimants"> | string | null
    mobilephone?: StringNullableWithAggregatesFilter<"claimants"> | string | null
    statusactive?: BoolNullableWithAggregatesFilter<"claimants"> | boolean | null
    dateofbirth?: StringNullableWithAggregatesFilter<"claimants"> | string | null
    gender?: StringNullableWithAggregatesFilter<"claimants"> | string | null
    registrationdate?: DateTimeNullableWithAggregatesFilter<"claimants"> | Date | string | null
    insurerid?: IntNullableWithAggregatesFilter<"claimants"> | number | null
  }

  export type claimdocumentsWhereInput = {
    AND?: claimdocumentsWhereInput | claimdocumentsWhereInput[]
    OR?: claimdocumentsWhereInput[]
    NOT?: claimdocumentsWhereInput | claimdocumentsWhereInput[]
    id?: IntFilter<"claimdocuments"> | number
    insurerid?: IntNullableFilter<"claimdocuments"> | number | null
    refid?: StringNullableFilter<"claimdocuments"> | string | null
    transactionno?: StringNullableFilter<"claimdocuments"> | string | null
    hn?: StringNullableFilter<"claimdocuments"> | string | null
    vn?: StringNullableFilter<"claimdocuments"> | string | null
    documentname?: StringNullableFilter<"claimdocuments"> | string | null
    documenttypecode?: StringNullableFilter<"claimdocuments"> | string | null
    documenttypename?: StringNullableFilter<"claimdocuments"> | string | null
    serverpath?: StringNullableFilter<"claimdocuments"> | string | null
    filepath?: StringFilter<"claimdocuments"> | string
    filesize?: BigIntNullableFilter<"claimdocuments"> | bigint | number | null
    filemimetype?: StringNullableFilter<"claimdocuments"> | string | null
    uploaddate?: DateTimeNullableFilter<"claimdocuments"> | Date | string | null
    uploadedby?: StringNullableFilter<"claimdocuments"> | string | null
    insurers?: XOR<InsurersNullableRelationFilter, insurersWhereInput> | null
  }

  export type claimdocumentsOrderByWithRelationInput = {
    id?: SortOrder
    insurerid?: SortOrderInput | SortOrder
    refid?: SortOrderInput | SortOrder
    transactionno?: SortOrderInput | SortOrder
    hn?: SortOrderInput | SortOrder
    vn?: SortOrderInput | SortOrder
    documentname?: SortOrderInput | SortOrder
    documenttypecode?: SortOrderInput | SortOrder
    documenttypename?: SortOrderInput | SortOrder
    serverpath?: SortOrderInput | SortOrder
    filepath?: SortOrder
    filesize?: SortOrderInput | SortOrder
    filemimetype?: SortOrderInput | SortOrder
    uploaddate?: SortOrderInput | SortOrder
    uploadedby?: SortOrderInput | SortOrder
    insurers?: insurersOrderByWithRelationInput
  }

  export type claimdocumentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: claimdocumentsWhereInput | claimdocumentsWhereInput[]
    OR?: claimdocumentsWhereInput[]
    NOT?: claimdocumentsWhereInput | claimdocumentsWhereInput[]
    insurerid?: IntNullableFilter<"claimdocuments"> | number | null
    refid?: StringNullableFilter<"claimdocuments"> | string | null
    transactionno?: StringNullableFilter<"claimdocuments"> | string | null
    hn?: StringNullableFilter<"claimdocuments"> | string | null
    vn?: StringNullableFilter<"claimdocuments"> | string | null
    documentname?: StringNullableFilter<"claimdocuments"> | string | null
    documenttypecode?: StringNullableFilter<"claimdocuments"> | string | null
    documenttypename?: StringNullableFilter<"claimdocuments"> | string | null
    serverpath?: StringNullableFilter<"claimdocuments"> | string | null
    filepath?: StringFilter<"claimdocuments"> | string
    filesize?: BigIntNullableFilter<"claimdocuments"> | bigint | number | null
    filemimetype?: StringNullableFilter<"claimdocuments"> | string | null
    uploaddate?: DateTimeNullableFilter<"claimdocuments"> | Date | string | null
    uploadedby?: StringNullableFilter<"claimdocuments"> | string | null
    insurers?: XOR<InsurersNullableRelationFilter, insurersWhereInput> | null
  }, "id">

  export type claimdocumentsOrderByWithAggregationInput = {
    id?: SortOrder
    insurerid?: SortOrderInput | SortOrder
    refid?: SortOrderInput | SortOrder
    transactionno?: SortOrderInput | SortOrder
    hn?: SortOrderInput | SortOrder
    vn?: SortOrderInput | SortOrder
    documentname?: SortOrderInput | SortOrder
    documenttypecode?: SortOrderInput | SortOrder
    documenttypename?: SortOrderInput | SortOrder
    serverpath?: SortOrderInput | SortOrder
    filepath?: SortOrder
    filesize?: SortOrderInput | SortOrder
    filemimetype?: SortOrderInput | SortOrder
    uploaddate?: SortOrderInput | SortOrder
    uploadedby?: SortOrderInput | SortOrder
    _count?: claimdocumentsCountOrderByAggregateInput
    _avg?: claimdocumentsAvgOrderByAggregateInput
    _max?: claimdocumentsMaxOrderByAggregateInput
    _min?: claimdocumentsMinOrderByAggregateInput
    _sum?: claimdocumentsSumOrderByAggregateInput
  }

  export type claimdocumentsScalarWhereWithAggregatesInput = {
    AND?: claimdocumentsScalarWhereWithAggregatesInput | claimdocumentsScalarWhereWithAggregatesInput[]
    OR?: claimdocumentsScalarWhereWithAggregatesInput[]
    NOT?: claimdocumentsScalarWhereWithAggregatesInput | claimdocumentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"claimdocuments"> | number
    insurerid?: IntNullableWithAggregatesFilter<"claimdocuments"> | number | null
    refid?: StringNullableWithAggregatesFilter<"claimdocuments"> | string | null
    transactionno?: StringNullableWithAggregatesFilter<"claimdocuments"> | string | null
    hn?: StringNullableWithAggregatesFilter<"claimdocuments"> | string | null
    vn?: StringNullableWithAggregatesFilter<"claimdocuments"> | string | null
    documentname?: StringNullableWithAggregatesFilter<"claimdocuments"> | string | null
    documenttypecode?: StringNullableWithAggregatesFilter<"claimdocuments"> | string | null
    documenttypename?: StringNullableWithAggregatesFilter<"claimdocuments"> | string | null
    serverpath?: StringNullableWithAggregatesFilter<"claimdocuments"> | string | null
    filepath?: StringWithAggregatesFilter<"claimdocuments"> | string
    filesize?: BigIntNullableWithAggregatesFilter<"claimdocuments"> | bigint | number | null
    filemimetype?: StringNullableWithAggregatesFilter<"claimdocuments"> | string | null
    uploaddate?: DateTimeNullableWithAggregatesFilter<"claimdocuments"> | Date | string | null
    uploadedby?: StringNullableWithAggregatesFilter<"claimdocuments"> | string | null
  }

  export type claimstatusWhereInput = {
    AND?: claimstatusWhereInput | claimstatusWhereInput[]
    OR?: claimstatusWhereInput[]
    NOT?: claimstatusWhereInput | claimstatusWhereInput[]
    id?: IntFilter<"claimstatus"> | number
    claimstatuscode?: StringFilter<"claimstatus"> | string
    claimstatusdesc_th?: StringNullableFilter<"claimstatus"> | string | null
    claimstatusdesc_en?: StringNullableFilter<"claimstatus"> | string | null
    insurerid?: IntNullableFilter<"claimstatus"> | number | null
    insurers?: XOR<InsurersNullableRelationFilter, insurersWhereInput> | null
    transactionclaimstatus?: TransactionclaimstatusListRelationFilter
  }

  export type claimstatusOrderByWithRelationInput = {
    id?: SortOrder
    claimstatuscode?: SortOrder
    claimstatusdesc_th?: SortOrderInput | SortOrder
    claimstatusdesc_en?: SortOrderInput | SortOrder
    insurerid?: SortOrderInput | SortOrder
    insurers?: insurersOrderByWithRelationInput
    transactionclaimstatus?: transactionclaimstatusOrderByRelationAggregateInput
  }

  export type claimstatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    claimstatuscode_insurerid?: claimstatusClaimstatuscodeInsureridCompoundUniqueInput
    AND?: claimstatusWhereInput | claimstatusWhereInput[]
    OR?: claimstatusWhereInput[]
    NOT?: claimstatusWhereInput | claimstatusWhereInput[]
    claimstatuscode?: StringFilter<"claimstatus"> | string
    claimstatusdesc_th?: StringNullableFilter<"claimstatus"> | string | null
    claimstatusdesc_en?: StringNullableFilter<"claimstatus"> | string | null
    insurerid?: IntNullableFilter<"claimstatus"> | number | null
    insurers?: XOR<InsurersNullableRelationFilter, insurersWhereInput> | null
    transactionclaimstatus?: TransactionclaimstatusListRelationFilter
  }, "id" | "claimstatuscode_insurerid">

  export type claimstatusOrderByWithAggregationInput = {
    id?: SortOrder
    claimstatuscode?: SortOrder
    claimstatusdesc_th?: SortOrderInput | SortOrder
    claimstatusdesc_en?: SortOrderInput | SortOrder
    insurerid?: SortOrderInput | SortOrder
    _count?: claimstatusCountOrderByAggregateInput
    _avg?: claimstatusAvgOrderByAggregateInput
    _max?: claimstatusMaxOrderByAggregateInput
    _min?: claimstatusMinOrderByAggregateInput
    _sum?: claimstatusSumOrderByAggregateInput
  }

  export type claimstatusScalarWhereWithAggregatesInput = {
    AND?: claimstatusScalarWhereWithAggregatesInput | claimstatusScalarWhereWithAggregatesInput[]
    OR?: claimstatusScalarWhereWithAggregatesInput[]
    NOT?: claimstatusScalarWhereWithAggregatesInput | claimstatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"claimstatus"> | number
    claimstatuscode?: StringWithAggregatesFilter<"claimstatus"> | string
    claimstatusdesc_th?: StringNullableWithAggregatesFilter<"claimstatus"> | string | null
    claimstatusdesc_en?: StringNullableWithAggregatesFilter<"claimstatus"> | string | null
    insurerid?: IntNullableWithAggregatesFilter<"claimstatus"> | number | null
  }

  export type diagnosistypemappingWhereInput = {
    AND?: diagnosistypemappingWhereInput | diagnosistypemappingWhereInput[]
    OR?: diagnosistypemappingWhereInput[]
    NOT?: diagnosistypemappingWhereInput | diagnosistypemappingWhereInput[]
    id?: IntFilter<"diagnosistypemapping"> | number
    dxtypecodetrakcare?: StringFilter<"diagnosistypemapping"> | string
    dxtypenametrakcare?: StringNullableFilter<"diagnosistypemapping"> | string | null
    dxtypecodeinsurance?: StringNullableFilter<"diagnosistypemapping"> | string | null
    dxtypenameinsurance?: StringNullableFilter<"diagnosistypemapping"> | string | null
    insurerid?: IntNullableFilter<"diagnosistypemapping"> | number | null
    insurers?: XOR<InsurersNullableRelationFilter, insurersWhereInput> | null
  }

  export type diagnosistypemappingOrderByWithRelationInput = {
    id?: SortOrder
    dxtypecodetrakcare?: SortOrder
    dxtypenametrakcare?: SortOrderInput | SortOrder
    dxtypecodeinsurance?: SortOrderInput | SortOrder
    dxtypenameinsurance?: SortOrderInput | SortOrder
    insurerid?: SortOrderInput | SortOrder
    insurers?: insurersOrderByWithRelationInput
  }

  export type diagnosistypemappingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: diagnosistypemappingWhereInput | diagnosistypemappingWhereInput[]
    OR?: diagnosistypemappingWhereInput[]
    NOT?: diagnosistypemappingWhereInput | diagnosistypemappingWhereInput[]
    dxtypecodetrakcare?: StringFilter<"diagnosistypemapping"> | string
    dxtypenametrakcare?: StringNullableFilter<"diagnosistypemapping"> | string | null
    dxtypecodeinsurance?: StringNullableFilter<"diagnosistypemapping"> | string | null
    dxtypenameinsurance?: StringNullableFilter<"diagnosistypemapping"> | string | null
    insurerid?: IntNullableFilter<"diagnosistypemapping"> | number | null
    insurers?: XOR<InsurersNullableRelationFilter, insurersWhereInput> | null
  }, "id">

  export type diagnosistypemappingOrderByWithAggregationInput = {
    id?: SortOrder
    dxtypecodetrakcare?: SortOrder
    dxtypenametrakcare?: SortOrderInput | SortOrder
    dxtypecodeinsurance?: SortOrderInput | SortOrder
    dxtypenameinsurance?: SortOrderInput | SortOrder
    insurerid?: SortOrderInput | SortOrder
    _count?: diagnosistypemappingCountOrderByAggregateInput
    _avg?: diagnosistypemappingAvgOrderByAggregateInput
    _max?: diagnosistypemappingMaxOrderByAggregateInput
    _min?: diagnosistypemappingMinOrderByAggregateInput
    _sum?: diagnosistypemappingSumOrderByAggregateInput
  }

  export type diagnosistypemappingScalarWhereWithAggregatesInput = {
    AND?: diagnosistypemappingScalarWhereWithAggregatesInput | diagnosistypemappingScalarWhereWithAggregatesInput[]
    OR?: diagnosistypemappingScalarWhereWithAggregatesInput[]
    NOT?: diagnosistypemappingScalarWhereWithAggregatesInput | diagnosistypemappingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"diagnosistypemapping"> | number
    dxtypecodetrakcare?: StringWithAggregatesFilter<"diagnosistypemapping"> | string
    dxtypenametrakcare?: StringNullableWithAggregatesFilter<"diagnosistypemapping"> | string | null
    dxtypecodeinsurance?: StringNullableWithAggregatesFilter<"diagnosistypemapping"> | string | null
    dxtypenameinsurance?: StringNullableWithAggregatesFilter<"diagnosistypemapping"> | string | null
    insurerid?: IntNullableWithAggregatesFilter<"diagnosistypemapping"> | number | null
  }

  export type documenttypeWhereInput = {
    AND?: documenttypeWhereInput | documenttypeWhereInput[]
    OR?: documenttypeWhereInput[]
    NOT?: documenttypeWhereInput | documenttypeWhereInput[]
    id?: IntFilter<"documenttype"> | number
    documenttypecode?: StringFilter<"documenttype"> | string
    documenttypename?: StringNullableFilter<"documenttype"> | string | null
    insurerid?: IntNullableFilter<"documenttype"> | number | null
    insurers?: XOR<InsurersNullableRelationFilter, insurersWhereInput> | null
  }

  export type documenttypeOrderByWithRelationInput = {
    id?: SortOrder
    documenttypecode?: SortOrder
    documenttypename?: SortOrderInput | SortOrder
    insurerid?: SortOrderInput | SortOrder
    insurers?: insurersOrderByWithRelationInput
  }

  export type documenttypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: documenttypeWhereInput | documenttypeWhereInput[]
    OR?: documenttypeWhereInput[]
    NOT?: documenttypeWhereInput | documenttypeWhereInput[]
    documenttypecode?: StringFilter<"documenttype"> | string
    documenttypename?: StringNullableFilter<"documenttype"> | string | null
    insurerid?: IntNullableFilter<"documenttype"> | number | null
    insurers?: XOR<InsurersNullableRelationFilter, insurersWhereInput> | null
  }, "id">

  export type documenttypeOrderByWithAggregationInput = {
    id?: SortOrder
    documenttypecode?: SortOrder
    documenttypename?: SortOrderInput | SortOrder
    insurerid?: SortOrderInput | SortOrder
    _count?: documenttypeCountOrderByAggregateInput
    _avg?: documenttypeAvgOrderByAggregateInput
    _max?: documenttypeMaxOrderByAggregateInput
    _min?: documenttypeMinOrderByAggregateInput
    _sum?: documenttypeSumOrderByAggregateInput
  }

  export type documenttypeScalarWhereWithAggregatesInput = {
    AND?: documenttypeScalarWhereWithAggregatesInput | documenttypeScalarWhereWithAggregatesInput[]
    OR?: documenttypeScalarWhereWithAggregatesInput[]
    NOT?: documenttypeScalarWhereWithAggregatesInput | documenttypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"documenttype"> | number
    documenttypecode?: StringWithAggregatesFilter<"documenttype"> | string
    documenttypename?: StringNullableWithAggregatesFilter<"documenttype"> | string | null
    insurerid?: IntNullableWithAggregatesFilter<"documenttype"> | number | null
  }

  export type illnesssurgeryWhereInput = {
    AND?: illnesssurgeryWhereInput | illnesssurgeryWhereInput[]
    OR?: illnesssurgeryWhereInput[]
    NOT?: illnesssurgeryWhereInput | illnesssurgeryWhereInput[]
    id?: IntFilter<"illnesssurgery"> | number
    iscode?: StringFilter<"illnesssurgery"> | string
    isdesc?: StringNullableFilter<"illnesssurgery"> | string | null
    insurerid?: IntNullableFilter<"illnesssurgery"> | number | null
    insurers?: XOR<InsurersNullableRelationFilter, insurersWhereInput> | null
  }

  export type illnesssurgeryOrderByWithRelationInput = {
    id?: SortOrder
    iscode?: SortOrder
    isdesc?: SortOrderInput | SortOrder
    insurerid?: SortOrderInput | SortOrder
    insurers?: insurersOrderByWithRelationInput
  }

  export type illnesssurgeryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: illnesssurgeryWhereInput | illnesssurgeryWhereInput[]
    OR?: illnesssurgeryWhereInput[]
    NOT?: illnesssurgeryWhereInput | illnesssurgeryWhereInput[]
    iscode?: StringFilter<"illnesssurgery"> | string
    isdesc?: StringNullableFilter<"illnesssurgery"> | string | null
    insurerid?: IntNullableFilter<"illnesssurgery"> | number | null
    insurers?: XOR<InsurersNullableRelationFilter, insurersWhereInput> | null
  }, "id">

  export type illnesssurgeryOrderByWithAggregationInput = {
    id?: SortOrder
    iscode?: SortOrder
    isdesc?: SortOrderInput | SortOrder
    insurerid?: SortOrderInput | SortOrder
    _count?: illnesssurgeryCountOrderByAggregateInput
    _avg?: illnesssurgeryAvgOrderByAggregateInput
    _max?: illnesssurgeryMaxOrderByAggregateInput
    _min?: illnesssurgeryMinOrderByAggregateInput
    _sum?: illnesssurgerySumOrderByAggregateInput
  }

  export type illnesssurgeryScalarWhereWithAggregatesInput = {
    AND?: illnesssurgeryScalarWhereWithAggregatesInput | illnesssurgeryScalarWhereWithAggregatesInput[]
    OR?: illnesssurgeryScalarWhereWithAggregatesInput[]
    NOT?: illnesssurgeryScalarWhereWithAggregatesInput | illnesssurgeryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"illnesssurgery"> | number
    iscode?: StringWithAggregatesFilter<"illnesssurgery"> | string
    isdesc?: StringNullableWithAggregatesFilter<"illnesssurgery"> | string | null
    insurerid?: IntNullableWithAggregatesFilter<"illnesssurgery"> | number | null
  }

  export type illnesstypeWhereInput = {
    AND?: illnesstypeWhereInput | illnesstypeWhereInput[]
    OR?: illnesstypeWhereInput[]
    NOT?: illnesstypeWhereInput | illnesstypeWhereInput[]
    id?: IntFilter<"illnesstype"> | number
    illnesstypecode?: StringFilter<"illnesstype"> | string
    illnesstypedesc?: StringNullableFilter<"illnesstype"> | string | null
    insurerid?: IntNullableFilter<"illnesstype"> | number | null
    insurers?: XOR<InsurersNullableRelationFilter, insurersWhereInput> | null
  }

  export type illnesstypeOrderByWithRelationInput = {
    id?: SortOrder
    illnesstypecode?: SortOrder
    illnesstypedesc?: SortOrderInput | SortOrder
    insurerid?: SortOrderInput | SortOrder
    insurers?: insurersOrderByWithRelationInput
  }

  export type illnesstypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: illnesstypeWhereInput | illnesstypeWhereInput[]
    OR?: illnesstypeWhereInput[]
    NOT?: illnesstypeWhereInput | illnesstypeWhereInput[]
    illnesstypecode?: StringFilter<"illnesstype"> | string
    illnesstypedesc?: StringNullableFilter<"illnesstype"> | string | null
    insurerid?: IntNullableFilter<"illnesstype"> | number | null
    insurers?: XOR<InsurersNullableRelationFilter, insurersWhereInput> | null
  }, "id">

  export type illnesstypeOrderByWithAggregationInput = {
    id?: SortOrder
    illnesstypecode?: SortOrder
    illnesstypedesc?: SortOrderInput | SortOrder
    insurerid?: SortOrderInput | SortOrder
    _count?: illnesstypeCountOrderByAggregateInput
    _avg?: illnesstypeAvgOrderByAggregateInput
    _max?: illnesstypeMaxOrderByAggregateInput
    _min?: illnesstypeMinOrderByAggregateInput
    _sum?: illnesstypeSumOrderByAggregateInput
  }

  export type illnesstypeScalarWhereWithAggregatesInput = {
    AND?: illnesstypeScalarWhereWithAggregatesInput | illnesstypeScalarWhereWithAggregatesInput[]
    OR?: illnesstypeScalarWhereWithAggregatesInput[]
    NOT?: illnesstypeScalarWhereWithAggregatesInput | illnesstypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"illnesstype"> | number
    illnesstypecode?: StringWithAggregatesFilter<"illnesstype"> | string
    illnesstypedesc?: StringNullableWithAggregatesFilter<"illnesstype"> | string | null
    insurerid?: IntNullableWithAggregatesFilter<"illnesstype"> | number | null
  }

  export type insurersWhereInput = {
    AND?: insurersWhereInput | insurersWhereInput[]
    OR?: insurersWhereInput[]
    NOT?: insurersWhereInput | insurersWhereInput[]
    id?: IntFilter<"insurers"> | number
    insurerid?: IntFilter<"insurers"> | number
    insurercode?: IntNullableFilter<"insurers"> | number | null
    insurername?: StringNullableFilter<"insurers"> | string | null
    accidentcauseover45days?: Accidentcauseover45daysListRelationFilter
    accidentplace?: AccidentplaceListRelationFilter
    accidenttransactions?: AccidenttransactionsListRelationFilter
    accidenttransactions22?: Accidenttransactions22ListRelationFilter
    causeofinjuryside?: CauseofinjurysideListRelationFilter
    causeofinjurywoundtype?: CauseofinjurywoundtypeListRelationFilter
    claimants?: ClaimantsListRelationFilter
    claimdocuments?: ClaimdocumentsListRelationFilter
    claimstatus?: ClaimstatusListRelationFilter
    diagnosistypemapping?: DiagnosistypemappingListRelationFilter
    documenttype?: DocumenttypeListRelationFilter
    illnesssurgery?: IllnesssurgeryListRelationFilter
    illnesstype?: IllnesstypeListRelationFilter
    policytype?: PolicytypeListRelationFilter
    proceduretransactions?: ProceduretransactionsListRelationFilter
    servicesetting?: ServicesettingListRelationFilter
  }

  export type insurersOrderByWithRelationInput = {
    id?: SortOrder
    insurerid?: SortOrder
    insurercode?: SortOrderInput | SortOrder
    insurername?: SortOrderInput | SortOrder
    accidentcauseover45days?: accidentcauseover45daysOrderByRelationAggregateInput
    accidentplace?: accidentplaceOrderByRelationAggregateInput
    accidenttransactions?: accidenttransactionsOrderByRelationAggregateInput
    accidenttransactions22?: accidenttransactions22OrderByRelationAggregateInput
    causeofinjuryside?: causeofinjurysideOrderByRelationAggregateInput
    causeofinjurywoundtype?: causeofinjurywoundtypeOrderByRelationAggregateInput
    claimants?: claimantsOrderByRelationAggregateInput
    claimdocuments?: claimdocumentsOrderByRelationAggregateInput
    claimstatus?: claimstatusOrderByRelationAggregateInput
    diagnosistypemapping?: diagnosistypemappingOrderByRelationAggregateInput
    documenttype?: documenttypeOrderByRelationAggregateInput
    illnesssurgery?: illnesssurgeryOrderByRelationAggregateInput
    illnesstype?: illnesstypeOrderByRelationAggregateInput
    policytype?: policytypeOrderByRelationAggregateInput
    proceduretransactions?: proceduretransactionsOrderByRelationAggregateInput
    servicesetting?: servicesettingOrderByRelationAggregateInput
  }

  export type insurersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    insurerid?: number
    AND?: insurersWhereInput | insurersWhereInput[]
    OR?: insurersWhereInput[]
    NOT?: insurersWhereInput | insurersWhereInput[]
    insurercode?: IntNullableFilter<"insurers"> | number | null
    insurername?: StringNullableFilter<"insurers"> | string | null
    accidentcauseover45days?: Accidentcauseover45daysListRelationFilter
    accidentplace?: AccidentplaceListRelationFilter
    accidenttransactions?: AccidenttransactionsListRelationFilter
    accidenttransactions22?: Accidenttransactions22ListRelationFilter
    causeofinjuryside?: CauseofinjurysideListRelationFilter
    causeofinjurywoundtype?: CauseofinjurywoundtypeListRelationFilter
    claimants?: ClaimantsListRelationFilter
    claimdocuments?: ClaimdocumentsListRelationFilter
    claimstatus?: ClaimstatusListRelationFilter
    diagnosistypemapping?: DiagnosistypemappingListRelationFilter
    documenttype?: DocumenttypeListRelationFilter
    illnesssurgery?: IllnesssurgeryListRelationFilter
    illnesstype?: IllnesstypeListRelationFilter
    policytype?: PolicytypeListRelationFilter
    proceduretransactions?: ProceduretransactionsListRelationFilter
    servicesetting?: ServicesettingListRelationFilter
  }, "id" | "insurerid">

  export type insurersOrderByWithAggregationInput = {
    id?: SortOrder
    insurerid?: SortOrder
    insurercode?: SortOrderInput | SortOrder
    insurername?: SortOrderInput | SortOrder
    _count?: insurersCountOrderByAggregateInput
    _avg?: insurersAvgOrderByAggregateInput
    _max?: insurersMaxOrderByAggregateInput
    _min?: insurersMinOrderByAggregateInput
    _sum?: insurersSumOrderByAggregateInput
  }

  export type insurersScalarWhereWithAggregatesInput = {
    AND?: insurersScalarWhereWithAggregatesInput | insurersScalarWhereWithAggregatesInput[]
    OR?: insurersScalarWhereWithAggregatesInput[]
    NOT?: insurersScalarWhereWithAggregatesInput | insurersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"insurers"> | number
    insurerid?: IntWithAggregatesFilter<"insurers"> | number
    insurercode?: IntNullableWithAggregatesFilter<"insurers"> | number | null
    insurername?: StringNullableWithAggregatesFilter<"insurers"> | string | null
  }

  export type medicaltransactionsWhereInput = {
    AND?: medicaltransactionsWhereInput | medicaltransactionsWhereInput[]
    OR?: medicaltransactionsWhereInput[]
    NOT?: medicaltransactionsWhereInput | medicaltransactionsWhereInput[]
    id?: IntFilter<"medicaltransactions"> | number
    insurerid?: IntNullableFilter<"medicaltransactions"> | number | null
    refid?: StringNullableFilter<"medicaltransactions"> | string | null
    transactionno?: StringNullableFilter<"medicaltransactions"> | string | null
    hn?: StringNullableFilter<"medicaltransactions"> | string | null
    vn?: StringNullableFilter<"medicaltransactions"> | string | null
    dxfreetext?: StringNullableFilter<"medicaltransactions"> | string | null
    presentillness?: StringNullableFilter<"medicaltransactions"> | string | null
    chiefcomplaint?: StringNullableFilter<"medicaltransactions"> | string | null
    accidentcauseover45days?: StringNullableFilter<"medicaltransactions"> | string | null
    underlyingcondition?: StringNullableFilter<"medicaltransactions"> | string | null
    physicalexam?: StringNullableFilter<"medicaltransactions"> | string | null
    planoftreatment?: StringNullableFilter<"medicaltransactions"> | string | null
    procedurefreetext?: StringNullableFilter<"medicaltransactions"> | string | null
    additionalnote?: StringNullableFilter<"medicaltransactions"> | string | null
    signsymptomsdate?: StringNullableFilter<"medicaltransactions"> | string | null
    comascore?: StringNullableFilter<"medicaltransactions"> | string | null
    expecteddayofrecovery?: StringNullableFilter<"medicaltransactions"> | string | null
    pregnant?: BoolNullableFilter<"medicaltransactions"> | boolean | null
    alcoholrelated?: BoolNullableFilter<"medicaltransactions"> | boolean | null
    haveaccidentinjurydetail?: BoolNullableFilter<"medicaltransactions"> | boolean | null
    haveaccidentcauseofinjurydetail?: BoolNullableFilter<"medicaltransactions"> | boolean | null
    haveprocedure?: BoolNullableFilter<"medicaltransactions"> | boolean | null
    privatecase?: BoolNullableFilter<"medicaltransactions"> | boolean | null
  }

  export type medicaltransactionsOrderByWithRelationInput = {
    id?: SortOrder
    insurerid?: SortOrderInput | SortOrder
    refid?: SortOrderInput | SortOrder
    transactionno?: SortOrderInput | SortOrder
    hn?: SortOrderInput | SortOrder
    vn?: SortOrderInput | SortOrder
    dxfreetext?: SortOrderInput | SortOrder
    presentillness?: SortOrderInput | SortOrder
    chiefcomplaint?: SortOrderInput | SortOrder
    accidentcauseover45days?: SortOrderInput | SortOrder
    underlyingcondition?: SortOrderInput | SortOrder
    physicalexam?: SortOrderInput | SortOrder
    planoftreatment?: SortOrderInput | SortOrder
    procedurefreetext?: SortOrderInput | SortOrder
    additionalnote?: SortOrderInput | SortOrder
    signsymptomsdate?: SortOrderInput | SortOrder
    comascore?: SortOrderInput | SortOrder
    expecteddayofrecovery?: SortOrderInput | SortOrder
    pregnant?: SortOrderInput | SortOrder
    alcoholrelated?: SortOrderInput | SortOrder
    haveaccidentinjurydetail?: SortOrderInput | SortOrder
    haveaccidentcauseofinjurydetail?: SortOrderInput | SortOrder
    haveprocedure?: SortOrderInput | SortOrder
    privatecase?: SortOrderInput | SortOrder
  }

  export type medicaltransactionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: medicaltransactionsWhereInput | medicaltransactionsWhereInput[]
    OR?: medicaltransactionsWhereInput[]
    NOT?: medicaltransactionsWhereInput | medicaltransactionsWhereInput[]
    insurerid?: IntNullableFilter<"medicaltransactions"> | number | null
    refid?: StringNullableFilter<"medicaltransactions"> | string | null
    transactionno?: StringNullableFilter<"medicaltransactions"> | string | null
    hn?: StringNullableFilter<"medicaltransactions"> | string | null
    vn?: StringNullableFilter<"medicaltransactions"> | string | null
    dxfreetext?: StringNullableFilter<"medicaltransactions"> | string | null
    presentillness?: StringNullableFilter<"medicaltransactions"> | string | null
    chiefcomplaint?: StringNullableFilter<"medicaltransactions"> | string | null
    accidentcauseover45days?: StringNullableFilter<"medicaltransactions"> | string | null
    underlyingcondition?: StringNullableFilter<"medicaltransactions"> | string | null
    physicalexam?: StringNullableFilter<"medicaltransactions"> | string | null
    planoftreatment?: StringNullableFilter<"medicaltransactions"> | string | null
    procedurefreetext?: StringNullableFilter<"medicaltransactions"> | string | null
    additionalnote?: StringNullableFilter<"medicaltransactions"> | string | null
    signsymptomsdate?: StringNullableFilter<"medicaltransactions"> | string | null
    comascore?: StringNullableFilter<"medicaltransactions"> | string | null
    expecteddayofrecovery?: StringNullableFilter<"medicaltransactions"> | string | null
    pregnant?: BoolNullableFilter<"medicaltransactions"> | boolean | null
    alcoholrelated?: BoolNullableFilter<"medicaltransactions"> | boolean | null
    haveaccidentinjurydetail?: BoolNullableFilter<"medicaltransactions"> | boolean | null
    haveaccidentcauseofinjurydetail?: BoolNullableFilter<"medicaltransactions"> | boolean | null
    haveprocedure?: BoolNullableFilter<"medicaltransactions"> | boolean | null
    privatecase?: BoolNullableFilter<"medicaltransactions"> | boolean | null
  }, "id">

  export type medicaltransactionsOrderByWithAggregationInput = {
    id?: SortOrder
    insurerid?: SortOrderInput | SortOrder
    refid?: SortOrderInput | SortOrder
    transactionno?: SortOrderInput | SortOrder
    hn?: SortOrderInput | SortOrder
    vn?: SortOrderInput | SortOrder
    dxfreetext?: SortOrderInput | SortOrder
    presentillness?: SortOrderInput | SortOrder
    chiefcomplaint?: SortOrderInput | SortOrder
    accidentcauseover45days?: SortOrderInput | SortOrder
    underlyingcondition?: SortOrderInput | SortOrder
    physicalexam?: SortOrderInput | SortOrder
    planoftreatment?: SortOrderInput | SortOrder
    procedurefreetext?: SortOrderInput | SortOrder
    additionalnote?: SortOrderInput | SortOrder
    signsymptomsdate?: SortOrderInput | SortOrder
    comascore?: SortOrderInput | SortOrder
    expecteddayofrecovery?: SortOrderInput | SortOrder
    pregnant?: SortOrderInput | SortOrder
    alcoholrelated?: SortOrderInput | SortOrder
    haveaccidentinjurydetail?: SortOrderInput | SortOrder
    haveaccidentcauseofinjurydetail?: SortOrderInput | SortOrder
    haveprocedure?: SortOrderInput | SortOrder
    privatecase?: SortOrderInput | SortOrder
    _count?: medicaltransactionsCountOrderByAggregateInput
    _avg?: medicaltransactionsAvgOrderByAggregateInput
    _max?: medicaltransactionsMaxOrderByAggregateInput
    _min?: medicaltransactionsMinOrderByAggregateInput
    _sum?: medicaltransactionsSumOrderByAggregateInput
  }

  export type medicaltransactionsScalarWhereWithAggregatesInput = {
    AND?: medicaltransactionsScalarWhereWithAggregatesInput | medicaltransactionsScalarWhereWithAggregatesInput[]
    OR?: medicaltransactionsScalarWhereWithAggregatesInput[]
    NOT?: medicaltransactionsScalarWhereWithAggregatesInput | medicaltransactionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"medicaltransactions"> | number
    insurerid?: IntNullableWithAggregatesFilter<"medicaltransactions"> | number | null
    refid?: StringNullableWithAggregatesFilter<"medicaltransactions"> | string | null
    transactionno?: StringNullableWithAggregatesFilter<"medicaltransactions"> | string | null
    hn?: StringNullableWithAggregatesFilter<"medicaltransactions"> | string | null
    vn?: StringNullableWithAggregatesFilter<"medicaltransactions"> | string | null
    dxfreetext?: StringNullableWithAggregatesFilter<"medicaltransactions"> | string | null
    presentillness?: StringNullableWithAggregatesFilter<"medicaltransactions"> | string | null
    chiefcomplaint?: StringNullableWithAggregatesFilter<"medicaltransactions"> | string | null
    accidentcauseover45days?: StringNullableWithAggregatesFilter<"medicaltransactions"> | string | null
    underlyingcondition?: StringNullableWithAggregatesFilter<"medicaltransactions"> | string | null
    physicalexam?: StringNullableWithAggregatesFilter<"medicaltransactions"> | string | null
    planoftreatment?: StringNullableWithAggregatesFilter<"medicaltransactions"> | string | null
    procedurefreetext?: StringNullableWithAggregatesFilter<"medicaltransactions"> | string | null
    additionalnote?: StringNullableWithAggregatesFilter<"medicaltransactions"> | string | null
    signsymptomsdate?: StringNullableWithAggregatesFilter<"medicaltransactions"> | string | null
    comascore?: StringNullableWithAggregatesFilter<"medicaltransactions"> | string | null
    expecteddayofrecovery?: StringNullableWithAggregatesFilter<"medicaltransactions"> | string | null
    pregnant?: BoolNullableWithAggregatesFilter<"medicaltransactions"> | boolean | null
    alcoholrelated?: BoolNullableWithAggregatesFilter<"medicaltransactions"> | boolean | null
    haveaccidentinjurydetail?: BoolNullableWithAggregatesFilter<"medicaltransactions"> | boolean | null
    haveaccidentcauseofinjurydetail?: BoolNullableWithAggregatesFilter<"medicaltransactions"> | boolean | null
    haveprocedure?: BoolNullableWithAggregatesFilter<"medicaltransactions"> | boolean | null
    privatecase?: BoolNullableWithAggregatesFilter<"medicaltransactions"> | boolean | null
  }

  export type policytypeWhereInput = {
    AND?: policytypeWhereInput | policytypeWhereInput[]
    OR?: policytypeWhereInput[]
    NOT?: policytypeWhereInput | policytypeWhereInput[]
    id?: IntFilter<"policytype"> | number
    policytypecode?: StringFilter<"policytype"> | string
    policytypedesc?: StringNullableFilter<"policytype"> | string | null
    insurerid?: IntNullableFilter<"policytype"> | number | null
    insurers?: XOR<InsurersNullableRelationFilter, insurersWhereInput> | null
  }

  export type policytypeOrderByWithRelationInput = {
    id?: SortOrder
    policytypecode?: SortOrder
    policytypedesc?: SortOrderInput | SortOrder
    insurerid?: SortOrderInput | SortOrder
    insurers?: insurersOrderByWithRelationInput
  }

  export type policytypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: policytypeWhereInput | policytypeWhereInput[]
    OR?: policytypeWhereInput[]
    NOT?: policytypeWhereInput | policytypeWhereInput[]
    policytypecode?: StringFilter<"policytype"> | string
    policytypedesc?: StringNullableFilter<"policytype"> | string | null
    insurerid?: IntNullableFilter<"policytype"> | number | null
    insurers?: XOR<InsurersNullableRelationFilter, insurersWhereInput> | null
  }, "id">

  export type policytypeOrderByWithAggregationInput = {
    id?: SortOrder
    policytypecode?: SortOrder
    policytypedesc?: SortOrderInput | SortOrder
    insurerid?: SortOrderInput | SortOrder
    _count?: policytypeCountOrderByAggregateInput
    _avg?: policytypeAvgOrderByAggregateInput
    _max?: policytypeMaxOrderByAggregateInput
    _min?: policytypeMinOrderByAggregateInput
    _sum?: policytypeSumOrderByAggregateInput
  }

  export type policytypeScalarWhereWithAggregatesInput = {
    AND?: policytypeScalarWhereWithAggregatesInput | policytypeScalarWhereWithAggregatesInput[]
    OR?: policytypeScalarWhereWithAggregatesInput[]
    NOT?: policytypeScalarWhereWithAggregatesInput | policytypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"policytype"> | number
    policytypecode?: StringWithAggregatesFilter<"policytype"> | string
    policytypedesc?: StringNullableWithAggregatesFilter<"policytype"> | string | null
    insurerid?: IntNullableWithAggregatesFilter<"policytype"> | number | null
  }

  export type servicesettingWhereInput = {
    AND?: servicesettingWhereInput | servicesettingWhereInput[]
    OR?: servicesettingWhereInput[]
    NOT?: servicesettingWhereInput | servicesettingWhereInput[]
    id?: IntFilter<"servicesetting"> | number
    servicesettingcode?: StringFilter<"servicesetting"> | string
    servicesettingdesc?: StringFilter<"servicesetting"> | string
    insurerid?: IntNullableFilter<"servicesetting"> | number | null
    insurers?: XOR<InsurersNullableRelationFilter, insurersWhereInput> | null
  }

  export type servicesettingOrderByWithRelationInput = {
    id?: SortOrder
    servicesettingcode?: SortOrder
    servicesettingdesc?: SortOrder
    insurerid?: SortOrderInput | SortOrder
    insurers?: insurersOrderByWithRelationInput
  }

  export type servicesettingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: servicesettingWhereInput | servicesettingWhereInput[]
    OR?: servicesettingWhereInput[]
    NOT?: servicesettingWhereInput | servicesettingWhereInput[]
    servicesettingcode?: StringFilter<"servicesetting"> | string
    servicesettingdesc?: StringFilter<"servicesetting"> | string
    insurerid?: IntNullableFilter<"servicesetting"> | number | null
    insurers?: XOR<InsurersNullableRelationFilter, insurersWhereInput> | null
  }, "id">

  export type servicesettingOrderByWithAggregationInput = {
    id?: SortOrder
    servicesettingcode?: SortOrder
    servicesettingdesc?: SortOrder
    insurerid?: SortOrderInput | SortOrder
    _count?: servicesettingCountOrderByAggregateInput
    _avg?: servicesettingAvgOrderByAggregateInput
    _max?: servicesettingMaxOrderByAggregateInput
    _min?: servicesettingMinOrderByAggregateInput
    _sum?: servicesettingSumOrderByAggregateInput
  }

  export type servicesettingScalarWhereWithAggregatesInput = {
    AND?: servicesettingScalarWhereWithAggregatesInput | servicesettingScalarWhereWithAggregatesInput[]
    OR?: servicesettingScalarWhereWithAggregatesInput[]
    NOT?: servicesettingScalarWhereWithAggregatesInput | servicesettingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"servicesetting"> | number
    servicesettingcode?: StringWithAggregatesFilter<"servicesetting"> | string
    servicesettingdesc?: StringWithAggregatesFilter<"servicesetting"> | string
    insurerid?: IntNullableWithAggregatesFilter<"servicesetting"> | number | null
  }

  export type transactionclaimWhereInput = {
    AND?: transactionclaimWhereInput | transactionclaimWhereInput[]
    OR?: transactionclaimWhereInput[]
    NOT?: transactionclaimWhereInput | transactionclaimWhereInput[]
    id?: IntFilter<"transactionclaim"> | number
    insurerid?: IntNullableFilter<"transactionclaim"> | number | null
    refid?: StringNullableFilter<"transactionclaim"> | string | null
    transactionno?: StringNullableFilter<"transactionclaim"> | string | null
    hn?: StringNullableFilter<"transactionclaim"> | string | null
    vn?: StringNullableFilter<"transactionclaim"> | string | null
    visitdate?: StringNullableFilter<"transactionclaim"> | string | null
    accidentdate?: StringNullableFilter<"transactionclaim"> | string | null
    messageclaim?: StringNullableFilter<"transactionclaim"> | string | null
    messageth?: StringNullableFilter<"transactionclaim"> | string | null
    claimno?: StringNullableFilter<"transactionclaim"> | string | null
    claimstatuscode?: StringNullableFilter<"transactionclaim"> | string | null
    status_changed_at?: DateTimeNullableFilter<"transactionclaim"> | Date | string | null
    occurrenceno?: StringNullableFilter<"transactionclaim"> | string | null
    totalapprovedamount?: DecimalNullableFilter<"transactionclaim"> | Decimal | DecimalJsLike | number | string | null
    totalexcessamount?: DecimalNullableFilter<"transactionclaim"> | Decimal | DecimalJsLike | number | string | null
    isreimbursement?: BoolNullableFilter<"transactionclaim"> | boolean | null
    batchnumber?: StringNullableFilter<"transactionclaim"> | string | null
    invoicenumber?: StringNullableFilter<"transactionclaim"> | string | null
    otherinsurer?: BoolNullableFilter<"transactionclaim"> | boolean | null
    furtherclaimid?: StringNullableFilter<"transactionclaim"> | string | null
    furtherclaimno?: StringNullableFilter<"transactionclaim"> | string | null
    privatecase?: BoolNullableFilter<"transactionclaim"> | boolean | null
    previoustreatmentdate?: StringNullableFilter<"transactionclaim"> | string | null
    previoustreatmentdetail?: StringNullableFilter<"transactionclaim"> | string | null
  }

  export type transactionclaimOrderByWithRelationInput = {
    id?: SortOrder
    insurerid?: SortOrderInput | SortOrder
    refid?: SortOrderInput | SortOrder
    transactionno?: SortOrderInput | SortOrder
    hn?: SortOrderInput | SortOrder
    vn?: SortOrderInput | SortOrder
    visitdate?: SortOrderInput | SortOrder
    accidentdate?: SortOrderInput | SortOrder
    messageclaim?: SortOrderInput | SortOrder
    messageth?: SortOrderInput | SortOrder
    claimno?: SortOrderInput | SortOrder
    claimstatuscode?: SortOrderInput | SortOrder
    status_changed_at?: SortOrderInput | SortOrder
    occurrenceno?: SortOrderInput | SortOrder
    totalapprovedamount?: SortOrderInput | SortOrder
    totalexcessamount?: SortOrderInput | SortOrder
    isreimbursement?: SortOrderInput | SortOrder
    batchnumber?: SortOrderInput | SortOrder
    invoicenumber?: SortOrderInput | SortOrder
    otherinsurer?: SortOrderInput | SortOrder
    furtherclaimid?: SortOrderInput | SortOrder
    furtherclaimno?: SortOrderInput | SortOrder
    privatecase?: SortOrderInput | SortOrder
    previoustreatmentdate?: SortOrderInput | SortOrder
    previoustreatmentdetail?: SortOrderInput | SortOrder
  }

  export type transactionclaimWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: transactionclaimWhereInput | transactionclaimWhereInput[]
    OR?: transactionclaimWhereInput[]
    NOT?: transactionclaimWhereInput | transactionclaimWhereInput[]
    insurerid?: IntNullableFilter<"transactionclaim"> | number | null
    refid?: StringNullableFilter<"transactionclaim"> | string | null
    transactionno?: StringNullableFilter<"transactionclaim"> | string | null
    hn?: StringNullableFilter<"transactionclaim"> | string | null
    vn?: StringNullableFilter<"transactionclaim"> | string | null
    visitdate?: StringNullableFilter<"transactionclaim"> | string | null
    accidentdate?: StringNullableFilter<"transactionclaim"> | string | null
    messageclaim?: StringNullableFilter<"transactionclaim"> | string | null
    messageth?: StringNullableFilter<"transactionclaim"> | string | null
    claimno?: StringNullableFilter<"transactionclaim"> | string | null
    claimstatuscode?: StringNullableFilter<"transactionclaim"> | string | null
    status_changed_at?: DateTimeNullableFilter<"transactionclaim"> | Date | string | null
    occurrenceno?: StringNullableFilter<"transactionclaim"> | string | null
    totalapprovedamount?: DecimalNullableFilter<"transactionclaim"> | Decimal | DecimalJsLike | number | string | null
    totalexcessamount?: DecimalNullableFilter<"transactionclaim"> | Decimal | DecimalJsLike | number | string | null
    isreimbursement?: BoolNullableFilter<"transactionclaim"> | boolean | null
    batchnumber?: StringNullableFilter<"transactionclaim"> | string | null
    invoicenumber?: StringNullableFilter<"transactionclaim"> | string | null
    otherinsurer?: BoolNullableFilter<"transactionclaim"> | boolean | null
    furtherclaimid?: StringNullableFilter<"transactionclaim"> | string | null
    furtherclaimno?: StringNullableFilter<"transactionclaim"> | string | null
    privatecase?: BoolNullableFilter<"transactionclaim"> | boolean | null
    previoustreatmentdate?: StringNullableFilter<"transactionclaim"> | string | null
    previoustreatmentdetail?: StringNullableFilter<"transactionclaim"> | string | null
  }, "id">

  export type transactionclaimOrderByWithAggregationInput = {
    id?: SortOrder
    insurerid?: SortOrderInput | SortOrder
    refid?: SortOrderInput | SortOrder
    transactionno?: SortOrderInput | SortOrder
    hn?: SortOrderInput | SortOrder
    vn?: SortOrderInput | SortOrder
    visitdate?: SortOrderInput | SortOrder
    accidentdate?: SortOrderInput | SortOrder
    messageclaim?: SortOrderInput | SortOrder
    messageth?: SortOrderInput | SortOrder
    claimno?: SortOrderInput | SortOrder
    claimstatuscode?: SortOrderInput | SortOrder
    status_changed_at?: SortOrderInput | SortOrder
    occurrenceno?: SortOrderInput | SortOrder
    totalapprovedamount?: SortOrderInput | SortOrder
    totalexcessamount?: SortOrderInput | SortOrder
    isreimbursement?: SortOrderInput | SortOrder
    batchnumber?: SortOrderInput | SortOrder
    invoicenumber?: SortOrderInput | SortOrder
    otherinsurer?: SortOrderInput | SortOrder
    furtherclaimid?: SortOrderInput | SortOrder
    furtherclaimno?: SortOrderInput | SortOrder
    privatecase?: SortOrderInput | SortOrder
    previoustreatmentdate?: SortOrderInput | SortOrder
    previoustreatmentdetail?: SortOrderInput | SortOrder
    _count?: transactionclaimCountOrderByAggregateInput
    _avg?: transactionclaimAvgOrderByAggregateInput
    _max?: transactionclaimMaxOrderByAggregateInput
    _min?: transactionclaimMinOrderByAggregateInput
    _sum?: transactionclaimSumOrderByAggregateInput
  }

  export type transactionclaimScalarWhereWithAggregatesInput = {
    AND?: transactionclaimScalarWhereWithAggregatesInput | transactionclaimScalarWhereWithAggregatesInput[]
    OR?: transactionclaimScalarWhereWithAggregatesInput[]
    NOT?: transactionclaimScalarWhereWithAggregatesInput | transactionclaimScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"transactionclaim"> | number
    insurerid?: IntNullableWithAggregatesFilter<"transactionclaim"> | number | null
    refid?: StringNullableWithAggregatesFilter<"transactionclaim"> | string | null
    transactionno?: StringNullableWithAggregatesFilter<"transactionclaim"> | string | null
    hn?: StringNullableWithAggregatesFilter<"transactionclaim"> | string | null
    vn?: StringNullableWithAggregatesFilter<"transactionclaim"> | string | null
    visitdate?: StringNullableWithAggregatesFilter<"transactionclaim"> | string | null
    accidentdate?: StringNullableWithAggregatesFilter<"transactionclaim"> | string | null
    messageclaim?: StringNullableWithAggregatesFilter<"transactionclaim"> | string | null
    messageth?: StringNullableWithAggregatesFilter<"transactionclaim"> | string | null
    claimno?: StringNullableWithAggregatesFilter<"transactionclaim"> | string | null
    claimstatuscode?: StringNullableWithAggregatesFilter<"transactionclaim"> | string | null
    status_changed_at?: DateTimeNullableWithAggregatesFilter<"transactionclaim"> | Date | string | null
    occurrenceno?: StringNullableWithAggregatesFilter<"transactionclaim"> | string | null
    totalapprovedamount?: DecimalNullableWithAggregatesFilter<"transactionclaim"> | Decimal | DecimalJsLike | number | string | null
    totalexcessamount?: DecimalNullableWithAggregatesFilter<"transactionclaim"> | Decimal | DecimalJsLike | number | string | null
    isreimbursement?: BoolNullableWithAggregatesFilter<"transactionclaim"> | boolean | null
    batchnumber?: StringNullableWithAggregatesFilter<"transactionclaim"> | string | null
    invoicenumber?: StringNullableWithAggregatesFilter<"transactionclaim"> | string | null
    otherinsurer?: BoolNullableWithAggregatesFilter<"transactionclaim"> | boolean | null
    furtherclaimid?: StringNullableWithAggregatesFilter<"transactionclaim"> | string | null
    furtherclaimno?: StringNullableWithAggregatesFilter<"transactionclaim"> | string | null
    privatecase?: BoolNullableWithAggregatesFilter<"transactionclaim"> | boolean | null
    previoustreatmentdate?: StringNullableWithAggregatesFilter<"transactionclaim"> | string | null
    previoustreatmentdetail?: StringNullableWithAggregatesFilter<"transactionclaim"> | string | null
  }

  export type transactionclaimstatusWhereInput = {
    AND?: transactionclaimstatusWhereInput | transactionclaimstatusWhereInput[]
    OR?: transactionclaimstatusWhereInput[]
    NOT?: transactionclaimstatusWhereInput | transactionclaimstatusWhereInput[]
    id?: IntFilter<"transactionclaimstatus"> | number
    insurerid?: IntNullableFilter<"transactionclaimstatus"> | number | null
    refid?: StringNullableFilter<"transactionclaimstatus"> | string | null
    transactionno?: StringNullableFilter<"transactionclaimstatus"> | string | null
    hn?: StringNullableFilter<"transactionclaimstatus"> | string | null
    vn?: StringNullableFilter<"transactionclaimstatus"> | string | null
    batchnumber?: StringNullableFilter<"transactionclaimstatus"> | string | null
    claimno?: StringNullableFilter<"transactionclaimstatus"> | string | null
    invoicenumber?: StringNullableFilter<"transactionclaimstatus"> | string | null
    status_changed_at?: DateTimeNullableFilter<"transactionclaimstatus"> | Date | string | null
    note?: StringNullableFilter<"transactionclaimstatus"> | string | null
    totalapproveamount?: StringNullableFilter<"transactionclaimstatus"> | string | null
    paymentdate?: StringNullableFilter<"transactionclaimstatus"> | string | null
    claimstatuscode?: StringNullableFilter<"transactionclaimstatus"> | string | null
    claimstatus?: XOR<ClaimstatusNullableRelationFilter, claimstatusWhereInput> | null
  }

  export type transactionclaimstatusOrderByWithRelationInput = {
    id?: SortOrder
    insurerid?: SortOrderInput | SortOrder
    refid?: SortOrderInput | SortOrder
    transactionno?: SortOrderInput | SortOrder
    hn?: SortOrderInput | SortOrder
    vn?: SortOrderInput | SortOrder
    batchnumber?: SortOrderInput | SortOrder
    claimno?: SortOrderInput | SortOrder
    invoicenumber?: SortOrderInput | SortOrder
    status_changed_at?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    totalapproveamount?: SortOrderInput | SortOrder
    paymentdate?: SortOrderInput | SortOrder
    claimstatuscode?: SortOrderInput | SortOrder
    claimstatus?: claimstatusOrderByWithRelationInput
  }

  export type transactionclaimstatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: transactionclaimstatusWhereInput | transactionclaimstatusWhereInput[]
    OR?: transactionclaimstatusWhereInput[]
    NOT?: transactionclaimstatusWhereInput | transactionclaimstatusWhereInput[]
    insurerid?: IntNullableFilter<"transactionclaimstatus"> | number | null
    refid?: StringNullableFilter<"transactionclaimstatus"> | string | null
    transactionno?: StringNullableFilter<"transactionclaimstatus"> | string | null
    hn?: StringNullableFilter<"transactionclaimstatus"> | string | null
    vn?: StringNullableFilter<"transactionclaimstatus"> | string | null
    batchnumber?: StringNullableFilter<"transactionclaimstatus"> | string | null
    claimno?: StringNullableFilter<"transactionclaimstatus"> | string | null
    invoicenumber?: StringNullableFilter<"transactionclaimstatus"> | string | null
    status_changed_at?: DateTimeNullableFilter<"transactionclaimstatus"> | Date | string | null
    note?: StringNullableFilter<"transactionclaimstatus"> | string | null
    totalapproveamount?: StringNullableFilter<"transactionclaimstatus"> | string | null
    paymentdate?: StringNullableFilter<"transactionclaimstatus"> | string | null
    claimstatuscode?: StringNullableFilter<"transactionclaimstatus"> | string | null
    claimstatus?: XOR<ClaimstatusNullableRelationFilter, claimstatusWhereInput> | null
  }, "id">

  export type transactionclaimstatusOrderByWithAggregationInput = {
    id?: SortOrder
    insurerid?: SortOrderInput | SortOrder
    refid?: SortOrderInput | SortOrder
    transactionno?: SortOrderInput | SortOrder
    hn?: SortOrderInput | SortOrder
    vn?: SortOrderInput | SortOrder
    batchnumber?: SortOrderInput | SortOrder
    claimno?: SortOrderInput | SortOrder
    invoicenumber?: SortOrderInput | SortOrder
    status_changed_at?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    totalapproveamount?: SortOrderInput | SortOrder
    paymentdate?: SortOrderInput | SortOrder
    claimstatuscode?: SortOrderInput | SortOrder
    _count?: transactionclaimstatusCountOrderByAggregateInput
    _avg?: transactionclaimstatusAvgOrderByAggregateInput
    _max?: transactionclaimstatusMaxOrderByAggregateInput
    _min?: transactionclaimstatusMinOrderByAggregateInput
    _sum?: transactionclaimstatusSumOrderByAggregateInput
  }

  export type transactionclaimstatusScalarWhereWithAggregatesInput = {
    AND?: transactionclaimstatusScalarWhereWithAggregatesInput | transactionclaimstatusScalarWhereWithAggregatesInput[]
    OR?: transactionclaimstatusScalarWhereWithAggregatesInput[]
    NOT?: transactionclaimstatusScalarWhereWithAggregatesInput | transactionclaimstatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"transactionclaimstatus"> | number
    insurerid?: IntNullableWithAggregatesFilter<"transactionclaimstatus"> | number | null
    refid?: StringNullableWithAggregatesFilter<"transactionclaimstatus"> | string | null
    transactionno?: StringNullableWithAggregatesFilter<"transactionclaimstatus"> | string | null
    hn?: StringNullableWithAggregatesFilter<"transactionclaimstatus"> | string | null
    vn?: StringNullableWithAggregatesFilter<"transactionclaimstatus"> | string | null
    batchnumber?: StringNullableWithAggregatesFilter<"transactionclaimstatus"> | string | null
    claimno?: StringNullableWithAggregatesFilter<"transactionclaimstatus"> | string | null
    invoicenumber?: StringNullableWithAggregatesFilter<"transactionclaimstatus"> | string | null
    status_changed_at?: DateTimeNullableWithAggregatesFilter<"transactionclaimstatus"> | Date | string | null
    note?: StringNullableWithAggregatesFilter<"transactionclaimstatus"> | string | null
    totalapproveamount?: StringNullableWithAggregatesFilter<"transactionclaimstatus"> | string | null
    paymentdate?: StringNullableWithAggregatesFilter<"transactionclaimstatus"> | string | null
    claimstatuscode?: StringNullableWithAggregatesFilter<"transactionclaimstatus"> | string | null
  }

  export type accidenttransactionsWhereInput = {
    AND?: accidenttransactionsWhereInput | accidenttransactionsWhereInput[]
    OR?: accidenttransactionsWhereInput[]
    NOT?: accidenttransactionsWhereInput | accidenttransactionsWhereInput[]
    id?: IntFilter<"accidenttransactions"> | number
    insurerid?: IntNullableFilter<"accidenttransactions"> | number | null
    refid?: StringNullableFilter<"accidenttransactions"> | string | null
    transactionno?: StringNullableFilter<"accidenttransactions"> | string | null
    hn?: StringNullableFilter<"accidenttransactions"> | string | null
    vn?: StringNullableFilter<"accidenttransactions"> | string | null
    accidentplace?: StringNullableFilter<"accidenttransactions"> | string | null
    accidentdate?: StringNullableFilter<"accidenttransactions"> | string | null
    insurers?: XOR<InsurersNullableRelationFilter, insurersWhereInput> | null
    causeofinjurydetail?: CauseofinjurydetailListRelationFilter
    injurydetail?: InjurydetailListRelationFilter
  }

  export type accidenttransactionsOrderByWithRelationInput = {
    id?: SortOrder
    insurerid?: SortOrderInput | SortOrder
    refid?: SortOrderInput | SortOrder
    transactionno?: SortOrderInput | SortOrder
    hn?: SortOrderInput | SortOrder
    vn?: SortOrderInput | SortOrder
    accidentplace?: SortOrderInput | SortOrder
    accidentdate?: SortOrderInput | SortOrder
    insurers?: insurersOrderByWithRelationInput
    causeofinjurydetail?: causeofinjurydetailOrderByRelationAggregateInput
    injurydetail?: injurydetailOrderByRelationAggregateInput
  }

  export type accidenttransactionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: accidenttransactionsWhereInput | accidenttransactionsWhereInput[]
    OR?: accidenttransactionsWhereInput[]
    NOT?: accidenttransactionsWhereInput | accidenttransactionsWhereInput[]
    insurerid?: IntNullableFilter<"accidenttransactions"> | number | null
    refid?: StringNullableFilter<"accidenttransactions"> | string | null
    transactionno?: StringNullableFilter<"accidenttransactions"> | string | null
    hn?: StringNullableFilter<"accidenttransactions"> | string | null
    vn?: StringNullableFilter<"accidenttransactions"> | string | null
    accidentplace?: StringNullableFilter<"accidenttransactions"> | string | null
    accidentdate?: StringNullableFilter<"accidenttransactions"> | string | null
    insurers?: XOR<InsurersNullableRelationFilter, insurersWhereInput> | null
    causeofinjurydetail?: CauseofinjurydetailListRelationFilter
    injurydetail?: InjurydetailListRelationFilter
  }, "id">

  export type accidenttransactionsOrderByWithAggregationInput = {
    id?: SortOrder
    insurerid?: SortOrderInput | SortOrder
    refid?: SortOrderInput | SortOrder
    transactionno?: SortOrderInput | SortOrder
    hn?: SortOrderInput | SortOrder
    vn?: SortOrderInput | SortOrder
    accidentplace?: SortOrderInput | SortOrder
    accidentdate?: SortOrderInput | SortOrder
    _count?: accidenttransactionsCountOrderByAggregateInput
    _avg?: accidenttransactionsAvgOrderByAggregateInput
    _max?: accidenttransactionsMaxOrderByAggregateInput
    _min?: accidenttransactionsMinOrderByAggregateInput
    _sum?: accidenttransactionsSumOrderByAggregateInput
  }

  export type accidenttransactionsScalarWhereWithAggregatesInput = {
    AND?: accidenttransactionsScalarWhereWithAggregatesInput | accidenttransactionsScalarWhereWithAggregatesInput[]
    OR?: accidenttransactionsScalarWhereWithAggregatesInput[]
    NOT?: accidenttransactionsScalarWhereWithAggregatesInput | accidenttransactionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"accidenttransactions"> | number
    insurerid?: IntNullableWithAggregatesFilter<"accidenttransactions"> | number | null
    refid?: StringNullableWithAggregatesFilter<"accidenttransactions"> | string | null
    transactionno?: StringNullableWithAggregatesFilter<"accidenttransactions"> | string | null
    hn?: StringNullableWithAggregatesFilter<"accidenttransactions"> | string | null
    vn?: StringNullableWithAggregatesFilter<"accidenttransactions"> | string | null
    accidentplace?: StringNullableWithAggregatesFilter<"accidenttransactions"> | string | null
    accidentdate?: StringNullableWithAggregatesFilter<"accidenttransactions"> | string | null
  }

  export type proceduretransactionsWhereInput = {
    AND?: proceduretransactionsWhereInput | proceduretransactionsWhereInput[]
    OR?: proceduretransactionsWhereInput[]
    NOT?: proceduretransactionsWhereInput | proceduretransactionsWhereInput[]
    id?: IntFilter<"proceduretransactions"> | number
    insurerid?: IntNullableFilter<"proceduretransactions"> | number | null
    refid?: StringNullableFilter<"proceduretransactions"> | string | null
    transactionno?: StringNullableFilter<"proceduretransactions"> | string | null
    hn?: StringNullableFilter<"proceduretransactions"> | string | null
    vn?: StringNullableFilter<"proceduretransactions"> | string | null
    icd9?: StringNullableFilter<"proceduretransactions"> | string | null
    procedurename?: StringNullableFilter<"proceduretransactions"> | string | null
    proceduredate?: StringNullableFilter<"proceduretransactions"> | string | null
    insurers?: XOR<InsurersNullableRelationFilter, insurersWhereInput> | null
  }

  export type proceduretransactionsOrderByWithRelationInput = {
    id?: SortOrder
    insurerid?: SortOrderInput | SortOrder
    refid?: SortOrderInput | SortOrder
    transactionno?: SortOrderInput | SortOrder
    hn?: SortOrderInput | SortOrder
    vn?: SortOrderInput | SortOrder
    icd9?: SortOrderInput | SortOrder
    procedurename?: SortOrderInput | SortOrder
    proceduredate?: SortOrderInput | SortOrder
    insurers?: insurersOrderByWithRelationInput
  }

  export type proceduretransactionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: proceduretransactionsWhereInput | proceduretransactionsWhereInput[]
    OR?: proceduretransactionsWhereInput[]
    NOT?: proceduretransactionsWhereInput | proceduretransactionsWhereInput[]
    insurerid?: IntNullableFilter<"proceduretransactions"> | number | null
    refid?: StringNullableFilter<"proceduretransactions"> | string | null
    transactionno?: StringNullableFilter<"proceduretransactions"> | string | null
    hn?: StringNullableFilter<"proceduretransactions"> | string | null
    vn?: StringNullableFilter<"proceduretransactions"> | string | null
    icd9?: StringNullableFilter<"proceduretransactions"> | string | null
    procedurename?: StringNullableFilter<"proceduretransactions"> | string | null
    proceduredate?: StringNullableFilter<"proceduretransactions"> | string | null
    insurers?: XOR<InsurersNullableRelationFilter, insurersWhereInput> | null
  }, "id">

  export type proceduretransactionsOrderByWithAggregationInput = {
    id?: SortOrder
    insurerid?: SortOrderInput | SortOrder
    refid?: SortOrderInput | SortOrder
    transactionno?: SortOrderInput | SortOrder
    hn?: SortOrderInput | SortOrder
    vn?: SortOrderInput | SortOrder
    icd9?: SortOrderInput | SortOrder
    procedurename?: SortOrderInput | SortOrder
    proceduredate?: SortOrderInput | SortOrder
    _count?: proceduretransactionsCountOrderByAggregateInput
    _avg?: proceduretransactionsAvgOrderByAggregateInput
    _max?: proceduretransactionsMaxOrderByAggregateInput
    _min?: proceduretransactionsMinOrderByAggregateInput
    _sum?: proceduretransactionsSumOrderByAggregateInput
  }

  export type proceduretransactionsScalarWhereWithAggregatesInput = {
    AND?: proceduretransactionsScalarWhereWithAggregatesInput | proceduretransactionsScalarWhereWithAggregatesInput[]
    OR?: proceduretransactionsScalarWhereWithAggregatesInput[]
    NOT?: proceduretransactionsScalarWhereWithAggregatesInput | proceduretransactionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"proceduretransactions"> | number
    insurerid?: IntNullableWithAggregatesFilter<"proceduretransactions"> | number | null
    refid?: StringNullableWithAggregatesFilter<"proceduretransactions"> | string | null
    transactionno?: StringNullableWithAggregatesFilter<"proceduretransactions"> | string | null
    hn?: StringNullableWithAggregatesFilter<"proceduretransactions"> | string | null
    vn?: StringNullableWithAggregatesFilter<"proceduretransactions"> | string | null
    icd9?: StringNullableWithAggregatesFilter<"proceduretransactions"> | string | null
    procedurename?: StringNullableWithAggregatesFilter<"proceduretransactions"> | string | null
    proceduredate?: StringNullableWithAggregatesFilter<"proceduretransactions"> | string | null
  }

  export type accidenttransactions22WhereInput = {
    AND?: accidenttransactions22WhereInput | accidenttransactions22WhereInput[]
    OR?: accidenttransactions22WhereInput[]
    NOT?: accidenttransactions22WhereInput | accidenttransactions22WhereInput[]
    id?: IntFilter<"accidenttransactions22"> | number
    insurerid?: IntNullableFilter<"accidenttransactions22"> | number | null
    refid?: StringNullableFilter<"accidenttransactions22"> | string | null
    transactionno?: StringNullableFilter<"accidenttransactions22"> | string | null
    hn?: StringNullableFilter<"accidenttransactions22"> | string | null
    vn?: StringNullableFilter<"accidenttransactions22"> | string | null
    accidentplace?: StringNullableFilter<"accidenttransactions22"> | string | null
    accidentdate?: StringNullableFilter<"accidenttransactions22"> | string | null
    causeofinjury?: StringNullableFilter<"accidenttransactions22"> | string | null
    commentofinjury?: StringNullableFilter<"accidenttransactions22"> | string | null
    woundtype?: StringNullableFilter<"accidenttransactions22"> | string | null
    injuryside?: StringNullableFilter<"accidenttransactions22"> | string | null
    injuryarea?: StringNullableFilter<"accidenttransactions22"> | string | null
    insurers?: XOR<InsurersNullableRelationFilter, insurersWhereInput> | null
  }

  export type accidenttransactions22OrderByWithRelationInput = {
    id?: SortOrder
    insurerid?: SortOrderInput | SortOrder
    refid?: SortOrderInput | SortOrder
    transactionno?: SortOrderInput | SortOrder
    hn?: SortOrderInput | SortOrder
    vn?: SortOrderInput | SortOrder
    accidentplace?: SortOrderInput | SortOrder
    accidentdate?: SortOrderInput | SortOrder
    causeofinjury?: SortOrderInput | SortOrder
    commentofinjury?: SortOrderInput | SortOrder
    woundtype?: SortOrderInput | SortOrder
    injuryside?: SortOrderInput | SortOrder
    injuryarea?: SortOrderInput | SortOrder
    insurers?: insurersOrderByWithRelationInput
  }

  export type accidenttransactions22WhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: accidenttransactions22WhereInput | accidenttransactions22WhereInput[]
    OR?: accidenttransactions22WhereInput[]
    NOT?: accidenttransactions22WhereInput | accidenttransactions22WhereInput[]
    insurerid?: IntNullableFilter<"accidenttransactions22"> | number | null
    refid?: StringNullableFilter<"accidenttransactions22"> | string | null
    transactionno?: StringNullableFilter<"accidenttransactions22"> | string | null
    hn?: StringNullableFilter<"accidenttransactions22"> | string | null
    vn?: StringNullableFilter<"accidenttransactions22"> | string | null
    accidentplace?: StringNullableFilter<"accidenttransactions22"> | string | null
    accidentdate?: StringNullableFilter<"accidenttransactions22"> | string | null
    causeofinjury?: StringNullableFilter<"accidenttransactions22"> | string | null
    commentofinjury?: StringNullableFilter<"accidenttransactions22"> | string | null
    woundtype?: StringNullableFilter<"accidenttransactions22"> | string | null
    injuryside?: StringNullableFilter<"accidenttransactions22"> | string | null
    injuryarea?: StringNullableFilter<"accidenttransactions22"> | string | null
    insurers?: XOR<InsurersNullableRelationFilter, insurersWhereInput> | null
  }, "id">

  export type accidenttransactions22OrderByWithAggregationInput = {
    id?: SortOrder
    insurerid?: SortOrderInput | SortOrder
    refid?: SortOrderInput | SortOrder
    transactionno?: SortOrderInput | SortOrder
    hn?: SortOrderInput | SortOrder
    vn?: SortOrderInput | SortOrder
    accidentplace?: SortOrderInput | SortOrder
    accidentdate?: SortOrderInput | SortOrder
    causeofinjury?: SortOrderInput | SortOrder
    commentofinjury?: SortOrderInput | SortOrder
    woundtype?: SortOrderInput | SortOrder
    injuryside?: SortOrderInput | SortOrder
    injuryarea?: SortOrderInput | SortOrder
    _count?: accidenttransactions22CountOrderByAggregateInput
    _avg?: accidenttransactions22AvgOrderByAggregateInput
    _max?: accidenttransactions22MaxOrderByAggregateInput
    _min?: accidenttransactions22MinOrderByAggregateInput
    _sum?: accidenttransactions22SumOrderByAggregateInput
  }

  export type accidenttransactions22ScalarWhereWithAggregatesInput = {
    AND?: accidenttransactions22ScalarWhereWithAggregatesInput | accidenttransactions22ScalarWhereWithAggregatesInput[]
    OR?: accidenttransactions22ScalarWhereWithAggregatesInput[]
    NOT?: accidenttransactions22ScalarWhereWithAggregatesInput | accidenttransactions22ScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"accidenttransactions22"> | number
    insurerid?: IntNullableWithAggregatesFilter<"accidenttransactions22"> | number | null
    refid?: StringNullableWithAggregatesFilter<"accidenttransactions22"> | string | null
    transactionno?: StringNullableWithAggregatesFilter<"accidenttransactions22"> | string | null
    hn?: StringNullableWithAggregatesFilter<"accidenttransactions22"> | string | null
    vn?: StringNullableWithAggregatesFilter<"accidenttransactions22"> | string | null
    accidentplace?: StringNullableWithAggregatesFilter<"accidenttransactions22"> | string | null
    accidentdate?: StringNullableWithAggregatesFilter<"accidenttransactions22"> | string | null
    causeofinjury?: StringNullableWithAggregatesFilter<"accidenttransactions22"> | string | null
    commentofinjury?: StringNullableWithAggregatesFilter<"accidenttransactions22"> | string | null
    woundtype?: StringNullableWithAggregatesFilter<"accidenttransactions22"> | string | null
    injuryside?: StringNullableWithAggregatesFilter<"accidenttransactions22"> | string | null
    injuryarea?: StringNullableWithAggregatesFilter<"accidenttransactions22"> | string | null
  }

  export type causeofinjurydetailWhereInput = {
    AND?: causeofinjurydetailWhereInput | causeofinjurydetailWhereInput[]
    OR?: causeofinjurydetailWhereInput[]
    NOT?: causeofinjurydetailWhereInput | causeofinjurydetailWhereInput[]
    id?: IntFilter<"causeofinjurydetail"> | number
    accidentid?: IntNullableFilter<"causeofinjurydetail"> | number | null
    causeofinjury?: StringNullableFilter<"causeofinjurydetail"> | string | null
    commentofinjury?: StringNullableFilter<"causeofinjurydetail"> | string | null
    accidenttransactions?: XOR<AccidenttransactionsNullableRelationFilter, accidenttransactionsWhereInput> | null
  }

  export type causeofinjurydetailOrderByWithRelationInput = {
    id?: SortOrder
    accidentid?: SortOrderInput | SortOrder
    causeofinjury?: SortOrderInput | SortOrder
    commentofinjury?: SortOrderInput | SortOrder
    accidenttransactions?: accidenttransactionsOrderByWithRelationInput
  }

  export type causeofinjurydetailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: causeofinjurydetailWhereInput | causeofinjurydetailWhereInput[]
    OR?: causeofinjurydetailWhereInput[]
    NOT?: causeofinjurydetailWhereInput | causeofinjurydetailWhereInput[]
    accidentid?: IntNullableFilter<"causeofinjurydetail"> | number | null
    causeofinjury?: StringNullableFilter<"causeofinjurydetail"> | string | null
    commentofinjury?: StringNullableFilter<"causeofinjurydetail"> | string | null
    accidenttransactions?: XOR<AccidenttransactionsNullableRelationFilter, accidenttransactionsWhereInput> | null
  }, "id">

  export type causeofinjurydetailOrderByWithAggregationInput = {
    id?: SortOrder
    accidentid?: SortOrderInput | SortOrder
    causeofinjury?: SortOrderInput | SortOrder
    commentofinjury?: SortOrderInput | SortOrder
    _count?: causeofinjurydetailCountOrderByAggregateInput
    _avg?: causeofinjurydetailAvgOrderByAggregateInput
    _max?: causeofinjurydetailMaxOrderByAggregateInput
    _min?: causeofinjurydetailMinOrderByAggregateInput
    _sum?: causeofinjurydetailSumOrderByAggregateInput
  }

  export type causeofinjurydetailScalarWhereWithAggregatesInput = {
    AND?: causeofinjurydetailScalarWhereWithAggregatesInput | causeofinjurydetailScalarWhereWithAggregatesInput[]
    OR?: causeofinjurydetailScalarWhereWithAggregatesInput[]
    NOT?: causeofinjurydetailScalarWhereWithAggregatesInput | causeofinjurydetailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"causeofinjurydetail"> | number
    accidentid?: IntNullableWithAggregatesFilter<"causeofinjurydetail"> | number | null
    causeofinjury?: StringNullableWithAggregatesFilter<"causeofinjurydetail"> | string | null
    commentofinjury?: StringNullableWithAggregatesFilter<"causeofinjurydetail"> | string | null
  }

  export type injurydetailWhereInput = {
    AND?: injurydetailWhereInput | injurydetailWhereInput[]
    OR?: injurydetailWhereInput[]
    NOT?: injurydetailWhereInput | injurydetailWhereInput[]
    id?: IntFilter<"injurydetail"> | number
    accidentid?: IntNullableFilter<"injurydetail"> | number | null
    woundtype?: StringNullableFilter<"injurydetail"> | string | null
    injuryside?: StringNullableFilter<"injurydetail"> | string | null
    injuryarea?: StringNullableFilter<"injurydetail"> | string | null
    accidenttransactions?: XOR<AccidenttransactionsNullableRelationFilter, accidenttransactionsWhereInput> | null
  }

  export type injurydetailOrderByWithRelationInput = {
    id?: SortOrder
    accidentid?: SortOrderInput | SortOrder
    woundtype?: SortOrderInput | SortOrder
    injuryside?: SortOrderInput | SortOrder
    injuryarea?: SortOrderInput | SortOrder
    accidenttransactions?: accidenttransactionsOrderByWithRelationInput
  }

  export type injurydetailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: injurydetailWhereInput | injurydetailWhereInput[]
    OR?: injurydetailWhereInput[]
    NOT?: injurydetailWhereInput | injurydetailWhereInput[]
    accidentid?: IntNullableFilter<"injurydetail"> | number | null
    woundtype?: StringNullableFilter<"injurydetail"> | string | null
    injuryside?: StringNullableFilter<"injurydetail"> | string | null
    injuryarea?: StringNullableFilter<"injurydetail"> | string | null
    accidenttransactions?: XOR<AccidenttransactionsNullableRelationFilter, accidenttransactionsWhereInput> | null
  }, "id">

  export type injurydetailOrderByWithAggregationInput = {
    id?: SortOrder
    accidentid?: SortOrderInput | SortOrder
    woundtype?: SortOrderInput | SortOrder
    injuryside?: SortOrderInput | SortOrder
    injuryarea?: SortOrderInput | SortOrder
    _count?: injurydetailCountOrderByAggregateInput
    _avg?: injurydetailAvgOrderByAggregateInput
    _max?: injurydetailMaxOrderByAggregateInput
    _min?: injurydetailMinOrderByAggregateInput
    _sum?: injurydetailSumOrderByAggregateInput
  }

  export type injurydetailScalarWhereWithAggregatesInput = {
    AND?: injurydetailScalarWhereWithAggregatesInput | injurydetailScalarWhereWithAggregatesInput[]
    OR?: injurydetailScalarWhereWithAggregatesInput[]
    NOT?: injurydetailScalarWhereWithAggregatesInput | injurydetailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"injurydetail"> | number
    accidentid?: IntNullableWithAggregatesFilter<"injurydetail"> | number | null
    woundtype?: StringNullableWithAggregatesFilter<"injurydetail"> | string | null
    injuryside?: StringNullableWithAggregatesFilter<"injurydetail"> | string | null
    injuryarea?: StringNullableWithAggregatesFilter<"injurydetail"> | string | null
  }

  export type accidentcauseover45daysCreateInput = {
    causeovercode: string
    causeoverdesc?: string | null
    insurers?: insurersCreateNestedOneWithoutAccidentcauseover45daysInput
  }

  export type accidentcauseover45daysUncheckedCreateInput = {
    id?: number
    causeovercode: string
    causeoverdesc?: string | null
    insurerid?: number | null
  }

  export type accidentcauseover45daysUpdateInput = {
    causeovercode?: StringFieldUpdateOperationsInput | string
    causeoverdesc?: NullableStringFieldUpdateOperationsInput | string | null
    insurers?: insurersUpdateOneWithoutAccidentcauseover45daysNestedInput
  }

  export type accidentcauseover45daysUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    causeovercode?: StringFieldUpdateOperationsInput | string
    causeoverdesc?: NullableStringFieldUpdateOperationsInput | string | null
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type accidentcauseover45daysCreateManyInput = {
    id?: number
    causeovercode: string
    causeoverdesc?: string | null
    insurerid?: number | null
  }

  export type accidentcauseover45daysUpdateManyMutationInput = {
    causeovercode?: StringFieldUpdateOperationsInput | string
    causeoverdesc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type accidentcauseover45daysUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    causeovercode?: StringFieldUpdateOperationsInput | string
    causeoverdesc?: NullableStringFieldUpdateOperationsInput | string | null
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type accidentplaceCreateInput = {
    accidentplacecode: string
    accidentplacename?: string | null
    insurers?: insurersCreateNestedOneWithoutAccidentplaceInput
  }

  export type accidentplaceUncheckedCreateInput = {
    id?: number
    accidentplacecode: string
    accidentplacename?: string | null
    insurerid?: number | null
  }

  export type accidentplaceUpdateInput = {
    accidentplacecode?: StringFieldUpdateOperationsInput | string
    accidentplacename?: NullableStringFieldUpdateOperationsInput | string | null
    insurers?: insurersUpdateOneWithoutAccidentplaceNestedInput
  }

  export type accidentplaceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    accidentplacecode?: StringFieldUpdateOperationsInput | string
    accidentplacename?: NullableStringFieldUpdateOperationsInput | string | null
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type accidentplaceCreateManyInput = {
    id?: number
    accidentplacecode: string
    accidentplacename?: string | null
    insurerid?: number | null
  }

  export type accidentplaceUpdateManyMutationInput = {
    accidentplacecode?: StringFieldUpdateOperationsInput | string
    accidentplacename?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type accidentplaceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    accidentplacecode?: StringFieldUpdateOperationsInput | string
    accidentplacename?: NullableStringFieldUpdateOperationsInput | string | null
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type causeofinjurysideCreateInput = {
    injurysidename: string
    injurysidecode?: string | null
    insurers?: insurersCreateNestedOneWithoutCauseofinjurysideInput
  }

  export type causeofinjurysideUncheckedCreateInput = {
    id?: number
    injurysidename: string
    injurysidecode?: string | null
    insurerid?: number | null
  }

  export type causeofinjurysideUpdateInput = {
    injurysidename?: StringFieldUpdateOperationsInput | string
    injurysidecode?: NullableStringFieldUpdateOperationsInput | string | null
    insurers?: insurersUpdateOneWithoutCauseofinjurysideNestedInput
  }

  export type causeofinjurysideUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    injurysidename?: StringFieldUpdateOperationsInput | string
    injurysidecode?: NullableStringFieldUpdateOperationsInput | string | null
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type causeofinjurysideCreateManyInput = {
    id?: number
    injurysidename: string
    injurysidecode?: string | null
    insurerid?: number | null
  }

  export type causeofinjurysideUpdateManyMutationInput = {
    injurysidename?: StringFieldUpdateOperationsInput | string
    injurysidecode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type causeofinjurysideUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    injurysidename?: StringFieldUpdateOperationsInput | string
    injurysidecode?: NullableStringFieldUpdateOperationsInput | string | null
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type causeofinjurywoundtypeCreateInput = {
    woundtypename: string
    woundtypecode?: string | null
    insurers?: insurersCreateNestedOneWithoutCauseofinjurywoundtypeInput
  }

  export type causeofinjurywoundtypeUncheckedCreateInput = {
    id?: number
    woundtypename: string
    woundtypecode?: string | null
    insurerid?: number | null
  }

  export type causeofinjurywoundtypeUpdateInput = {
    woundtypename?: StringFieldUpdateOperationsInput | string
    woundtypecode?: NullableStringFieldUpdateOperationsInput | string | null
    insurers?: insurersUpdateOneWithoutCauseofinjurywoundtypeNestedInput
  }

  export type causeofinjurywoundtypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    woundtypename?: StringFieldUpdateOperationsInput | string
    woundtypecode?: NullableStringFieldUpdateOperationsInput | string | null
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type causeofinjurywoundtypeCreateManyInput = {
    id?: number
    woundtypename: string
    woundtypecode?: string | null
    insurerid?: number | null
  }

  export type causeofinjurywoundtypeUpdateManyMutationInput = {
    woundtypename?: StringFieldUpdateOperationsInput | string
    woundtypecode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type causeofinjurywoundtypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    woundtypename?: StringFieldUpdateOperationsInput | string
    woundtypecode?: NullableStringFieldUpdateOperationsInput | string | null
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type claimantsCreateInput = {
    national_id?: string | null
    passportnumber?: string | null
    hn?: string | null
    patientid?: number | null
    title_th?: string | null
    givenname_th?: string | null
    surname_th?: string | null
    title_en?: string | null
    givenname_en?: string | null
    surname_en?: string | null
    mobilephone?: string | null
    statusactive?: boolean | null
    dateofbirth?: string | null
    gender?: string | null
    registrationdate?: Date | string | null
    insurers?: insurersCreateNestedOneWithoutClaimantsInput
  }

  export type claimantsUncheckedCreateInput = {
    id?: number
    national_id?: string | null
    passportnumber?: string | null
    hn?: string | null
    patientid?: number | null
    title_th?: string | null
    givenname_th?: string | null
    surname_th?: string | null
    title_en?: string | null
    givenname_en?: string | null
    surname_en?: string | null
    mobilephone?: string | null
    statusactive?: boolean | null
    dateofbirth?: string | null
    gender?: string | null
    registrationdate?: Date | string | null
    insurerid?: number | null
  }

  export type claimantsUpdateInput = {
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    passportnumber?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    patientid?: NullableIntFieldUpdateOperationsInput | number | null
    title_th?: NullableStringFieldUpdateOperationsInput | string | null
    givenname_th?: NullableStringFieldUpdateOperationsInput | string | null
    surname_th?: NullableStringFieldUpdateOperationsInput | string | null
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    givenname_en?: NullableStringFieldUpdateOperationsInput | string | null
    surname_en?: NullableStringFieldUpdateOperationsInput | string | null
    mobilephone?: NullableStringFieldUpdateOperationsInput | string | null
    statusactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dateofbirth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    registrationdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insurers?: insurersUpdateOneWithoutClaimantsNestedInput
  }

  export type claimantsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    passportnumber?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    patientid?: NullableIntFieldUpdateOperationsInput | number | null
    title_th?: NullableStringFieldUpdateOperationsInput | string | null
    givenname_th?: NullableStringFieldUpdateOperationsInput | string | null
    surname_th?: NullableStringFieldUpdateOperationsInput | string | null
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    givenname_en?: NullableStringFieldUpdateOperationsInput | string | null
    surname_en?: NullableStringFieldUpdateOperationsInput | string | null
    mobilephone?: NullableStringFieldUpdateOperationsInput | string | null
    statusactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dateofbirth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    registrationdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type claimantsCreateManyInput = {
    id?: number
    national_id?: string | null
    passportnumber?: string | null
    hn?: string | null
    patientid?: number | null
    title_th?: string | null
    givenname_th?: string | null
    surname_th?: string | null
    title_en?: string | null
    givenname_en?: string | null
    surname_en?: string | null
    mobilephone?: string | null
    statusactive?: boolean | null
    dateofbirth?: string | null
    gender?: string | null
    registrationdate?: Date | string | null
    insurerid?: number | null
  }

  export type claimantsUpdateManyMutationInput = {
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    passportnumber?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    patientid?: NullableIntFieldUpdateOperationsInput | number | null
    title_th?: NullableStringFieldUpdateOperationsInput | string | null
    givenname_th?: NullableStringFieldUpdateOperationsInput | string | null
    surname_th?: NullableStringFieldUpdateOperationsInput | string | null
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    givenname_en?: NullableStringFieldUpdateOperationsInput | string | null
    surname_en?: NullableStringFieldUpdateOperationsInput | string | null
    mobilephone?: NullableStringFieldUpdateOperationsInput | string | null
    statusactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dateofbirth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    registrationdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type claimantsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    passportnumber?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    patientid?: NullableIntFieldUpdateOperationsInput | number | null
    title_th?: NullableStringFieldUpdateOperationsInput | string | null
    givenname_th?: NullableStringFieldUpdateOperationsInput | string | null
    surname_th?: NullableStringFieldUpdateOperationsInput | string | null
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    givenname_en?: NullableStringFieldUpdateOperationsInput | string | null
    surname_en?: NullableStringFieldUpdateOperationsInput | string | null
    mobilephone?: NullableStringFieldUpdateOperationsInput | string | null
    statusactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dateofbirth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    registrationdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type claimdocumentsCreateInput = {
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    documentname?: string | null
    documenttypecode?: string | null
    documenttypename?: string | null
    serverpath?: string | null
    filepath: string
    filesize?: bigint | number | null
    filemimetype?: string | null
    uploaddate?: Date | string | null
    uploadedby?: string | null
    insurers?: insurersCreateNestedOneWithoutClaimdocumentsInput
  }

  export type claimdocumentsUncheckedCreateInput = {
    id?: number
    insurerid?: number | null
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    documentname?: string | null
    documenttypecode?: string | null
    documenttypename?: string | null
    serverpath?: string | null
    filepath: string
    filesize?: bigint | number | null
    filemimetype?: string | null
    uploaddate?: Date | string | null
    uploadedby?: string | null
  }

  export type claimdocumentsUpdateInput = {
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    documentname?: NullableStringFieldUpdateOperationsInput | string | null
    documenttypecode?: NullableStringFieldUpdateOperationsInput | string | null
    documenttypename?: NullableStringFieldUpdateOperationsInput | string | null
    serverpath?: NullableStringFieldUpdateOperationsInput | string | null
    filepath?: StringFieldUpdateOperationsInput | string
    filesize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    filemimetype?: NullableStringFieldUpdateOperationsInput | string | null
    uploaddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedby?: NullableStringFieldUpdateOperationsInput | string | null
    insurers?: insurersUpdateOneWithoutClaimdocumentsNestedInput
  }

  export type claimdocumentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    documentname?: NullableStringFieldUpdateOperationsInput | string | null
    documenttypecode?: NullableStringFieldUpdateOperationsInput | string | null
    documenttypename?: NullableStringFieldUpdateOperationsInput | string | null
    serverpath?: NullableStringFieldUpdateOperationsInput | string | null
    filepath?: StringFieldUpdateOperationsInput | string
    filesize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    filemimetype?: NullableStringFieldUpdateOperationsInput | string | null
    uploaddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedby?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type claimdocumentsCreateManyInput = {
    id?: number
    insurerid?: number | null
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    documentname?: string | null
    documenttypecode?: string | null
    documenttypename?: string | null
    serverpath?: string | null
    filepath: string
    filesize?: bigint | number | null
    filemimetype?: string | null
    uploaddate?: Date | string | null
    uploadedby?: string | null
  }

  export type claimdocumentsUpdateManyMutationInput = {
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    documentname?: NullableStringFieldUpdateOperationsInput | string | null
    documenttypecode?: NullableStringFieldUpdateOperationsInput | string | null
    documenttypename?: NullableStringFieldUpdateOperationsInput | string | null
    serverpath?: NullableStringFieldUpdateOperationsInput | string | null
    filepath?: StringFieldUpdateOperationsInput | string
    filesize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    filemimetype?: NullableStringFieldUpdateOperationsInput | string | null
    uploaddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedby?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type claimdocumentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    documentname?: NullableStringFieldUpdateOperationsInput | string | null
    documenttypecode?: NullableStringFieldUpdateOperationsInput | string | null
    documenttypename?: NullableStringFieldUpdateOperationsInput | string | null
    serverpath?: NullableStringFieldUpdateOperationsInput | string | null
    filepath?: StringFieldUpdateOperationsInput | string
    filesize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    filemimetype?: NullableStringFieldUpdateOperationsInput | string | null
    uploaddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedby?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type claimstatusCreateInput = {
    claimstatuscode: string
    claimstatusdesc_th?: string | null
    claimstatusdesc_en?: string | null
    insurers?: insurersCreateNestedOneWithoutClaimstatusInput
    transactionclaimstatus?: transactionclaimstatusCreateNestedManyWithoutClaimstatusInput
  }

  export type claimstatusUncheckedCreateInput = {
    id?: number
    claimstatuscode: string
    claimstatusdesc_th?: string | null
    claimstatusdesc_en?: string | null
    insurerid?: number | null
    transactionclaimstatus?: transactionclaimstatusUncheckedCreateNestedManyWithoutClaimstatusInput
  }

  export type claimstatusUpdateInput = {
    claimstatuscode?: StringFieldUpdateOperationsInput | string
    claimstatusdesc_th?: NullableStringFieldUpdateOperationsInput | string | null
    claimstatusdesc_en?: NullableStringFieldUpdateOperationsInput | string | null
    insurers?: insurersUpdateOneWithoutClaimstatusNestedInput
    transactionclaimstatus?: transactionclaimstatusUpdateManyWithoutClaimstatusNestedInput
  }

  export type claimstatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    claimstatuscode?: StringFieldUpdateOperationsInput | string
    claimstatusdesc_th?: NullableStringFieldUpdateOperationsInput | string | null
    claimstatusdesc_en?: NullableStringFieldUpdateOperationsInput | string | null
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
    transactionclaimstatus?: transactionclaimstatusUncheckedUpdateManyWithoutClaimstatusNestedInput
  }

  export type claimstatusCreateManyInput = {
    id?: number
    claimstatuscode: string
    claimstatusdesc_th?: string | null
    claimstatusdesc_en?: string | null
    insurerid?: number | null
  }

  export type claimstatusUpdateManyMutationInput = {
    claimstatuscode?: StringFieldUpdateOperationsInput | string
    claimstatusdesc_th?: NullableStringFieldUpdateOperationsInput | string | null
    claimstatusdesc_en?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type claimstatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    claimstatuscode?: StringFieldUpdateOperationsInput | string
    claimstatusdesc_th?: NullableStringFieldUpdateOperationsInput | string | null
    claimstatusdesc_en?: NullableStringFieldUpdateOperationsInput | string | null
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type diagnosistypemappingCreateInput = {
    dxtypecodetrakcare: string
    dxtypenametrakcare?: string | null
    dxtypecodeinsurance?: string | null
    dxtypenameinsurance?: string | null
    insurers?: insurersCreateNestedOneWithoutDiagnosistypemappingInput
  }

  export type diagnosistypemappingUncheckedCreateInput = {
    id?: number
    dxtypecodetrakcare: string
    dxtypenametrakcare?: string | null
    dxtypecodeinsurance?: string | null
    dxtypenameinsurance?: string | null
    insurerid?: number | null
  }

  export type diagnosistypemappingUpdateInput = {
    dxtypecodetrakcare?: StringFieldUpdateOperationsInput | string
    dxtypenametrakcare?: NullableStringFieldUpdateOperationsInput | string | null
    dxtypecodeinsurance?: NullableStringFieldUpdateOperationsInput | string | null
    dxtypenameinsurance?: NullableStringFieldUpdateOperationsInput | string | null
    insurers?: insurersUpdateOneWithoutDiagnosistypemappingNestedInput
  }

  export type diagnosistypemappingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dxtypecodetrakcare?: StringFieldUpdateOperationsInput | string
    dxtypenametrakcare?: NullableStringFieldUpdateOperationsInput | string | null
    dxtypecodeinsurance?: NullableStringFieldUpdateOperationsInput | string | null
    dxtypenameinsurance?: NullableStringFieldUpdateOperationsInput | string | null
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type diagnosistypemappingCreateManyInput = {
    id?: number
    dxtypecodetrakcare: string
    dxtypenametrakcare?: string | null
    dxtypecodeinsurance?: string | null
    dxtypenameinsurance?: string | null
    insurerid?: number | null
  }

  export type diagnosistypemappingUpdateManyMutationInput = {
    dxtypecodetrakcare?: StringFieldUpdateOperationsInput | string
    dxtypenametrakcare?: NullableStringFieldUpdateOperationsInput | string | null
    dxtypecodeinsurance?: NullableStringFieldUpdateOperationsInput | string | null
    dxtypenameinsurance?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type diagnosistypemappingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dxtypecodetrakcare?: StringFieldUpdateOperationsInput | string
    dxtypenametrakcare?: NullableStringFieldUpdateOperationsInput | string | null
    dxtypecodeinsurance?: NullableStringFieldUpdateOperationsInput | string | null
    dxtypenameinsurance?: NullableStringFieldUpdateOperationsInput | string | null
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type documenttypeCreateInput = {
    documenttypecode: string
    documenttypename?: string | null
    insurers?: insurersCreateNestedOneWithoutDocumenttypeInput
  }

  export type documenttypeUncheckedCreateInput = {
    id?: number
    documenttypecode: string
    documenttypename?: string | null
    insurerid?: number | null
  }

  export type documenttypeUpdateInput = {
    documenttypecode?: StringFieldUpdateOperationsInput | string
    documenttypename?: NullableStringFieldUpdateOperationsInput | string | null
    insurers?: insurersUpdateOneWithoutDocumenttypeNestedInput
  }

  export type documenttypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    documenttypecode?: StringFieldUpdateOperationsInput | string
    documenttypename?: NullableStringFieldUpdateOperationsInput | string | null
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type documenttypeCreateManyInput = {
    id?: number
    documenttypecode: string
    documenttypename?: string | null
    insurerid?: number | null
  }

  export type documenttypeUpdateManyMutationInput = {
    documenttypecode?: StringFieldUpdateOperationsInput | string
    documenttypename?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type documenttypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    documenttypecode?: StringFieldUpdateOperationsInput | string
    documenttypename?: NullableStringFieldUpdateOperationsInput | string | null
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type illnesssurgeryCreateInput = {
    iscode: string
    isdesc?: string | null
    insurers?: insurersCreateNestedOneWithoutIllnesssurgeryInput
  }

  export type illnesssurgeryUncheckedCreateInput = {
    id?: number
    iscode: string
    isdesc?: string | null
    insurerid?: number | null
  }

  export type illnesssurgeryUpdateInput = {
    iscode?: StringFieldUpdateOperationsInput | string
    isdesc?: NullableStringFieldUpdateOperationsInput | string | null
    insurers?: insurersUpdateOneWithoutIllnesssurgeryNestedInput
  }

  export type illnesssurgeryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    iscode?: StringFieldUpdateOperationsInput | string
    isdesc?: NullableStringFieldUpdateOperationsInput | string | null
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type illnesssurgeryCreateManyInput = {
    id?: number
    iscode: string
    isdesc?: string | null
    insurerid?: number | null
  }

  export type illnesssurgeryUpdateManyMutationInput = {
    iscode?: StringFieldUpdateOperationsInput | string
    isdesc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type illnesssurgeryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    iscode?: StringFieldUpdateOperationsInput | string
    isdesc?: NullableStringFieldUpdateOperationsInput | string | null
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type illnesstypeCreateInput = {
    illnesstypecode: string
    illnesstypedesc?: string | null
    insurers?: insurersCreateNestedOneWithoutIllnesstypeInput
  }

  export type illnesstypeUncheckedCreateInput = {
    id?: number
    illnesstypecode: string
    illnesstypedesc?: string | null
    insurerid?: number | null
  }

  export type illnesstypeUpdateInput = {
    illnesstypecode?: StringFieldUpdateOperationsInput | string
    illnesstypedesc?: NullableStringFieldUpdateOperationsInput | string | null
    insurers?: insurersUpdateOneWithoutIllnesstypeNestedInput
  }

  export type illnesstypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    illnesstypecode?: StringFieldUpdateOperationsInput | string
    illnesstypedesc?: NullableStringFieldUpdateOperationsInput | string | null
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type illnesstypeCreateManyInput = {
    id?: number
    illnesstypecode: string
    illnesstypedesc?: string | null
    insurerid?: number | null
  }

  export type illnesstypeUpdateManyMutationInput = {
    illnesstypecode?: StringFieldUpdateOperationsInput | string
    illnesstypedesc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type illnesstypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    illnesstypecode?: StringFieldUpdateOperationsInput | string
    illnesstypedesc?: NullableStringFieldUpdateOperationsInput | string | null
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type insurersCreateInput = {
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentcauseover45days?: accidentcauseover45daysCreateNestedManyWithoutInsurersInput
    accidentplace?: accidentplaceCreateNestedManyWithoutInsurersInput
    accidenttransactions?: accidenttransactionsCreateNestedManyWithoutInsurersInput
    accidenttransactions22?: accidenttransactions22CreateNestedManyWithoutInsurersInput
    causeofinjuryside?: causeofinjurysideCreateNestedManyWithoutInsurersInput
    causeofinjurywoundtype?: causeofinjurywoundtypeCreateNestedManyWithoutInsurersInput
    claimants?: claimantsCreateNestedManyWithoutInsurersInput
    claimdocuments?: claimdocumentsCreateNestedManyWithoutInsurersInput
    claimstatus?: claimstatusCreateNestedManyWithoutInsurersInput
    diagnosistypemapping?: diagnosistypemappingCreateNestedManyWithoutInsurersInput
    documenttype?: documenttypeCreateNestedManyWithoutInsurersInput
    illnesssurgery?: illnesssurgeryCreateNestedManyWithoutInsurersInput
    illnesstype?: illnesstypeCreateNestedManyWithoutInsurersInput
    policytype?: policytypeCreateNestedManyWithoutInsurersInput
    proceduretransactions?: proceduretransactionsCreateNestedManyWithoutInsurersInput
    servicesetting?: servicesettingCreateNestedManyWithoutInsurersInput
  }

  export type insurersUncheckedCreateInput = {
    id?: number
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentcauseover45days?: accidentcauseover45daysUncheckedCreateNestedManyWithoutInsurersInput
    accidentplace?: accidentplaceUncheckedCreateNestedManyWithoutInsurersInput
    accidenttransactions?: accidenttransactionsUncheckedCreateNestedManyWithoutInsurersInput
    accidenttransactions22?: accidenttransactions22UncheckedCreateNestedManyWithoutInsurersInput
    causeofinjuryside?: causeofinjurysideUncheckedCreateNestedManyWithoutInsurersInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUncheckedCreateNestedManyWithoutInsurersInput
    claimants?: claimantsUncheckedCreateNestedManyWithoutInsurersInput
    claimdocuments?: claimdocumentsUncheckedCreateNestedManyWithoutInsurersInput
    claimstatus?: claimstatusUncheckedCreateNestedManyWithoutInsurersInput
    diagnosistypemapping?: diagnosistypemappingUncheckedCreateNestedManyWithoutInsurersInput
    documenttype?: documenttypeUncheckedCreateNestedManyWithoutInsurersInput
    illnesssurgery?: illnesssurgeryUncheckedCreateNestedManyWithoutInsurersInput
    illnesstype?: illnesstypeUncheckedCreateNestedManyWithoutInsurersInput
    policytype?: policytypeUncheckedCreateNestedManyWithoutInsurersInput
    proceduretransactions?: proceduretransactionsUncheckedCreateNestedManyWithoutInsurersInput
    servicesetting?: servicesettingUncheckedCreateNestedManyWithoutInsurersInput
  }

  export type insurersUpdateInput = {
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: accidentcauseover45daysUpdateManyWithoutInsurersNestedInput
    accidentplace?: accidentplaceUpdateManyWithoutInsurersNestedInput
    accidenttransactions?: accidenttransactionsUpdateManyWithoutInsurersNestedInput
    accidenttransactions22?: accidenttransactions22UpdateManyWithoutInsurersNestedInput
    causeofinjuryside?: causeofinjurysideUpdateManyWithoutInsurersNestedInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUpdateManyWithoutInsurersNestedInput
    claimants?: claimantsUpdateManyWithoutInsurersNestedInput
    claimdocuments?: claimdocumentsUpdateManyWithoutInsurersNestedInput
    claimstatus?: claimstatusUpdateManyWithoutInsurersNestedInput
    diagnosistypemapping?: diagnosistypemappingUpdateManyWithoutInsurersNestedInput
    documenttype?: documenttypeUpdateManyWithoutInsurersNestedInput
    illnesssurgery?: illnesssurgeryUpdateManyWithoutInsurersNestedInput
    illnesstype?: illnesstypeUpdateManyWithoutInsurersNestedInput
    policytype?: policytypeUpdateManyWithoutInsurersNestedInput
    proceduretransactions?: proceduretransactionsUpdateManyWithoutInsurersNestedInput
    servicesetting?: servicesettingUpdateManyWithoutInsurersNestedInput
  }

  export type insurersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: accidentcauseover45daysUncheckedUpdateManyWithoutInsurersNestedInput
    accidentplace?: accidentplaceUncheckedUpdateManyWithoutInsurersNestedInput
    accidenttransactions?: accidenttransactionsUncheckedUpdateManyWithoutInsurersNestedInput
    accidenttransactions22?: accidenttransactions22UncheckedUpdateManyWithoutInsurersNestedInput
    causeofinjuryside?: causeofinjurysideUncheckedUpdateManyWithoutInsurersNestedInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUncheckedUpdateManyWithoutInsurersNestedInput
    claimants?: claimantsUncheckedUpdateManyWithoutInsurersNestedInput
    claimdocuments?: claimdocumentsUncheckedUpdateManyWithoutInsurersNestedInput
    claimstatus?: claimstatusUncheckedUpdateManyWithoutInsurersNestedInput
    diagnosistypemapping?: diagnosistypemappingUncheckedUpdateManyWithoutInsurersNestedInput
    documenttype?: documenttypeUncheckedUpdateManyWithoutInsurersNestedInput
    illnesssurgery?: illnesssurgeryUncheckedUpdateManyWithoutInsurersNestedInput
    illnesstype?: illnesstypeUncheckedUpdateManyWithoutInsurersNestedInput
    policytype?: policytypeUncheckedUpdateManyWithoutInsurersNestedInput
    proceduretransactions?: proceduretransactionsUncheckedUpdateManyWithoutInsurersNestedInput
    servicesetting?: servicesettingUncheckedUpdateManyWithoutInsurersNestedInput
  }

  export type insurersCreateManyInput = {
    id?: number
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
  }

  export type insurersUpdateManyMutationInput = {
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type insurersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type medicaltransactionsCreateInput = {
    insurerid?: number | null
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    dxfreetext?: string | null
    presentillness?: string | null
    chiefcomplaint?: string | null
    accidentcauseover45days?: string | null
    underlyingcondition?: string | null
    physicalexam?: string | null
    planoftreatment?: string | null
    procedurefreetext?: string | null
    additionalnote?: string | null
    signsymptomsdate?: string | null
    comascore?: string | null
    expecteddayofrecovery?: string | null
    pregnant?: boolean | null
    alcoholrelated?: boolean | null
    haveaccidentinjurydetail?: boolean | null
    haveaccidentcauseofinjurydetail?: boolean | null
    haveprocedure?: boolean | null
    privatecase?: boolean | null
  }

  export type medicaltransactionsUncheckedCreateInput = {
    id?: number
    insurerid?: number | null
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    dxfreetext?: string | null
    presentillness?: string | null
    chiefcomplaint?: string | null
    accidentcauseover45days?: string | null
    underlyingcondition?: string | null
    physicalexam?: string | null
    planoftreatment?: string | null
    procedurefreetext?: string | null
    additionalnote?: string | null
    signsymptomsdate?: string | null
    comascore?: string | null
    expecteddayofrecovery?: string | null
    pregnant?: boolean | null
    alcoholrelated?: boolean | null
    haveaccidentinjurydetail?: boolean | null
    haveaccidentcauseofinjurydetail?: boolean | null
    haveprocedure?: boolean | null
    privatecase?: boolean | null
  }

  export type medicaltransactionsUpdateInput = {
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    dxfreetext?: NullableStringFieldUpdateOperationsInput | string | null
    presentillness?: NullableStringFieldUpdateOperationsInput | string | null
    chiefcomplaint?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: NullableStringFieldUpdateOperationsInput | string | null
    underlyingcondition?: NullableStringFieldUpdateOperationsInput | string | null
    physicalexam?: NullableStringFieldUpdateOperationsInput | string | null
    planoftreatment?: NullableStringFieldUpdateOperationsInput | string | null
    procedurefreetext?: NullableStringFieldUpdateOperationsInput | string | null
    additionalnote?: NullableStringFieldUpdateOperationsInput | string | null
    signsymptomsdate?: NullableStringFieldUpdateOperationsInput | string | null
    comascore?: NullableStringFieldUpdateOperationsInput | string | null
    expecteddayofrecovery?: NullableStringFieldUpdateOperationsInput | string | null
    pregnant?: NullableBoolFieldUpdateOperationsInput | boolean | null
    alcoholrelated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    haveaccidentinjurydetail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    haveaccidentcauseofinjurydetail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    haveprocedure?: NullableBoolFieldUpdateOperationsInput | boolean | null
    privatecase?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type medicaltransactionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    dxfreetext?: NullableStringFieldUpdateOperationsInput | string | null
    presentillness?: NullableStringFieldUpdateOperationsInput | string | null
    chiefcomplaint?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: NullableStringFieldUpdateOperationsInput | string | null
    underlyingcondition?: NullableStringFieldUpdateOperationsInput | string | null
    physicalexam?: NullableStringFieldUpdateOperationsInput | string | null
    planoftreatment?: NullableStringFieldUpdateOperationsInput | string | null
    procedurefreetext?: NullableStringFieldUpdateOperationsInput | string | null
    additionalnote?: NullableStringFieldUpdateOperationsInput | string | null
    signsymptomsdate?: NullableStringFieldUpdateOperationsInput | string | null
    comascore?: NullableStringFieldUpdateOperationsInput | string | null
    expecteddayofrecovery?: NullableStringFieldUpdateOperationsInput | string | null
    pregnant?: NullableBoolFieldUpdateOperationsInput | boolean | null
    alcoholrelated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    haveaccidentinjurydetail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    haveaccidentcauseofinjurydetail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    haveprocedure?: NullableBoolFieldUpdateOperationsInput | boolean | null
    privatecase?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type medicaltransactionsCreateManyInput = {
    id?: number
    insurerid?: number | null
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    dxfreetext?: string | null
    presentillness?: string | null
    chiefcomplaint?: string | null
    accidentcauseover45days?: string | null
    underlyingcondition?: string | null
    physicalexam?: string | null
    planoftreatment?: string | null
    procedurefreetext?: string | null
    additionalnote?: string | null
    signsymptomsdate?: string | null
    comascore?: string | null
    expecteddayofrecovery?: string | null
    pregnant?: boolean | null
    alcoholrelated?: boolean | null
    haveaccidentinjurydetail?: boolean | null
    haveaccidentcauseofinjurydetail?: boolean | null
    haveprocedure?: boolean | null
    privatecase?: boolean | null
  }

  export type medicaltransactionsUpdateManyMutationInput = {
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    dxfreetext?: NullableStringFieldUpdateOperationsInput | string | null
    presentillness?: NullableStringFieldUpdateOperationsInput | string | null
    chiefcomplaint?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: NullableStringFieldUpdateOperationsInput | string | null
    underlyingcondition?: NullableStringFieldUpdateOperationsInput | string | null
    physicalexam?: NullableStringFieldUpdateOperationsInput | string | null
    planoftreatment?: NullableStringFieldUpdateOperationsInput | string | null
    procedurefreetext?: NullableStringFieldUpdateOperationsInput | string | null
    additionalnote?: NullableStringFieldUpdateOperationsInput | string | null
    signsymptomsdate?: NullableStringFieldUpdateOperationsInput | string | null
    comascore?: NullableStringFieldUpdateOperationsInput | string | null
    expecteddayofrecovery?: NullableStringFieldUpdateOperationsInput | string | null
    pregnant?: NullableBoolFieldUpdateOperationsInput | boolean | null
    alcoholrelated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    haveaccidentinjurydetail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    haveaccidentcauseofinjurydetail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    haveprocedure?: NullableBoolFieldUpdateOperationsInput | boolean | null
    privatecase?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type medicaltransactionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    dxfreetext?: NullableStringFieldUpdateOperationsInput | string | null
    presentillness?: NullableStringFieldUpdateOperationsInput | string | null
    chiefcomplaint?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: NullableStringFieldUpdateOperationsInput | string | null
    underlyingcondition?: NullableStringFieldUpdateOperationsInput | string | null
    physicalexam?: NullableStringFieldUpdateOperationsInput | string | null
    planoftreatment?: NullableStringFieldUpdateOperationsInput | string | null
    procedurefreetext?: NullableStringFieldUpdateOperationsInput | string | null
    additionalnote?: NullableStringFieldUpdateOperationsInput | string | null
    signsymptomsdate?: NullableStringFieldUpdateOperationsInput | string | null
    comascore?: NullableStringFieldUpdateOperationsInput | string | null
    expecteddayofrecovery?: NullableStringFieldUpdateOperationsInput | string | null
    pregnant?: NullableBoolFieldUpdateOperationsInput | boolean | null
    alcoholrelated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    haveaccidentinjurydetail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    haveaccidentcauseofinjurydetail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    haveprocedure?: NullableBoolFieldUpdateOperationsInput | boolean | null
    privatecase?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type policytypeCreateInput = {
    policytypecode: string
    policytypedesc?: string | null
    insurers?: insurersCreateNestedOneWithoutPolicytypeInput
  }

  export type policytypeUncheckedCreateInput = {
    id?: number
    policytypecode: string
    policytypedesc?: string | null
    insurerid?: number | null
  }

  export type policytypeUpdateInput = {
    policytypecode?: StringFieldUpdateOperationsInput | string
    policytypedesc?: NullableStringFieldUpdateOperationsInput | string | null
    insurers?: insurersUpdateOneWithoutPolicytypeNestedInput
  }

  export type policytypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    policytypecode?: StringFieldUpdateOperationsInput | string
    policytypedesc?: NullableStringFieldUpdateOperationsInput | string | null
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type policytypeCreateManyInput = {
    id?: number
    policytypecode: string
    policytypedesc?: string | null
    insurerid?: number | null
  }

  export type policytypeUpdateManyMutationInput = {
    policytypecode?: StringFieldUpdateOperationsInput | string
    policytypedesc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type policytypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    policytypecode?: StringFieldUpdateOperationsInput | string
    policytypedesc?: NullableStringFieldUpdateOperationsInput | string | null
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type servicesettingCreateInput = {
    servicesettingcode: string
    servicesettingdesc: string
    insurers?: insurersCreateNestedOneWithoutServicesettingInput
  }

  export type servicesettingUncheckedCreateInput = {
    id?: number
    servicesettingcode: string
    servicesettingdesc: string
    insurerid?: number | null
  }

  export type servicesettingUpdateInput = {
    servicesettingcode?: StringFieldUpdateOperationsInput | string
    servicesettingdesc?: StringFieldUpdateOperationsInput | string
    insurers?: insurersUpdateOneWithoutServicesettingNestedInput
  }

  export type servicesettingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    servicesettingcode?: StringFieldUpdateOperationsInput | string
    servicesettingdesc?: StringFieldUpdateOperationsInput | string
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type servicesettingCreateManyInput = {
    id?: number
    servicesettingcode: string
    servicesettingdesc: string
    insurerid?: number | null
  }

  export type servicesettingUpdateManyMutationInput = {
    servicesettingcode?: StringFieldUpdateOperationsInput | string
    servicesettingdesc?: StringFieldUpdateOperationsInput | string
  }

  export type servicesettingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    servicesettingcode?: StringFieldUpdateOperationsInput | string
    servicesettingdesc?: StringFieldUpdateOperationsInput | string
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type transactionclaimCreateInput = {
    insurerid?: number | null
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    visitdate?: string | null
    accidentdate?: string | null
    messageclaim?: string | null
    messageth?: string | null
    claimno?: string | null
    claimstatuscode?: string | null
    status_changed_at?: Date | string | null
    occurrenceno?: string | null
    totalapprovedamount?: Decimal | DecimalJsLike | number | string | null
    totalexcessamount?: Decimal | DecimalJsLike | number | string | null
    isreimbursement?: boolean | null
    batchnumber?: string | null
    invoicenumber?: string | null
    otherinsurer?: boolean | null
    furtherclaimid?: string | null
    furtherclaimno?: string | null
    privatecase?: boolean | null
    previoustreatmentdate?: string | null
    previoustreatmentdetail?: string | null
  }

  export type transactionclaimUncheckedCreateInput = {
    id?: number
    insurerid?: number | null
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    visitdate?: string | null
    accidentdate?: string | null
    messageclaim?: string | null
    messageth?: string | null
    claimno?: string | null
    claimstatuscode?: string | null
    status_changed_at?: Date | string | null
    occurrenceno?: string | null
    totalapprovedamount?: Decimal | DecimalJsLike | number | string | null
    totalexcessamount?: Decimal | DecimalJsLike | number | string | null
    isreimbursement?: boolean | null
    batchnumber?: string | null
    invoicenumber?: string | null
    otherinsurer?: boolean | null
    furtherclaimid?: string | null
    furtherclaimno?: string | null
    privatecase?: boolean | null
    previoustreatmentdate?: string | null
    previoustreatmentdetail?: string | null
  }

  export type transactionclaimUpdateInput = {
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    visitdate?: NullableStringFieldUpdateOperationsInput | string | null
    accidentdate?: NullableStringFieldUpdateOperationsInput | string | null
    messageclaim?: NullableStringFieldUpdateOperationsInput | string | null
    messageth?: NullableStringFieldUpdateOperationsInput | string | null
    claimno?: NullableStringFieldUpdateOperationsInput | string | null
    claimstatuscode?: NullableStringFieldUpdateOperationsInput | string | null
    status_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    occurrenceno?: NullableStringFieldUpdateOperationsInput | string | null
    totalapprovedamount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalexcessamount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isreimbursement?: NullableBoolFieldUpdateOperationsInput | boolean | null
    batchnumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoicenumber?: NullableStringFieldUpdateOperationsInput | string | null
    otherinsurer?: NullableBoolFieldUpdateOperationsInput | boolean | null
    furtherclaimid?: NullableStringFieldUpdateOperationsInput | string | null
    furtherclaimno?: NullableStringFieldUpdateOperationsInput | string | null
    privatecase?: NullableBoolFieldUpdateOperationsInput | boolean | null
    previoustreatmentdate?: NullableStringFieldUpdateOperationsInput | string | null
    previoustreatmentdetail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type transactionclaimUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    visitdate?: NullableStringFieldUpdateOperationsInput | string | null
    accidentdate?: NullableStringFieldUpdateOperationsInput | string | null
    messageclaim?: NullableStringFieldUpdateOperationsInput | string | null
    messageth?: NullableStringFieldUpdateOperationsInput | string | null
    claimno?: NullableStringFieldUpdateOperationsInput | string | null
    claimstatuscode?: NullableStringFieldUpdateOperationsInput | string | null
    status_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    occurrenceno?: NullableStringFieldUpdateOperationsInput | string | null
    totalapprovedamount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalexcessamount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isreimbursement?: NullableBoolFieldUpdateOperationsInput | boolean | null
    batchnumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoicenumber?: NullableStringFieldUpdateOperationsInput | string | null
    otherinsurer?: NullableBoolFieldUpdateOperationsInput | boolean | null
    furtherclaimid?: NullableStringFieldUpdateOperationsInput | string | null
    furtherclaimno?: NullableStringFieldUpdateOperationsInput | string | null
    privatecase?: NullableBoolFieldUpdateOperationsInput | boolean | null
    previoustreatmentdate?: NullableStringFieldUpdateOperationsInput | string | null
    previoustreatmentdetail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type transactionclaimCreateManyInput = {
    id?: number
    insurerid?: number | null
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    visitdate?: string | null
    accidentdate?: string | null
    messageclaim?: string | null
    messageth?: string | null
    claimno?: string | null
    claimstatuscode?: string | null
    status_changed_at?: Date | string | null
    occurrenceno?: string | null
    totalapprovedamount?: Decimal | DecimalJsLike | number | string | null
    totalexcessamount?: Decimal | DecimalJsLike | number | string | null
    isreimbursement?: boolean | null
    batchnumber?: string | null
    invoicenumber?: string | null
    otherinsurer?: boolean | null
    furtherclaimid?: string | null
    furtherclaimno?: string | null
    privatecase?: boolean | null
    previoustreatmentdate?: string | null
    previoustreatmentdetail?: string | null
  }

  export type transactionclaimUpdateManyMutationInput = {
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    visitdate?: NullableStringFieldUpdateOperationsInput | string | null
    accidentdate?: NullableStringFieldUpdateOperationsInput | string | null
    messageclaim?: NullableStringFieldUpdateOperationsInput | string | null
    messageth?: NullableStringFieldUpdateOperationsInput | string | null
    claimno?: NullableStringFieldUpdateOperationsInput | string | null
    claimstatuscode?: NullableStringFieldUpdateOperationsInput | string | null
    status_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    occurrenceno?: NullableStringFieldUpdateOperationsInput | string | null
    totalapprovedamount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalexcessamount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isreimbursement?: NullableBoolFieldUpdateOperationsInput | boolean | null
    batchnumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoicenumber?: NullableStringFieldUpdateOperationsInput | string | null
    otherinsurer?: NullableBoolFieldUpdateOperationsInput | boolean | null
    furtherclaimid?: NullableStringFieldUpdateOperationsInput | string | null
    furtherclaimno?: NullableStringFieldUpdateOperationsInput | string | null
    privatecase?: NullableBoolFieldUpdateOperationsInput | boolean | null
    previoustreatmentdate?: NullableStringFieldUpdateOperationsInput | string | null
    previoustreatmentdetail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type transactionclaimUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    visitdate?: NullableStringFieldUpdateOperationsInput | string | null
    accidentdate?: NullableStringFieldUpdateOperationsInput | string | null
    messageclaim?: NullableStringFieldUpdateOperationsInput | string | null
    messageth?: NullableStringFieldUpdateOperationsInput | string | null
    claimno?: NullableStringFieldUpdateOperationsInput | string | null
    claimstatuscode?: NullableStringFieldUpdateOperationsInput | string | null
    status_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    occurrenceno?: NullableStringFieldUpdateOperationsInput | string | null
    totalapprovedamount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalexcessamount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isreimbursement?: NullableBoolFieldUpdateOperationsInput | boolean | null
    batchnumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoicenumber?: NullableStringFieldUpdateOperationsInput | string | null
    otherinsurer?: NullableBoolFieldUpdateOperationsInput | boolean | null
    furtherclaimid?: NullableStringFieldUpdateOperationsInput | string | null
    furtherclaimno?: NullableStringFieldUpdateOperationsInput | string | null
    privatecase?: NullableBoolFieldUpdateOperationsInput | boolean | null
    previoustreatmentdate?: NullableStringFieldUpdateOperationsInput | string | null
    previoustreatmentdetail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type transactionclaimstatusCreateInput = {
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    batchnumber?: string | null
    claimno?: string | null
    invoicenumber?: string | null
    status_changed_at?: Date | string | null
    note?: string | null
    totalapproveamount?: string | null
    paymentdate?: string | null
    claimstatus?: claimstatusCreateNestedOneWithoutTransactionclaimstatusInput
  }

  export type transactionclaimstatusUncheckedCreateInput = {
    id?: number
    insurerid?: number | null
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    batchnumber?: string | null
    claimno?: string | null
    invoicenumber?: string | null
    status_changed_at?: Date | string | null
    note?: string | null
    totalapproveamount?: string | null
    paymentdate?: string | null
    claimstatuscode?: string | null
  }

  export type transactionclaimstatusUpdateInput = {
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    batchnumber?: NullableStringFieldUpdateOperationsInput | string | null
    claimno?: NullableStringFieldUpdateOperationsInput | string | null
    invoicenumber?: NullableStringFieldUpdateOperationsInput | string | null
    status_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    totalapproveamount?: NullableStringFieldUpdateOperationsInput | string | null
    paymentdate?: NullableStringFieldUpdateOperationsInput | string | null
    claimstatus?: claimstatusUpdateOneWithoutTransactionclaimstatusNestedInput
  }

  export type transactionclaimstatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    batchnumber?: NullableStringFieldUpdateOperationsInput | string | null
    claimno?: NullableStringFieldUpdateOperationsInput | string | null
    invoicenumber?: NullableStringFieldUpdateOperationsInput | string | null
    status_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    totalapproveamount?: NullableStringFieldUpdateOperationsInput | string | null
    paymentdate?: NullableStringFieldUpdateOperationsInput | string | null
    claimstatuscode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type transactionclaimstatusCreateManyInput = {
    id?: number
    insurerid?: number | null
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    batchnumber?: string | null
    claimno?: string | null
    invoicenumber?: string | null
    status_changed_at?: Date | string | null
    note?: string | null
    totalapproveamount?: string | null
    paymentdate?: string | null
    claimstatuscode?: string | null
  }

  export type transactionclaimstatusUpdateManyMutationInput = {
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    batchnumber?: NullableStringFieldUpdateOperationsInput | string | null
    claimno?: NullableStringFieldUpdateOperationsInput | string | null
    invoicenumber?: NullableStringFieldUpdateOperationsInput | string | null
    status_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    totalapproveamount?: NullableStringFieldUpdateOperationsInput | string | null
    paymentdate?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type transactionclaimstatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    batchnumber?: NullableStringFieldUpdateOperationsInput | string | null
    claimno?: NullableStringFieldUpdateOperationsInput | string | null
    invoicenumber?: NullableStringFieldUpdateOperationsInput | string | null
    status_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    totalapproveamount?: NullableStringFieldUpdateOperationsInput | string | null
    paymentdate?: NullableStringFieldUpdateOperationsInput | string | null
    claimstatuscode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type accidenttransactionsCreateInput = {
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    accidentplace?: string | null
    accidentdate?: string | null
    insurers?: insurersCreateNestedOneWithoutAccidenttransactionsInput
    causeofinjurydetail?: causeofinjurydetailCreateNestedManyWithoutAccidenttransactionsInput
    injurydetail?: injurydetailCreateNestedManyWithoutAccidenttransactionsInput
  }

  export type accidenttransactionsUncheckedCreateInput = {
    id?: number
    insurerid?: number | null
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    accidentplace?: string | null
    accidentdate?: string | null
    causeofinjurydetail?: causeofinjurydetailUncheckedCreateNestedManyWithoutAccidenttransactionsInput
    injurydetail?: injurydetailUncheckedCreateNestedManyWithoutAccidenttransactionsInput
  }

  export type accidenttransactionsUpdateInput = {
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    accidentplace?: NullableStringFieldUpdateOperationsInput | string | null
    accidentdate?: NullableStringFieldUpdateOperationsInput | string | null
    insurers?: insurersUpdateOneWithoutAccidenttransactionsNestedInput
    causeofinjurydetail?: causeofinjurydetailUpdateManyWithoutAccidenttransactionsNestedInput
    injurydetail?: injurydetailUpdateManyWithoutAccidenttransactionsNestedInput
  }

  export type accidenttransactionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    accidentplace?: NullableStringFieldUpdateOperationsInput | string | null
    accidentdate?: NullableStringFieldUpdateOperationsInput | string | null
    causeofinjurydetail?: causeofinjurydetailUncheckedUpdateManyWithoutAccidenttransactionsNestedInput
    injurydetail?: injurydetailUncheckedUpdateManyWithoutAccidenttransactionsNestedInput
  }

  export type accidenttransactionsCreateManyInput = {
    id?: number
    insurerid?: number | null
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    accidentplace?: string | null
    accidentdate?: string | null
  }

  export type accidenttransactionsUpdateManyMutationInput = {
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    accidentplace?: NullableStringFieldUpdateOperationsInput | string | null
    accidentdate?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type accidenttransactionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    accidentplace?: NullableStringFieldUpdateOperationsInput | string | null
    accidentdate?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type proceduretransactionsCreateInput = {
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    icd9?: string | null
    procedurename?: string | null
    proceduredate?: string | null
    insurers?: insurersCreateNestedOneWithoutProceduretransactionsInput
  }

  export type proceduretransactionsUncheckedCreateInput = {
    id?: number
    insurerid?: number | null
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    icd9?: string | null
    procedurename?: string | null
    proceduredate?: string | null
  }

  export type proceduretransactionsUpdateInput = {
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    icd9?: NullableStringFieldUpdateOperationsInput | string | null
    procedurename?: NullableStringFieldUpdateOperationsInput | string | null
    proceduredate?: NullableStringFieldUpdateOperationsInput | string | null
    insurers?: insurersUpdateOneWithoutProceduretransactionsNestedInput
  }

  export type proceduretransactionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    icd9?: NullableStringFieldUpdateOperationsInput | string | null
    procedurename?: NullableStringFieldUpdateOperationsInput | string | null
    proceduredate?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type proceduretransactionsCreateManyInput = {
    id?: number
    insurerid?: number | null
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    icd9?: string | null
    procedurename?: string | null
    proceduredate?: string | null
  }

  export type proceduretransactionsUpdateManyMutationInput = {
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    icd9?: NullableStringFieldUpdateOperationsInput | string | null
    procedurename?: NullableStringFieldUpdateOperationsInput | string | null
    proceduredate?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type proceduretransactionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    icd9?: NullableStringFieldUpdateOperationsInput | string | null
    procedurename?: NullableStringFieldUpdateOperationsInput | string | null
    proceduredate?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type accidenttransactions22CreateInput = {
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    accidentplace?: string | null
    accidentdate?: string | null
    causeofinjury?: string | null
    commentofinjury?: string | null
    woundtype?: string | null
    injuryside?: string | null
    injuryarea?: string | null
    insurers?: insurersCreateNestedOneWithoutAccidenttransactions22Input
  }

  export type accidenttransactions22UncheckedCreateInput = {
    id?: number
    insurerid?: number | null
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    accidentplace?: string | null
    accidentdate?: string | null
    causeofinjury?: string | null
    commentofinjury?: string | null
    woundtype?: string | null
    injuryside?: string | null
    injuryarea?: string | null
  }

  export type accidenttransactions22UpdateInput = {
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    accidentplace?: NullableStringFieldUpdateOperationsInput | string | null
    accidentdate?: NullableStringFieldUpdateOperationsInput | string | null
    causeofinjury?: NullableStringFieldUpdateOperationsInput | string | null
    commentofinjury?: NullableStringFieldUpdateOperationsInput | string | null
    woundtype?: NullableStringFieldUpdateOperationsInput | string | null
    injuryside?: NullableStringFieldUpdateOperationsInput | string | null
    injuryarea?: NullableStringFieldUpdateOperationsInput | string | null
    insurers?: insurersUpdateOneWithoutAccidenttransactions22NestedInput
  }

  export type accidenttransactions22UncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    accidentplace?: NullableStringFieldUpdateOperationsInput | string | null
    accidentdate?: NullableStringFieldUpdateOperationsInput | string | null
    causeofinjury?: NullableStringFieldUpdateOperationsInput | string | null
    commentofinjury?: NullableStringFieldUpdateOperationsInput | string | null
    woundtype?: NullableStringFieldUpdateOperationsInput | string | null
    injuryside?: NullableStringFieldUpdateOperationsInput | string | null
    injuryarea?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type accidenttransactions22CreateManyInput = {
    id?: number
    insurerid?: number | null
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    accidentplace?: string | null
    accidentdate?: string | null
    causeofinjury?: string | null
    commentofinjury?: string | null
    woundtype?: string | null
    injuryside?: string | null
    injuryarea?: string | null
  }

  export type accidenttransactions22UpdateManyMutationInput = {
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    accidentplace?: NullableStringFieldUpdateOperationsInput | string | null
    accidentdate?: NullableStringFieldUpdateOperationsInput | string | null
    causeofinjury?: NullableStringFieldUpdateOperationsInput | string | null
    commentofinjury?: NullableStringFieldUpdateOperationsInput | string | null
    woundtype?: NullableStringFieldUpdateOperationsInput | string | null
    injuryside?: NullableStringFieldUpdateOperationsInput | string | null
    injuryarea?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type accidenttransactions22UncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    accidentplace?: NullableStringFieldUpdateOperationsInput | string | null
    accidentdate?: NullableStringFieldUpdateOperationsInput | string | null
    causeofinjury?: NullableStringFieldUpdateOperationsInput | string | null
    commentofinjury?: NullableStringFieldUpdateOperationsInput | string | null
    woundtype?: NullableStringFieldUpdateOperationsInput | string | null
    injuryside?: NullableStringFieldUpdateOperationsInput | string | null
    injuryarea?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type causeofinjurydetailCreateInput = {
    causeofinjury?: string | null
    commentofinjury?: string | null
    accidenttransactions?: accidenttransactionsCreateNestedOneWithoutCauseofinjurydetailInput
  }

  export type causeofinjurydetailUncheckedCreateInput = {
    id?: number
    accidentid?: number | null
    causeofinjury?: string | null
    commentofinjury?: string | null
  }

  export type causeofinjurydetailUpdateInput = {
    causeofinjury?: NullableStringFieldUpdateOperationsInput | string | null
    commentofinjury?: NullableStringFieldUpdateOperationsInput | string | null
    accidenttransactions?: accidenttransactionsUpdateOneWithoutCauseofinjurydetailNestedInput
  }

  export type causeofinjurydetailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    accidentid?: NullableIntFieldUpdateOperationsInput | number | null
    causeofinjury?: NullableStringFieldUpdateOperationsInput | string | null
    commentofinjury?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type causeofinjurydetailCreateManyInput = {
    id?: number
    accidentid?: number | null
    causeofinjury?: string | null
    commentofinjury?: string | null
  }

  export type causeofinjurydetailUpdateManyMutationInput = {
    causeofinjury?: NullableStringFieldUpdateOperationsInput | string | null
    commentofinjury?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type causeofinjurydetailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    accidentid?: NullableIntFieldUpdateOperationsInput | number | null
    causeofinjury?: NullableStringFieldUpdateOperationsInput | string | null
    commentofinjury?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type injurydetailCreateInput = {
    woundtype?: string | null
    injuryside?: string | null
    injuryarea?: string | null
    accidenttransactions?: accidenttransactionsCreateNestedOneWithoutInjurydetailInput
  }

  export type injurydetailUncheckedCreateInput = {
    id?: number
    accidentid?: number | null
    woundtype?: string | null
    injuryside?: string | null
    injuryarea?: string | null
  }

  export type injurydetailUpdateInput = {
    woundtype?: NullableStringFieldUpdateOperationsInput | string | null
    injuryside?: NullableStringFieldUpdateOperationsInput | string | null
    injuryarea?: NullableStringFieldUpdateOperationsInput | string | null
    accidenttransactions?: accidenttransactionsUpdateOneWithoutInjurydetailNestedInput
  }

  export type injurydetailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    accidentid?: NullableIntFieldUpdateOperationsInput | number | null
    woundtype?: NullableStringFieldUpdateOperationsInput | string | null
    injuryside?: NullableStringFieldUpdateOperationsInput | string | null
    injuryarea?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type injurydetailCreateManyInput = {
    id?: number
    accidentid?: number | null
    woundtype?: string | null
    injuryside?: string | null
    injuryarea?: string | null
  }

  export type injurydetailUpdateManyMutationInput = {
    woundtype?: NullableStringFieldUpdateOperationsInput | string | null
    injuryside?: NullableStringFieldUpdateOperationsInput | string | null
    injuryarea?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type injurydetailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    accidentid?: NullableIntFieldUpdateOperationsInput | number | null
    woundtype?: NullableStringFieldUpdateOperationsInput | string | null
    injuryside?: NullableStringFieldUpdateOperationsInput | string | null
    injuryarea?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type InsurersNullableRelationFilter = {
    is?: insurersWhereInput | null
    isNot?: insurersWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type accidentcauseover45daysCountOrderByAggregateInput = {
    id?: SortOrder
    causeovercode?: SortOrder
    causeoverdesc?: SortOrder
    insurerid?: SortOrder
  }

  export type accidentcauseover45daysAvgOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
  }

  export type accidentcauseover45daysMaxOrderByAggregateInput = {
    id?: SortOrder
    causeovercode?: SortOrder
    causeoverdesc?: SortOrder
    insurerid?: SortOrder
  }

  export type accidentcauseover45daysMinOrderByAggregateInput = {
    id?: SortOrder
    causeovercode?: SortOrder
    causeoverdesc?: SortOrder
    insurerid?: SortOrder
  }

  export type accidentcauseover45daysSumOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type accidentplaceCountOrderByAggregateInput = {
    id?: SortOrder
    accidentplacecode?: SortOrder
    accidentplacename?: SortOrder
    insurerid?: SortOrder
  }

  export type accidentplaceAvgOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
  }

  export type accidentplaceMaxOrderByAggregateInput = {
    id?: SortOrder
    accidentplacecode?: SortOrder
    accidentplacename?: SortOrder
    insurerid?: SortOrder
  }

  export type accidentplaceMinOrderByAggregateInput = {
    id?: SortOrder
    accidentplacecode?: SortOrder
    accidentplacename?: SortOrder
    insurerid?: SortOrder
  }

  export type accidentplaceSumOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
  }

  export type causeofinjurysideCountOrderByAggregateInput = {
    id?: SortOrder
    injurysidename?: SortOrder
    injurysidecode?: SortOrder
    insurerid?: SortOrder
  }

  export type causeofinjurysideAvgOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
  }

  export type causeofinjurysideMaxOrderByAggregateInput = {
    id?: SortOrder
    injurysidename?: SortOrder
    injurysidecode?: SortOrder
    insurerid?: SortOrder
  }

  export type causeofinjurysideMinOrderByAggregateInput = {
    id?: SortOrder
    injurysidename?: SortOrder
    injurysidecode?: SortOrder
    insurerid?: SortOrder
  }

  export type causeofinjurysideSumOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
  }

  export type causeofinjurywoundtypeCountOrderByAggregateInput = {
    id?: SortOrder
    woundtypename?: SortOrder
    woundtypecode?: SortOrder
    insurerid?: SortOrder
  }

  export type causeofinjurywoundtypeAvgOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
  }

  export type causeofinjurywoundtypeMaxOrderByAggregateInput = {
    id?: SortOrder
    woundtypename?: SortOrder
    woundtypecode?: SortOrder
    insurerid?: SortOrder
  }

  export type causeofinjurywoundtypeMinOrderByAggregateInput = {
    id?: SortOrder
    woundtypename?: SortOrder
    woundtypecode?: SortOrder
    insurerid?: SortOrder
  }

  export type causeofinjurywoundtypeSumOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type claimantsHnInsureridCompoundUniqueInput = {
    hn: string
    insurerid: number
  }

  export type claimantsCountOrderByAggregateInput = {
    id?: SortOrder
    national_id?: SortOrder
    passportnumber?: SortOrder
    hn?: SortOrder
    patientid?: SortOrder
    title_th?: SortOrder
    givenname_th?: SortOrder
    surname_th?: SortOrder
    title_en?: SortOrder
    givenname_en?: SortOrder
    surname_en?: SortOrder
    mobilephone?: SortOrder
    statusactive?: SortOrder
    dateofbirth?: SortOrder
    gender?: SortOrder
    registrationdate?: SortOrder
    insurerid?: SortOrder
  }

  export type claimantsAvgOrderByAggregateInput = {
    id?: SortOrder
    patientid?: SortOrder
    insurerid?: SortOrder
  }

  export type claimantsMaxOrderByAggregateInput = {
    id?: SortOrder
    national_id?: SortOrder
    passportnumber?: SortOrder
    hn?: SortOrder
    patientid?: SortOrder
    title_th?: SortOrder
    givenname_th?: SortOrder
    surname_th?: SortOrder
    title_en?: SortOrder
    givenname_en?: SortOrder
    surname_en?: SortOrder
    mobilephone?: SortOrder
    statusactive?: SortOrder
    dateofbirth?: SortOrder
    gender?: SortOrder
    registrationdate?: SortOrder
    insurerid?: SortOrder
  }

  export type claimantsMinOrderByAggregateInput = {
    id?: SortOrder
    national_id?: SortOrder
    passportnumber?: SortOrder
    hn?: SortOrder
    patientid?: SortOrder
    title_th?: SortOrder
    givenname_th?: SortOrder
    surname_th?: SortOrder
    title_en?: SortOrder
    givenname_en?: SortOrder
    surname_en?: SortOrder
    mobilephone?: SortOrder
    statusactive?: SortOrder
    dateofbirth?: SortOrder
    gender?: SortOrder
    registrationdate?: SortOrder
    insurerid?: SortOrder
  }

  export type claimantsSumOrderByAggregateInput = {
    id?: SortOrder
    patientid?: SortOrder
    insurerid?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type claimdocumentsCountOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
    refid?: SortOrder
    transactionno?: SortOrder
    hn?: SortOrder
    vn?: SortOrder
    documentname?: SortOrder
    documenttypecode?: SortOrder
    documenttypename?: SortOrder
    serverpath?: SortOrder
    filepath?: SortOrder
    filesize?: SortOrder
    filemimetype?: SortOrder
    uploaddate?: SortOrder
    uploadedby?: SortOrder
  }

  export type claimdocumentsAvgOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
    filesize?: SortOrder
  }

  export type claimdocumentsMaxOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
    refid?: SortOrder
    transactionno?: SortOrder
    hn?: SortOrder
    vn?: SortOrder
    documentname?: SortOrder
    documenttypecode?: SortOrder
    documenttypename?: SortOrder
    serverpath?: SortOrder
    filepath?: SortOrder
    filesize?: SortOrder
    filemimetype?: SortOrder
    uploaddate?: SortOrder
    uploadedby?: SortOrder
  }

  export type claimdocumentsMinOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
    refid?: SortOrder
    transactionno?: SortOrder
    hn?: SortOrder
    vn?: SortOrder
    documentname?: SortOrder
    documenttypecode?: SortOrder
    documenttypename?: SortOrder
    serverpath?: SortOrder
    filepath?: SortOrder
    filesize?: SortOrder
    filemimetype?: SortOrder
    uploaddate?: SortOrder
    uploadedby?: SortOrder
  }

  export type claimdocumentsSumOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
    filesize?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type TransactionclaimstatusListRelationFilter = {
    every?: transactionclaimstatusWhereInput
    some?: transactionclaimstatusWhereInput
    none?: transactionclaimstatusWhereInput
  }

  export type transactionclaimstatusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type claimstatusClaimstatuscodeInsureridCompoundUniqueInput = {
    claimstatuscode: string
    insurerid: number
  }

  export type claimstatusCountOrderByAggregateInput = {
    id?: SortOrder
    claimstatuscode?: SortOrder
    claimstatusdesc_th?: SortOrder
    claimstatusdesc_en?: SortOrder
    insurerid?: SortOrder
  }

  export type claimstatusAvgOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
  }

  export type claimstatusMaxOrderByAggregateInput = {
    id?: SortOrder
    claimstatuscode?: SortOrder
    claimstatusdesc_th?: SortOrder
    claimstatusdesc_en?: SortOrder
    insurerid?: SortOrder
  }

  export type claimstatusMinOrderByAggregateInput = {
    id?: SortOrder
    claimstatuscode?: SortOrder
    claimstatusdesc_th?: SortOrder
    claimstatusdesc_en?: SortOrder
    insurerid?: SortOrder
  }

  export type claimstatusSumOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
  }

  export type diagnosistypemappingCountOrderByAggregateInput = {
    id?: SortOrder
    dxtypecodetrakcare?: SortOrder
    dxtypenametrakcare?: SortOrder
    dxtypecodeinsurance?: SortOrder
    dxtypenameinsurance?: SortOrder
    insurerid?: SortOrder
  }

  export type diagnosistypemappingAvgOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
  }

  export type diagnosistypemappingMaxOrderByAggregateInput = {
    id?: SortOrder
    dxtypecodetrakcare?: SortOrder
    dxtypenametrakcare?: SortOrder
    dxtypecodeinsurance?: SortOrder
    dxtypenameinsurance?: SortOrder
    insurerid?: SortOrder
  }

  export type diagnosistypemappingMinOrderByAggregateInput = {
    id?: SortOrder
    dxtypecodetrakcare?: SortOrder
    dxtypenametrakcare?: SortOrder
    dxtypecodeinsurance?: SortOrder
    dxtypenameinsurance?: SortOrder
    insurerid?: SortOrder
  }

  export type diagnosistypemappingSumOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
  }

  export type documenttypeCountOrderByAggregateInput = {
    id?: SortOrder
    documenttypecode?: SortOrder
    documenttypename?: SortOrder
    insurerid?: SortOrder
  }

  export type documenttypeAvgOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
  }

  export type documenttypeMaxOrderByAggregateInput = {
    id?: SortOrder
    documenttypecode?: SortOrder
    documenttypename?: SortOrder
    insurerid?: SortOrder
  }

  export type documenttypeMinOrderByAggregateInput = {
    id?: SortOrder
    documenttypecode?: SortOrder
    documenttypename?: SortOrder
    insurerid?: SortOrder
  }

  export type documenttypeSumOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
  }

  export type illnesssurgeryCountOrderByAggregateInput = {
    id?: SortOrder
    iscode?: SortOrder
    isdesc?: SortOrder
    insurerid?: SortOrder
  }

  export type illnesssurgeryAvgOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
  }

  export type illnesssurgeryMaxOrderByAggregateInput = {
    id?: SortOrder
    iscode?: SortOrder
    isdesc?: SortOrder
    insurerid?: SortOrder
  }

  export type illnesssurgeryMinOrderByAggregateInput = {
    id?: SortOrder
    iscode?: SortOrder
    isdesc?: SortOrder
    insurerid?: SortOrder
  }

  export type illnesssurgerySumOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
  }

  export type illnesstypeCountOrderByAggregateInput = {
    id?: SortOrder
    illnesstypecode?: SortOrder
    illnesstypedesc?: SortOrder
    insurerid?: SortOrder
  }

  export type illnesstypeAvgOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
  }

  export type illnesstypeMaxOrderByAggregateInput = {
    id?: SortOrder
    illnesstypecode?: SortOrder
    illnesstypedesc?: SortOrder
    insurerid?: SortOrder
  }

  export type illnesstypeMinOrderByAggregateInput = {
    id?: SortOrder
    illnesstypecode?: SortOrder
    illnesstypedesc?: SortOrder
    insurerid?: SortOrder
  }

  export type illnesstypeSumOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
  }

  export type Accidentcauseover45daysListRelationFilter = {
    every?: accidentcauseover45daysWhereInput
    some?: accidentcauseover45daysWhereInput
    none?: accidentcauseover45daysWhereInput
  }

  export type AccidentplaceListRelationFilter = {
    every?: accidentplaceWhereInput
    some?: accidentplaceWhereInput
    none?: accidentplaceWhereInput
  }

  export type AccidenttransactionsListRelationFilter = {
    every?: accidenttransactionsWhereInput
    some?: accidenttransactionsWhereInput
    none?: accidenttransactionsWhereInput
  }

  export type Accidenttransactions22ListRelationFilter = {
    every?: accidenttransactions22WhereInput
    some?: accidenttransactions22WhereInput
    none?: accidenttransactions22WhereInput
  }

  export type CauseofinjurysideListRelationFilter = {
    every?: causeofinjurysideWhereInput
    some?: causeofinjurysideWhereInput
    none?: causeofinjurysideWhereInput
  }

  export type CauseofinjurywoundtypeListRelationFilter = {
    every?: causeofinjurywoundtypeWhereInput
    some?: causeofinjurywoundtypeWhereInput
    none?: causeofinjurywoundtypeWhereInput
  }

  export type ClaimantsListRelationFilter = {
    every?: claimantsWhereInput
    some?: claimantsWhereInput
    none?: claimantsWhereInput
  }

  export type ClaimdocumentsListRelationFilter = {
    every?: claimdocumentsWhereInput
    some?: claimdocumentsWhereInput
    none?: claimdocumentsWhereInput
  }

  export type ClaimstatusListRelationFilter = {
    every?: claimstatusWhereInput
    some?: claimstatusWhereInput
    none?: claimstatusWhereInput
  }

  export type DiagnosistypemappingListRelationFilter = {
    every?: diagnosistypemappingWhereInput
    some?: diagnosistypemappingWhereInput
    none?: diagnosistypemappingWhereInput
  }

  export type DocumenttypeListRelationFilter = {
    every?: documenttypeWhereInput
    some?: documenttypeWhereInput
    none?: documenttypeWhereInput
  }

  export type IllnesssurgeryListRelationFilter = {
    every?: illnesssurgeryWhereInput
    some?: illnesssurgeryWhereInput
    none?: illnesssurgeryWhereInput
  }

  export type IllnesstypeListRelationFilter = {
    every?: illnesstypeWhereInput
    some?: illnesstypeWhereInput
    none?: illnesstypeWhereInput
  }

  export type PolicytypeListRelationFilter = {
    every?: policytypeWhereInput
    some?: policytypeWhereInput
    none?: policytypeWhereInput
  }

  export type ProceduretransactionsListRelationFilter = {
    every?: proceduretransactionsWhereInput
    some?: proceduretransactionsWhereInput
    none?: proceduretransactionsWhereInput
  }

  export type ServicesettingListRelationFilter = {
    every?: servicesettingWhereInput
    some?: servicesettingWhereInput
    none?: servicesettingWhereInput
  }

  export type accidentcauseover45daysOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type accidentplaceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type accidenttransactionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type accidenttransactions22OrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type causeofinjurysideOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type causeofinjurywoundtypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type claimantsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type claimdocumentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type claimstatusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type diagnosistypemappingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type documenttypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type illnesssurgeryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type illnesstypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type policytypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type proceduretransactionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type servicesettingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type insurersCountOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
    insurercode?: SortOrder
    insurername?: SortOrder
  }

  export type insurersAvgOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
    insurercode?: SortOrder
  }

  export type insurersMaxOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
    insurercode?: SortOrder
    insurername?: SortOrder
  }

  export type insurersMinOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
    insurercode?: SortOrder
    insurername?: SortOrder
  }

  export type insurersSumOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
    insurercode?: SortOrder
  }

  export type medicaltransactionsCountOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
    refid?: SortOrder
    transactionno?: SortOrder
    hn?: SortOrder
    vn?: SortOrder
    dxfreetext?: SortOrder
    presentillness?: SortOrder
    chiefcomplaint?: SortOrder
    accidentcauseover45days?: SortOrder
    underlyingcondition?: SortOrder
    physicalexam?: SortOrder
    planoftreatment?: SortOrder
    procedurefreetext?: SortOrder
    additionalnote?: SortOrder
    signsymptomsdate?: SortOrder
    comascore?: SortOrder
    expecteddayofrecovery?: SortOrder
    pregnant?: SortOrder
    alcoholrelated?: SortOrder
    haveaccidentinjurydetail?: SortOrder
    haveaccidentcauseofinjurydetail?: SortOrder
    haveprocedure?: SortOrder
    privatecase?: SortOrder
  }

  export type medicaltransactionsAvgOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
  }

  export type medicaltransactionsMaxOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
    refid?: SortOrder
    transactionno?: SortOrder
    hn?: SortOrder
    vn?: SortOrder
    dxfreetext?: SortOrder
    presentillness?: SortOrder
    chiefcomplaint?: SortOrder
    accidentcauseover45days?: SortOrder
    underlyingcondition?: SortOrder
    physicalexam?: SortOrder
    planoftreatment?: SortOrder
    procedurefreetext?: SortOrder
    additionalnote?: SortOrder
    signsymptomsdate?: SortOrder
    comascore?: SortOrder
    expecteddayofrecovery?: SortOrder
    pregnant?: SortOrder
    alcoholrelated?: SortOrder
    haveaccidentinjurydetail?: SortOrder
    haveaccidentcauseofinjurydetail?: SortOrder
    haveprocedure?: SortOrder
    privatecase?: SortOrder
  }

  export type medicaltransactionsMinOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
    refid?: SortOrder
    transactionno?: SortOrder
    hn?: SortOrder
    vn?: SortOrder
    dxfreetext?: SortOrder
    presentillness?: SortOrder
    chiefcomplaint?: SortOrder
    accidentcauseover45days?: SortOrder
    underlyingcondition?: SortOrder
    physicalexam?: SortOrder
    planoftreatment?: SortOrder
    procedurefreetext?: SortOrder
    additionalnote?: SortOrder
    signsymptomsdate?: SortOrder
    comascore?: SortOrder
    expecteddayofrecovery?: SortOrder
    pregnant?: SortOrder
    alcoholrelated?: SortOrder
    haveaccidentinjurydetail?: SortOrder
    haveaccidentcauseofinjurydetail?: SortOrder
    haveprocedure?: SortOrder
    privatecase?: SortOrder
  }

  export type medicaltransactionsSumOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
  }

  export type policytypeCountOrderByAggregateInput = {
    id?: SortOrder
    policytypecode?: SortOrder
    policytypedesc?: SortOrder
    insurerid?: SortOrder
  }

  export type policytypeAvgOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
  }

  export type policytypeMaxOrderByAggregateInput = {
    id?: SortOrder
    policytypecode?: SortOrder
    policytypedesc?: SortOrder
    insurerid?: SortOrder
  }

  export type policytypeMinOrderByAggregateInput = {
    id?: SortOrder
    policytypecode?: SortOrder
    policytypedesc?: SortOrder
    insurerid?: SortOrder
  }

  export type policytypeSumOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
  }

  export type servicesettingCountOrderByAggregateInput = {
    id?: SortOrder
    servicesettingcode?: SortOrder
    servicesettingdesc?: SortOrder
    insurerid?: SortOrder
  }

  export type servicesettingAvgOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
  }

  export type servicesettingMaxOrderByAggregateInput = {
    id?: SortOrder
    servicesettingcode?: SortOrder
    servicesettingdesc?: SortOrder
    insurerid?: SortOrder
  }

  export type servicesettingMinOrderByAggregateInput = {
    id?: SortOrder
    servicesettingcode?: SortOrder
    servicesettingdesc?: SortOrder
    insurerid?: SortOrder
  }

  export type servicesettingSumOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type transactionclaimCountOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
    refid?: SortOrder
    transactionno?: SortOrder
    hn?: SortOrder
    vn?: SortOrder
    visitdate?: SortOrder
    accidentdate?: SortOrder
    messageclaim?: SortOrder
    messageth?: SortOrder
    claimno?: SortOrder
    claimstatuscode?: SortOrder
    status_changed_at?: SortOrder
    occurrenceno?: SortOrder
    totalapprovedamount?: SortOrder
    totalexcessamount?: SortOrder
    isreimbursement?: SortOrder
    batchnumber?: SortOrder
    invoicenumber?: SortOrder
    otherinsurer?: SortOrder
    furtherclaimid?: SortOrder
    furtherclaimno?: SortOrder
    privatecase?: SortOrder
    previoustreatmentdate?: SortOrder
    previoustreatmentdetail?: SortOrder
  }

  export type transactionclaimAvgOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
    totalapprovedamount?: SortOrder
    totalexcessamount?: SortOrder
  }

  export type transactionclaimMaxOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
    refid?: SortOrder
    transactionno?: SortOrder
    hn?: SortOrder
    vn?: SortOrder
    visitdate?: SortOrder
    accidentdate?: SortOrder
    messageclaim?: SortOrder
    messageth?: SortOrder
    claimno?: SortOrder
    claimstatuscode?: SortOrder
    status_changed_at?: SortOrder
    occurrenceno?: SortOrder
    totalapprovedamount?: SortOrder
    totalexcessamount?: SortOrder
    isreimbursement?: SortOrder
    batchnumber?: SortOrder
    invoicenumber?: SortOrder
    otherinsurer?: SortOrder
    furtherclaimid?: SortOrder
    furtherclaimno?: SortOrder
    privatecase?: SortOrder
    previoustreatmentdate?: SortOrder
    previoustreatmentdetail?: SortOrder
  }

  export type transactionclaimMinOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
    refid?: SortOrder
    transactionno?: SortOrder
    hn?: SortOrder
    vn?: SortOrder
    visitdate?: SortOrder
    accidentdate?: SortOrder
    messageclaim?: SortOrder
    messageth?: SortOrder
    claimno?: SortOrder
    claimstatuscode?: SortOrder
    status_changed_at?: SortOrder
    occurrenceno?: SortOrder
    totalapprovedamount?: SortOrder
    totalexcessamount?: SortOrder
    isreimbursement?: SortOrder
    batchnumber?: SortOrder
    invoicenumber?: SortOrder
    otherinsurer?: SortOrder
    furtherclaimid?: SortOrder
    furtherclaimno?: SortOrder
    privatecase?: SortOrder
    previoustreatmentdate?: SortOrder
    previoustreatmentdetail?: SortOrder
  }

  export type transactionclaimSumOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
    totalapprovedamount?: SortOrder
    totalexcessamount?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type ClaimstatusNullableRelationFilter = {
    is?: claimstatusWhereInput | null
    isNot?: claimstatusWhereInput | null
  }

  export type transactionclaimstatusCountOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
    refid?: SortOrder
    transactionno?: SortOrder
    hn?: SortOrder
    vn?: SortOrder
    batchnumber?: SortOrder
    claimno?: SortOrder
    invoicenumber?: SortOrder
    status_changed_at?: SortOrder
    note?: SortOrder
    totalapproveamount?: SortOrder
    paymentdate?: SortOrder
    claimstatuscode?: SortOrder
  }

  export type transactionclaimstatusAvgOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
  }

  export type transactionclaimstatusMaxOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
    refid?: SortOrder
    transactionno?: SortOrder
    hn?: SortOrder
    vn?: SortOrder
    batchnumber?: SortOrder
    claimno?: SortOrder
    invoicenumber?: SortOrder
    status_changed_at?: SortOrder
    note?: SortOrder
    totalapproveamount?: SortOrder
    paymentdate?: SortOrder
    claimstatuscode?: SortOrder
  }

  export type transactionclaimstatusMinOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
    refid?: SortOrder
    transactionno?: SortOrder
    hn?: SortOrder
    vn?: SortOrder
    batchnumber?: SortOrder
    claimno?: SortOrder
    invoicenumber?: SortOrder
    status_changed_at?: SortOrder
    note?: SortOrder
    totalapproveamount?: SortOrder
    paymentdate?: SortOrder
    claimstatuscode?: SortOrder
  }

  export type transactionclaimstatusSumOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
  }

  export type CauseofinjurydetailListRelationFilter = {
    every?: causeofinjurydetailWhereInput
    some?: causeofinjurydetailWhereInput
    none?: causeofinjurydetailWhereInput
  }

  export type InjurydetailListRelationFilter = {
    every?: injurydetailWhereInput
    some?: injurydetailWhereInput
    none?: injurydetailWhereInput
  }

  export type causeofinjurydetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type injurydetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type accidenttransactionsCountOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
    refid?: SortOrder
    transactionno?: SortOrder
    hn?: SortOrder
    vn?: SortOrder
    accidentplace?: SortOrder
    accidentdate?: SortOrder
  }

  export type accidenttransactionsAvgOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
  }

  export type accidenttransactionsMaxOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
    refid?: SortOrder
    transactionno?: SortOrder
    hn?: SortOrder
    vn?: SortOrder
    accidentplace?: SortOrder
    accidentdate?: SortOrder
  }

  export type accidenttransactionsMinOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
    refid?: SortOrder
    transactionno?: SortOrder
    hn?: SortOrder
    vn?: SortOrder
    accidentplace?: SortOrder
    accidentdate?: SortOrder
  }

  export type accidenttransactionsSumOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
  }

  export type proceduretransactionsCountOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
    refid?: SortOrder
    transactionno?: SortOrder
    hn?: SortOrder
    vn?: SortOrder
    icd9?: SortOrder
    procedurename?: SortOrder
    proceduredate?: SortOrder
  }

  export type proceduretransactionsAvgOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
  }

  export type proceduretransactionsMaxOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
    refid?: SortOrder
    transactionno?: SortOrder
    hn?: SortOrder
    vn?: SortOrder
    icd9?: SortOrder
    procedurename?: SortOrder
    proceduredate?: SortOrder
  }

  export type proceduretransactionsMinOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
    refid?: SortOrder
    transactionno?: SortOrder
    hn?: SortOrder
    vn?: SortOrder
    icd9?: SortOrder
    procedurename?: SortOrder
    proceduredate?: SortOrder
  }

  export type proceduretransactionsSumOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
  }

  export type accidenttransactions22CountOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
    refid?: SortOrder
    transactionno?: SortOrder
    hn?: SortOrder
    vn?: SortOrder
    accidentplace?: SortOrder
    accidentdate?: SortOrder
    causeofinjury?: SortOrder
    commentofinjury?: SortOrder
    woundtype?: SortOrder
    injuryside?: SortOrder
    injuryarea?: SortOrder
  }

  export type accidenttransactions22AvgOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
  }

  export type accidenttransactions22MaxOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
    refid?: SortOrder
    transactionno?: SortOrder
    hn?: SortOrder
    vn?: SortOrder
    accidentplace?: SortOrder
    accidentdate?: SortOrder
    causeofinjury?: SortOrder
    commentofinjury?: SortOrder
    woundtype?: SortOrder
    injuryside?: SortOrder
    injuryarea?: SortOrder
  }

  export type accidenttransactions22MinOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
    refid?: SortOrder
    transactionno?: SortOrder
    hn?: SortOrder
    vn?: SortOrder
    accidentplace?: SortOrder
    accidentdate?: SortOrder
    causeofinjury?: SortOrder
    commentofinjury?: SortOrder
    woundtype?: SortOrder
    injuryside?: SortOrder
    injuryarea?: SortOrder
  }

  export type accidenttransactions22SumOrderByAggregateInput = {
    id?: SortOrder
    insurerid?: SortOrder
  }

  export type AccidenttransactionsNullableRelationFilter = {
    is?: accidenttransactionsWhereInput | null
    isNot?: accidenttransactionsWhereInput | null
  }

  export type causeofinjurydetailCountOrderByAggregateInput = {
    id?: SortOrder
    accidentid?: SortOrder
    causeofinjury?: SortOrder
    commentofinjury?: SortOrder
  }

  export type causeofinjurydetailAvgOrderByAggregateInput = {
    id?: SortOrder
    accidentid?: SortOrder
  }

  export type causeofinjurydetailMaxOrderByAggregateInput = {
    id?: SortOrder
    accidentid?: SortOrder
    causeofinjury?: SortOrder
    commentofinjury?: SortOrder
  }

  export type causeofinjurydetailMinOrderByAggregateInput = {
    id?: SortOrder
    accidentid?: SortOrder
    causeofinjury?: SortOrder
    commentofinjury?: SortOrder
  }

  export type causeofinjurydetailSumOrderByAggregateInput = {
    id?: SortOrder
    accidentid?: SortOrder
  }

  export type injurydetailCountOrderByAggregateInput = {
    id?: SortOrder
    accidentid?: SortOrder
    woundtype?: SortOrder
    injuryside?: SortOrder
    injuryarea?: SortOrder
  }

  export type injurydetailAvgOrderByAggregateInput = {
    id?: SortOrder
    accidentid?: SortOrder
  }

  export type injurydetailMaxOrderByAggregateInput = {
    id?: SortOrder
    accidentid?: SortOrder
    woundtype?: SortOrder
    injuryside?: SortOrder
    injuryarea?: SortOrder
  }

  export type injurydetailMinOrderByAggregateInput = {
    id?: SortOrder
    accidentid?: SortOrder
    woundtype?: SortOrder
    injuryside?: SortOrder
    injuryarea?: SortOrder
  }

  export type injurydetailSumOrderByAggregateInput = {
    id?: SortOrder
    accidentid?: SortOrder
  }

  export type insurersCreateNestedOneWithoutAccidentcauseover45daysInput = {
    create?: XOR<insurersCreateWithoutAccidentcauseover45daysInput, insurersUncheckedCreateWithoutAccidentcauseover45daysInput>
    connectOrCreate?: insurersCreateOrConnectWithoutAccidentcauseover45daysInput
    connect?: insurersWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type insurersUpdateOneWithoutAccidentcauseover45daysNestedInput = {
    create?: XOR<insurersCreateWithoutAccidentcauseover45daysInput, insurersUncheckedCreateWithoutAccidentcauseover45daysInput>
    connectOrCreate?: insurersCreateOrConnectWithoutAccidentcauseover45daysInput
    upsert?: insurersUpsertWithoutAccidentcauseover45daysInput
    disconnect?: insurersWhereInput | boolean
    delete?: insurersWhereInput | boolean
    connect?: insurersWhereUniqueInput
    update?: XOR<XOR<insurersUpdateToOneWithWhereWithoutAccidentcauseover45daysInput, insurersUpdateWithoutAccidentcauseover45daysInput>, insurersUncheckedUpdateWithoutAccidentcauseover45daysInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type insurersCreateNestedOneWithoutAccidentplaceInput = {
    create?: XOR<insurersCreateWithoutAccidentplaceInput, insurersUncheckedCreateWithoutAccidentplaceInput>
    connectOrCreate?: insurersCreateOrConnectWithoutAccidentplaceInput
    connect?: insurersWhereUniqueInput
  }

  export type insurersUpdateOneWithoutAccidentplaceNestedInput = {
    create?: XOR<insurersCreateWithoutAccidentplaceInput, insurersUncheckedCreateWithoutAccidentplaceInput>
    connectOrCreate?: insurersCreateOrConnectWithoutAccidentplaceInput
    upsert?: insurersUpsertWithoutAccidentplaceInput
    disconnect?: insurersWhereInput | boolean
    delete?: insurersWhereInput | boolean
    connect?: insurersWhereUniqueInput
    update?: XOR<XOR<insurersUpdateToOneWithWhereWithoutAccidentplaceInput, insurersUpdateWithoutAccidentplaceInput>, insurersUncheckedUpdateWithoutAccidentplaceInput>
  }

  export type insurersCreateNestedOneWithoutCauseofinjurysideInput = {
    create?: XOR<insurersCreateWithoutCauseofinjurysideInput, insurersUncheckedCreateWithoutCauseofinjurysideInput>
    connectOrCreate?: insurersCreateOrConnectWithoutCauseofinjurysideInput
    connect?: insurersWhereUniqueInput
  }

  export type insurersUpdateOneWithoutCauseofinjurysideNestedInput = {
    create?: XOR<insurersCreateWithoutCauseofinjurysideInput, insurersUncheckedCreateWithoutCauseofinjurysideInput>
    connectOrCreate?: insurersCreateOrConnectWithoutCauseofinjurysideInput
    upsert?: insurersUpsertWithoutCauseofinjurysideInput
    disconnect?: insurersWhereInput | boolean
    delete?: insurersWhereInput | boolean
    connect?: insurersWhereUniqueInput
    update?: XOR<XOR<insurersUpdateToOneWithWhereWithoutCauseofinjurysideInput, insurersUpdateWithoutCauseofinjurysideInput>, insurersUncheckedUpdateWithoutCauseofinjurysideInput>
  }

  export type insurersCreateNestedOneWithoutCauseofinjurywoundtypeInput = {
    create?: XOR<insurersCreateWithoutCauseofinjurywoundtypeInput, insurersUncheckedCreateWithoutCauseofinjurywoundtypeInput>
    connectOrCreate?: insurersCreateOrConnectWithoutCauseofinjurywoundtypeInput
    connect?: insurersWhereUniqueInput
  }

  export type insurersUpdateOneWithoutCauseofinjurywoundtypeNestedInput = {
    create?: XOR<insurersCreateWithoutCauseofinjurywoundtypeInput, insurersUncheckedCreateWithoutCauseofinjurywoundtypeInput>
    connectOrCreate?: insurersCreateOrConnectWithoutCauseofinjurywoundtypeInput
    upsert?: insurersUpsertWithoutCauseofinjurywoundtypeInput
    disconnect?: insurersWhereInput | boolean
    delete?: insurersWhereInput | boolean
    connect?: insurersWhereUniqueInput
    update?: XOR<XOR<insurersUpdateToOneWithWhereWithoutCauseofinjurywoundtypeInput, insurersUpdateWithoutCauseofinjurywoundtypeInput>, insurersUncheckedUpdateWithoutCauseofinjurywoundtypeInput>
  }

  export type insurersCreateNestedOneWithoutClaimantsInput = {
    create?: XOR<insurersCreateWithoutClaimantsInput, insurersUncheckedCreateWithoutClaimantsInput>
    connectOrCreate?: insurersCreateOrConnectWithoutClaimantsInput
    connect?: insurersWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type insurersUpdateOneWithoutClaimantsNestedInput = {
    create?: XOR<insurersCreateWithoutClaimantsInput, insurersUncheckedCreateWithoutClaimantsInput>
    connectOrCreate?: insurersCreateOrConnectWithoutClaimantsInput
    upsert?: insurersUpsertWithoutClaimantsInput
    disconnect?: insurersWhereInput | boolean
    delete?: insurersWhereInput | boolean
    connect?: insurersWhereUniqueInput
    update?: XOR<XOR<insurersUpdateToOneWithWhereWithoutClaimantsInput, insurersUpdateWithoutClaimantsInput>, insurersUncheckedUpdateWithoutClaimantsInput>
  }

  export type insurersCreateNestedOneWithoutClaimdocumentsInput = {
    create?: XOR<insurersCreateWithoutClaimdocumentsInput, insurersUncheckedCreateWithoutClaimdocumentsInput>
    connectOrCreate?: insurersCreateOrConnectWithoutClaimdocumentsInput
    connect?: insurersWhereUniqueInput
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type insurersUpdateOneWithoutClaimdocumentsNestedInput = {
    create?: XOR<insurersCreateWithoutClaimdocumentsInput, insurersUncheckedCreateWithoutClaimdocumentsInput>
    connectOrCreate?: insurersCreateOrConnectWithoutClaimdocumentsInput
    upsert?: insurersUpsertWithoutClaimdocumentsInput
    disconnect?: insurersWhereInput | boolean
    delete?: insurersWhereInput | boolean
    connect?: insurersWhereUniqueInput
    update?: XOR<XOR<insurersUpdateToOneWithWhereWithoutClaimdocumentsInput, insurersUpdateWithoutClaimdocumentsInput>, insurersUncheckedUpdateWithoutClaimdocumentsInput>
  }

  export type insurersCreateNestedOneWithoutClaimstatusInput = {
    create?: XOR<insurersCreateWithoutClaimstatusInput, insurersUncheckedCreateWithoutClaimstatusInput>
    connectOrCreate?: insurersCreateOrConnectWithoutClaimstatusInput
    connect?: insurersWhereUniqueInput
  }

  export type transactionclaimstatusCreateNestedManyWithoutClaimstatusInput = {
    create?: XOR<transactionclaimstatusCreateWithoutClaimstatusInput, transactionclaimstatusUncheckedCreateWithoutClaimstatusInput> | transactionclaimstatusCreateWithoutClaimstatusInput[] | transactionclaimstatusUncheckedCreateWithoutClaimstatusInput[]
    connectOrCreate?: transactionclaimstatusCreateOrConnectWithoutClaimstatusInput | transactionclaimstatusCreateOrConnectWithoutClaimstatusInput[]
    createMany?: transactionclaimstatusCreateManyClaimstatusInputEnvelope
    connect?: transactionclaimstatusWhereUniqueInput | transactionclaimstatusWhereUniqueInput[]
  }

  export type transactionclaimstatusUncheckedCreateNestedManyWithoutClaimstatusInput = {
    create?: XOR<transactionclaimstatusCreateWithoutClaimstatusInput, transactionclaimstatusUncheckedCreateWithoutClaimstatusInput> | transactionclaimstatusCreateWithoutClaimstatusInput[] | transactionclaimstatusUncheckedCreateWithoutClaimstatusInput[]
    connectOrCreate?: transactionclaimstatusCreateOrConnectWithoutClaimstatusInput | transactionclaimstatusCreateOrConnectWithoutClaimstatusInput[]
    createMany?: transactionclaimstatusCreateManyClaimstatusInputEnvelope
    connect?: transactionclaimstatusWhereUniqueInput | transactionclaimstatusWhereUniqueInput[]
  }

  export type insurersUpdateOneWithoutClaimstatusNestedInput = {
    create?: XOR<insurersCreateWithoutClaimstatusInput, insurersUncheckedCreateWithoutClaimstatusInput>
    connectOrCreate?: insurersCreateOrConnectWithoutClaimstatusInput
    upsert?: insurersUpsertWithoutClaimstatusInput
    disconnect?: insurersWhereInput | boolean
    delete?: insurersWhereInput | boolean
    connect?: insurersWhereUniqueInput
    update?: XOR<XOR<insurersUpdateToOneWithWhereWithoutClaimstatusInput, insurersUpdateWithoutClaimstatusInput>, insurersUncheckedUpdateWithoutClaimstatusInput>
  }

  export type transactionclaimstatusUpdateManyWithoutClaimstatusNestedInput = {
    create?: XOR<transactionclaimstatusCreateWithoutClaimstatusInput, transactionclaimstatusUncheckedCreateWithoutClaimstatusInput> | transactionclaimstatusCreateWithoutClaimstatusInput[] | transactionclaimstatusUncheckedCreateWithoutClaimstatusInput[]
    connectOrCreate?: transactionclaimstatusCreateOrConnectWithoutClaimstatusInput | transactionclaimstatusCreateOrConnectWithoutClaimstatusInput[]
    upsert?: transactionclaimstatusUpsertWithWhereUniqueWithoutClaimstatusInput | transactionclaimstatusUpsertWithWhereUniqueWithoutClaimstatusInput[]
    createMany?: transactionclaimstatusCreateManyClaimstatusInputEnvelope
    set?: transactionclaimstatusWhereUniqueInput | transactionclaimstatusWhereUniqueInput[]
    disconnect?: transactionclaimstatusWhereUniqueInput | transactionclaimstatusWhereUniqueInput[]
    delete?: transactionclaimstatusWhereUniqueInput | transactionclaimstatusWhereUniqueInput[]
    connect?: transactionclaimstatusWhereUniqueInput | transactionclaimstatusWhereUniqueInput[]
    update?: transactionclaimstatusUpdateWithWhereUniqueWithoutClaimstatusInput | transactionclaimstatusUpdateWithWhereUniqueWithoutClaimstatusInput[]
    updateMany?: transactionclaimstatusUpdateManyWithWhereWithoutClaimstatusInput | transactionclaimstatusUpdateManyWithWhereWithoutClaimstatusInput[]
    deleteMany?: transactionclaimstatusScalarWhereInput | transactionclaimstatusScalarWhereInput[]
  }

  export type transactionclaimstatusUncheckedUpdateManyWithoutClaimstatusNestedInput = {
    create?: XOR<transactionclaimstatusCreateWithoutClaimstatusInput, transactionclaimstatusUncheckedCreateWithoutClaimstatusInput> | transactionclaimstatusCreateWithoutClaimstatusInput[] | transactionclaimstatusUncheckedCreateWithoutClaimstatusInput[]
    connectOrCreate?: transactionclaimstatusCreateOrConnectWithoutClaimstatusInput | transactionclaimstatusCreateOrConnectWithoutClaimstatusInput[]
    upsert?: transactionclaimstatusUpsertWithWhereUniqueWithoutClaimstatusInput | transactionclaimstatusUpsertWithWhereUniqueWithoutClaimstatusInput[]
    createMany?: transactionclaimstatusCreateManyClaimstatusInputEnvelope
    set?: transactionclaimstatusWhereUniqueInput | transactionclaimstatusWhereUniqueInput[]
    disconnect?: transactionclaimstatusWhereUniqueInput | transactionclaimstatusWhereUniqueInput[]
    delete?: transactionclaimstatusWhereUniqueInput | transactionclaimstatusWhereUniqueInput[]
    connect?: transactionclaimstatusWhereUniqueInput | transactionclaimstatusWhereUniqueInput[]
    update?: transactionclaimstatusUpdateWithWhereUniqueWithoutClaimstatusInput | transactionclaimstatusUpdateWithWhereUniqueWithoutClaimstatusInput[]
    updateMany?: transactionclaimstatusUpdateManyWithWhereWithoutClaimstatusInput | transactionclaimstatusUpdateManyWithWhereWithoutClaimstatusInput[]
    deleteMany?: transactionclaimstatusScalarWhereInput | transactionclaimstatusScalarWhereInput[]
  }

  export type insurersCreateNestedOneWithoutDiagnosistypemappingInput = {
    create?: XOR<insurersCreateWithoutDiagnosistypemappingInput, insurersUncheckedCreateWithoutDiagnosistypemappingInput>
    connectOrCreate?: insurersCreateOrConnectWithoutDiagnosistypemappingInput
    connect?: insurersWhereUniqueInput
  }

  export type insurersUpdateOneWithoutDiagnosistypemappingNestedInput = {
    create?: XOR<insurersCreateWithoutDiagnosistypemappingInput, insurersUncheckedCreateWithoutDiagnosistypemappingInput>
    connectOrCreate?: insurersCreateOrConnectWithoutDiagnosistypemappingInput
    upsert?: insurersUpsertWithoutDiagnosistypemappingInput
    disconnect?: insurersWhereInput | boolean
    delete?: insurersWhereInput | boolean
    connect?: insurersWhereUniqueInput
    update?: XOR<XOR<insurersUpdateToOneWithWhereWithoutDiagnosistypemappingInput, insurersUpdateWithoutDiagnosistypemappingInput>, insurersUncheckedUpdateWithoutDiagnosistypemappingInput>
  }

  export type insurersCreateNestedOneWithoutDocumenttypeInput = {
    create?: XOR<insurersCreateWithoutDocumenttypeInput, insurersUncheckedCreateWithoutDocumenttypeInput>
    connectOrCreate?: insurersCreateOrConnectWithoutDocumenttypeInput
    connect?: insurersWhereUniqueInput
  }

  export type insurersUpdateOneWithoutDocumenttypeNestedInput = {
    create?: XOR<insurersCreateWithoutDocumenttypeInput, insurersUncheckedCreateWithoutDocumenttypeInput>
    connectOrCreate?: insurersCreateOrConnectWithoutDocumenttypeInput
    upsert?: insurersUpsertWithoutDocumenttypeInput
    disconnect?: insurersWhereInput | boolean
    delete?: insurersWhereInput | boolean
    connect?: insurersWhereUniqueInput
    update?: XOR<XOR<insurersUpdateToOneWithWhereWithoutDocumenttypeInput, insurersUpdateWithoutDocumenttypeInput>, insurersUncheckedUpdateWithoutDocumenttypeInput>
  }

  export type insurersCreateNestedOneWithoutIllnesssurgeryInput = {
    create?: XOR<insurersCreateWithoutIllnesssurgeryInput, insurersUncheckedCreateWithoutIllnesssurgeryInput>
    connectOrCreate?: insurersCreateOrConnectWithoutIllnesssurgeryInput
    connect?: insurersWhereUniqueInput
  }

  export type insurersUpdateOneWithoutIllnesssurgeryNestedInput = {
    create?: XOR<insurersCreateWithoutIllnesssurgeryInput, insurersUncheckedCreateWithoutIllnesssurgeryInput>
    connectOrCreate?: insurersCreateOrConnectWithoutIllnesssurgeryInput
    upsert?: insurersUpsertWithoutIllnesssurgeryInput
    disconnect?: insurersWhereInput | boolean
    delete?: insurersWhereInput | boolean
    connect?: insurersWhereUniqueInput
    update?: XOR<XOR<insurersUpdateToOneWithWhereWithoutIllnesssurgeryInput, insurersUpdateWithoutIllnesssurgeryInput>, insurersUncheckedUpdateWithoutIllnesssurgeryInput>
  }

  export type insurersCreateNestedOneWithoutIllnesstypeInput = {
    create?: XOR<insurersCreateWithoutIllnesstypeInput, insurersUncheckedCreateWithoutIllnesstypeInput>
    connectOrCreate?: insurersCreateOrConnectWithoutIllnesstypeInput
    connect?: insurersWhereUniqueInput
  }

  export type insurersUpdateOneWithoutIllnesstypeNestedInput = {
    create?: XOR<insurersCreateWithoutIllnesstypeInput, insurersUncheckedCreateWithoutIllnesstypeInput>
    connectOrCreate?: insurersCreateOrConnectWithoutIllnesstypeInput
    upsert?: insurersUpsertWithoutIllnesstypeInput
    disconnect?: insurersWhereInput | boolean
    delete?: insurersWhereInput | boolean
    connect?: insurersWhereUniqueInput
    update?: XOR<XOR<insurersUpdateToOneWithWhereWithoutIllnesstypeInput, insurersUpdateWithoutIllnesstypeInput>, insurersUncheckedUpdateWithoutIllnesstypeInput>
  }

  export type accidentcauseover45daysCreateNestedManyWithoutInsurersInput = {
    create?: XOR<accidentcauseover45daysCreateWithoutInsurersInput, accidentcauseover45daysUncheckedCreateWithoutInsurersInput> | accidentcauseover45daysCreateWithoutInsurersInput[] | accidentcauseover45daysUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: accidentcauseover45daysCreateOrConnectWithoutInsurersInput | accidentcauseover45daysCreateOrConnectWithoutInsurersInput[]
    createMany?: accidentcauseover45daysCreateManyInsurersInputEnvelope
    connect?: accidentcauseover45daysWhereUniqueInput | accidentcauseover45daysWhereUniqueInput[]
  }

  export type accidentplaceCreateNestedManyWithoutInsurersInput = {
    create?: XOR<accidentplaceCreateWithoutInsurersInput, accidentplaceUncheckedCreateWithoutInsurersInput> | accidentplaceCreateWithoutInsurersInput[] | accidentplaceUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: accidentplaceCreateOrConnectWithoutInsurersInput | accidentplaceCreateOrConnectWithoutInsurersInput[]
    createMany?: accidentplaceCreateManyInsurersInputEnvelope
    connect?: accidentplaceWhereUniqueInput | accidentplaceWhereUniqueInput[]
  }

  export type accidenttransactionsCreateNestedManyWithoutInsurersInput = {
    create?: XOR<accidenttransactionsCreateWithoutInsurersInput, accidenttransactionsUncheckedCreateWithoutInsurersInput> | accidenttransactionsCreateWithoutInsurersInput[] | accidenttransactionsUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: accidenttransactionsCreateOrConnectWithoutInsurersInput | accidenttransactionsCreateOrConnectWithoutInsurersInput[]
    createMany?: accidenttransactionsCreateManyInsurersInputEnvelope
    connect?: accidenttransactionsWhereUniqueInput | accidenttransactionsWhereUniqueInput[]
  }

  export type accidenttransactions22CreateNestedManyWithoutInsurersInput = {
    create?: XOR<accidenttransactions22CreateWithoutInsurersInput, accidenttransactions22UncheckedCreateWithoutInsurersInput> | accidenttransactions22CreateWithoutInsurersInput[] | accidenttransactions22UncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: accidenttransactions22CreateOrConnectWithoutInsurersInput | accidenttransactions22CreateOrConnectWithoutInsurersInput[]
    createMany?: accidenttransactions22CreateManyInsurersInputEnvelope
    connect?: accidenttransactions22WhereUniqueInput | accidenttransactions22WhereUniqueInput[]
  }

  export type causeofinjurysideCreateNestedManyWithoutInsurersInput = {
    create?: XOR<causeofinjurysideCreateWithoutInsurersInput, causeofinjurysideUncheckedCreateWithoutInsurersInput> | causeofinjurysideCreateWithoutInsurersInput[] | causeofinjurysideUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: causeofinjurysideCreateOrConnectWithoutInsurersInput | causeofinjurysideCreateOrConnectWithoutInsurersInput[]
    createMany?: causeofinjurysideCreateManyInsurersInputEnvelope
    connect?: causeofinjurysideWhereUniqueInput | causeofinjurysideWhereUniqueInput[]
  }

  export type causeofinjurywoundtypeCreateNestedManyWithoutInsurersInput = {
    create?: XOR<causeofinjurywoundtypeCreateWithoutInsurersInput, causeofinjurywoundtypeUncheckedCreateWithoutInsurersInput> | causeofinjurywoundtypeCreateWithoutInsurersInput[] | causeofinjurywoundtypeUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: causeofinjurywoundtypeCreateOrConnectWithoutInsurersInput | causeofinjurywoundtypeCreateOrConnectWithoutInsurersInput[]
    createMany?: causeofinjurywoundtypeCreateManyInsurersInputEnvelope
    connect?: causeofinjurywoundtypeWhereUniqueInput | causeofinjurywoundtypeWhereUniqueInput[]
  }

  export type claimantsCreateNestedManyWithoutInsurersInput = {
    create?: XOR<claimantsCreateWithoutInsurersInput, claimantsUncheckedCreateWithoutInsurersInput> | claimantsCreateWithoutInsurersInput[] | claimantsUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: claimantsCreateOrConnectWithoutInsurersInput | claimantsCreateOrConnectWithoutInsurersInput[]
    createMany?: claimantsCreateManyInsurersInputEnvelope
    connect?: claimantsWhereUniqueInput | claimantsWhereUniqueInput[]
  }

  export type claimdocumentsCreateNestedManyWithoutInsurersInput = {
    create?: XOR<claimdocumentsCreateWithoutInsurersInput, claimdocumentsUncheckedCreateWithoutInsurersInput> | claimdocumentsCreateWithoutInsurersInput[] | claimdocumentsUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: claimdocumentsCreateOrConnectWithoutInsurersInput | claimdocumentsCreateOrConnectWithoutInsurersInput[]
    createMany?: claimdocumentsCreateManyInsurersInputEnvelope
    connect?: claimdocumentsWhereUniqueInput | claimdocumentsWhereUniqueInput[]
  }

  export type claimstatusCreateNestedManyWithoutInsurersInput = {
    create?: XOR<claimstatusCreateWithoutInsurersInput, claimstatusUncheckedCreateWithoutInsurersInput> | claimstatusCreateWithoutInsurersInput[] | claimstatusUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: claimstatusCreateOrConnectWithoutInsurersInput | claimstatusCreateOrConnectWithoutInsurersInput[]
    createMany?: claimstatusCreateManyInsurersInputEnvelope
    connect?: claimstatusWhereUniqueInput | claimstatusWhereUniqueInput[]
  }

  export type diagnosistypemappingCreateNestedManyWithoutInsurersInput = {
    create?: XOR<diagnosistypemappingCreateWithoutInsurersInput, diagnosistypemappingUncheckedCreateWithoutInsurersInput> | diagnosistypemappingCreateWithoutInsurersInput[] | diagnosistypemappingUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: diagnosistypemappingCreateOrConnectWithoutInsurersInput | diagnosistypemappingCreateOrConnectWithoutInsurersInput[]
    createMany?: diagnosistypemappingCreateManyInsurersInputEnvelope
    connect?: diagnosistypemappingWhereUniqueInput | diagnosistypemappingWhereUniqueInput[]
  }

  export type documenttypeCreateNestedManyWithoutInsurersInput = {
    create?: XOR<documenttypeCreateWithoutInsurersInput, documenttypeUncheckedCreateWithoutInsurersInput> | documenttypeCreateWithoutInsurersInput[] | documenttypeUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: documenttypeCreateOrConnectWithoutInsurersInput | documenttypeCreateOrConnectWithoutInsurersInput[]
    createMany?: documenttypeCreateManyInsurersInputEnvelope
    connect?: documenttypeWhereUniqueInput | documenttypeWhereUniqueInput[]
  }

  export type illnesssurgeryCreateNestedManyWithoutInsurersInput = {
    create?: XOR<illnesssurgeryCreateWithoutInsurersInput, illnesssurgeryUncheckedCreateWithoutInsurersInput> | illnesssurgeryCreateWithoutInsurersInput[] | illnesssurgeryUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: illnesssurgeryCreateOrConnectWithoutInsurersInput | illnesssurgeryCreateOrConnectWithoutInsurersInput[]
    createMany?: illnesssurgeryCreateManyInsurersInputEnvelope
    connect?: illnesssurgeryWhereUniqueInput | illnesssurgeryWhereUniqueInput[]
  }

  export type illnesstypeCreateNestedManyWithoutInsurersInput = {
    create?: XOR<illnesstypeCreateWithoutInsurersInput, illnesstypeUncheckedCreateWithoutInsurersInput> | illnesstypeCreateWithoutInsurersInput[] | illnesstypeUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: illnesstypeCreateOrConnectWithoutInsurersInput | illnesstypeCreateOrConnectWithoutInsurersInput[]
    createMany?: illnesstypeCreateManyInsurersInputEnvelope
    connect?: illnesstypeWhereUniqueInput | illnesstypeWhereUniqueInput[]
  }

  export type policytypeCreateNestedManyWithoutInsurersInput = {
    create?: XOR<policytypeCreateWithoutInsurersInput, policytypeUncheckedCreateWithoutInsurersInput> | policytypeCreateWithoutInsurersInput[] | policytypeUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: policytypeCreateOrConnectWithoutInsurersInput | policytypeCreateOrConnectWithoutInsurersInput[]
    createMany?: policytypeCreateManyInsurersInputEnvelope
    connect?: policytypeWhereUniqueInput | policytypeWhereUniqueInput[]
  }

  export type proceduretransactionsCreateNestedManyWithoutInsurersInput = {
    create?: XOR<proceduretransactionsCreateWithoutInsurersInput, proceduretransactionsUncheckedCreateWithoutInsurersInput> | proceduretransactionsCreateWithoutInsurersInput[] | proceduretransactionsUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: proceduretransactionsCreateOrConnectWithoutInsurersInput | proceduretransactionsCreateOrConnectWithoutInsurersInput[]
    createMany?: proceduretransactionsCreateManyInsurersInputEnvelope
    connect?: proceduretransactionsWhereUniqueInput | proceduretransactionsWhereUniqueInput[]
  }

  export type servicesettingCreateNestedManyWithoutInsurersInput = {
    create?: XOR<servicesettingCreateWithoutInsurersInput, servicesettingUncheckedCreateWithoutInsurersInput> | servicesettingCreateWithoutInsurersInput[] | servicesettingUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: servicesettingCreateOrConnectWithoutInsurersInput | servicesettingCreateOrConnectWithoutInsurersInput[]
    createMany?: servicesettingCreateManyInsurersInputEnvelope
    connect?: servicesettingWhereUniqueInput | servicesettingWhereUniqueInput[]
  }

  export type accidentcauseover45daysUncheckedCreateNestedManyWithoutInsurersInput = {
    create?: XOR<accidentcauseover45daysCreateWithoutInsurersInput, accidentcauseover45daysUncheckedCreateWithoutInsurersInput> | accidentcauseover45daysCreateWithoutInsurersInput[] | accidentcauseover45daysUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: accidentcauseover45daysCreateOrConnectWithoutInsurersInput | accidentcauseover45daysCreateOrConnectWithoutInsurersInput[]
    createMany?: accidentcauseover45daysCreateManyInsurersInputEnvelope
    connect?: accidentcauseover45daysWhereUniqueInput | accidentcauseover45daysWhereUniqueInput[]
  }

  export type accidentplaceUncheckedCreateNestedManyWithoutInsurersInput = {
    create?: XOR<accidentplaceCreateWithoutInsurersInput, accidentplaceUncheckedCreateWithoutInsurersInput> | accidentplaceCreateWithoutInsurersInput[] | accidentplaceUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: accidentplaceCreateOrConnectWithoutInsurersInput | accidentplaceCreateOrConnectWithoutInsurersInput[]
    createMany?: accidentplaceCreateManyInsurersInputEnvelope
    connect?: accidentplaceWhereUniqueInput | accidentplaceWhereUniqueInput[]
  }

  export type accidenttransactionsUncheckedCreateNestedManyWithoutInsurersInput = {
    create?: XOR<accidenttransactionsCreateWithoutInsurersInput, accidenttransactionsUncheckedCreateWithoutInsurersInput> | accidenttransactionsCreateWithoutInsurersInput[] | accidenttransactionsUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: accidenttransactionsCreateOrConnectWithoutInsurersInput | accidenttransactionsCreateOrConnectWithoutInsurersInput[]
    createMany?: accidenttransactionsCreateManyInsurersInputEnvelope
    connect?: accidenttransactionsWhereUniqueInput | accidenttransactionsWhereUniqueInput[]
  }

  export type accidenttransactions22UncheckedCreateNestedManyWithoutInsurersInput = {
    create?: XOR<accidenttransactions22CreateWithoutInsurersInput, accidenttransactions22UncheckedCreateWithoutInsurersInput> | accidenttransactions22CreateWithoutInsurersInput[] | accidenttransactions22UncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: accidenttransactions22CreateOrConnectWithoutInsurersInput | accidenttransactions22CreateOrConnectWithoutInsurersInput[]
    createMany?: accidenttransactions22CreateManyInsurersInputEnvelope
    connect?: accidenttransactions22WhereUniqueInput | accidenttransactions22WhereUniqueInput[]
  }

  export type causeofinjurysideUncheckedCreateNestedManyWithoutInsurersInput = {
    create?: XOR<causeofinjurysideCreateWithoutInsurersInput, causeofinjurysideUncheckedCreateWithoutInsurersInput> | causeofinjurysideCreateWithoutInsurersInput[] | causeofinjurysideUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: causeofinjurysideCreateOrConnectWithoutInsurersInput | causeofinjurysideCreateOrConnectWithoutInsurersInput[]
    createMany?: causeofinjurysideCreateManyInsurersInputEnvelope
    connect?: causeofinjurysideWhereUniqueInput | causeofinjurysideWhereUniqueInput[]
  }

  export type causeofinjurywoundtypeUncheckedCreateNestedManyWithoutInsurersInput = {
    create?: XOR<causeofinjurywoundtypeCreateWithoutInsurersInput, causeofinjurywoundtypeUncheckedCreateWithoutInsurersInput> | causeofinjurywoundtypeCreateWithoutInsurersInput[] | causeofinjurywoundtypeUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: causeofinjurywoundtypeCreateOrConnectWithoutInsurersInput | causeofinjurywoundtypeCreateOrConnectWithoutInsurersInput[]
    createMany?: causeofinjurywoundtypeCreateManyInsurersInputEnvelope
    connect?: causeofinjurywoundtypeWhereUniqueInput | causeofinjurywoundtypeWhereUniqueInput[]
  }

  export type claimantsUncheckedCreateNestedManyWithoutInsurersInput = {
    create?: XOR<claimantsCreateWithoutInsurersInput, claimantsUncheckedCreateWithoutInsurersInput> | claimantsCreateWithoutInsurersInput[] | claimantsUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: claimantsCreateOrConnectWithoutInsurersInput | claimantsCreateOrConnectWithoutInsurersInput[]
    createMany?: claimantsCreateManyInsurersInputEnvelope
    connect?: claimantsWhereUniqueInput | claimantsWhereUniqueInput[]
  }

  export type claimdocumentsUncheckedCreateNestedManyWithoutInsurersInput = {
    create?: XOR<claimdocumentsCreateWithoutInsurersInput, claimdocumentsUncheckedCreateWithoutInsurersInput> | claimdocumentsCreateWithoutInsurersInput[] | claimdocumentsUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: claimdocumentsCreateOrConnectWithoutInsurersInput | claimdocumentsCreateOrConnectWithoutInsurersInput[]
    createMany?: claimdocumentsCreateManyInsurersInputEnvelope
    connect?: claimdocumentsWhereUniqueInput | claimdocumentsWhereUniqueInput[]
  }

  export type claimstatusUncheckedCreateNestedManyWithoutInsurersInput = {
    create?: XOR<claimstatusCreateWithoutInsurersInput, claimstatusUncheckedCreateWithoutInsurersInput> | claimstatusCreateWithoutInsurersInput[] | claimstatusUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: claimstatusCreateOrConnectWithoutInsurersInput | claimstatusCreateOrConnectWithoutInsurersInput[]
    createMany?: claimstatusCreateManyInsurersInputEnvelope
    connect?: claimstatusWhereUniqueInput | claimstatusWhereUniqueInput[]
  }

  export type diagnosistypemappingUncheckedCreateNestedManyWithoutInsurersInput = {
    create?: XOR<diagnosistypemappingCreateWithoutInsurersInput, diagnosistypemappingUncheckedCreateWithoutInsurersInput> | diagnosistypemappingCreateWithoutInsurersInput[] | diagnosistypemappingUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: diagnosistypemappingCreateOrConnectWithoutInsurersInput | diagnosistypemappingCreateOrConnectWithoutInsurersInput[]
    createMany?: diagnosistypemappingCreateManyInsurersInputEnvelope
    connect?: diagnosistypemappingWhereUniqueInput | diagnosistypemappingWhereUniqueInput[]
  }

  export type documenttypeUncheckedCreateNestedManyWithoutInsurersInput = {
    create?: XOR<documenttypeCreateWithoutInsurersInput, documenttypeUncheckedCreateWithoutInsurersInput> | documenttypeCreateWithoutInsurersInput[] | documenttypeUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: documenttypeCreateOrConnectWithoutInsurersInput | documenttypeCreateOrConnectWithoutInsurersInput[]
    createMany?: documenttypeCreateManyInsurersInputEnvelope
    connect?: documenttypeWhereUniqueInput | documenttypeWhereUniqueInput[]
  }

  export type illnesssurgeryUncheckedCreateNestedManyWithoutInsurersInput = {
    create?: XOR<illnesssurgeryCreateWithoutInsurersInput, illnesssurgeryUncheckedCreateWithoutInsurersInput> | illnesssurgeryCreateWithoutInsurersInput[] | illnesssurgeryUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: illnesssurgeryCreateOrConnectWithoutInsurersInput | illnesssurgeryCreateOrConnectWithoutInsurersInput[]
    createMany?: illnesssurgeryCreateManyInsurersInputEnvelope
    connect?: illnesssurgeryWhereUniqueInput | illnesssurgeryWhereUniqueInput[]
  }

  export type illnesstypeUncheckedCreateNestedManyWithoutInsurersInput = {
    create?: XOR<illnesstypeCreateWithoutInsurersInput, illnesstypeUncheckedCreateWithoutInsurersInput> | illnesstypeCreateWithoutInsurersInput[] | illnesstypeUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: illnesstypeCreateOrConnectWithoutInsurersInput | illnesstypeCreateOrConnectWithoutInsurersInput[]
    createMany?: illnesstypeCreateManyInsurersInputEnvelope
    connect?: illnesstypeWhereUniqueInput | illnesstypeWhereUniqueInput[]
  }

  export type policytypeUncheckedCreateNestedManyWithoutInsurersInput = {
    create?: XOR<policytypeCreateWithoutInsurersInput, policytypeUncheckedCreateWithoutInsurersInput> | policytypeCreateWithoutInsurersInput[] | policytypeUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: policytypeCreateOrConnectWithoutInsurersInput | policytypeCreateOrConnectWithoutInsurersInput[]
    createMany?: policytypeCreateManyInsurersInputEnvelope
    connect?: policytypeWhereUniqueInput | policytypeWhereUniqueInput[]
  }

  export type proceduretransactionsUncheckedCreateNestedManyWithoutInsurersInput = {
    create?: XOR<proceduretransactionsCreateWithoutInsurersInput, proceduretransactionsUncheckedCreateWithoutInsurersInput> | proceduretransactionsCreateWithoutInsurersInput[] | proceduretransactionsUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: proceduretransactionsCreateOrConnectWithoutInsurersInput | proceduretransactionsCreateOrConnectWithoutInsurersInput[]
    createMany?: proceduretransactionsCreateManyInsurersInputEnvelope
    connect?: proceduretransactionsWhereUniqueInput | proceduretransactionsWhereUniqueInput[]
  }

  export type servicesettingUncheckedCreateNestedManyWithoutInsurersInput = {
    create?: XOR<servicesettingCreateWithoutInsurersInput, servicesettingUncheckedCreateWithoutInsurersInput> | servicesettingCreateWithoutInsurersInput[] | servicesettingUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: servicesettingCreateOrConnectWithoutInsurersInput | servicesettingCreateOrConnectWithoutInsurersInput[]
    createMany?: servicesettingCreateManyInsurersInputEnvelope
    connect?: servicesettingWhereUniqueInput | servicesettingWhereUniqueInput[]
  }

  export type accidentcauseover45daysUpdateManyWithoutInsurersNestedInput = {
    create?: XOR<accidentcauseover45daysCreateWithoutInsurersInput, accidentcauseover45daysUncheckedCreateWithoutInsurersInput> | accidentcauseover45daysCreateWithoutInsurersInput[] | accidentcauseover45daysUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: accidentcauseover45daysCreateOrConnectWithoutInsurersInput | accidentcauseover45daysCreateOrConnectWithoutInsurersInput[]
    upsert?: accidentcauseover45daysUpsertWithWhereUniqueWithoutInsurersInput | accidentcauseover45daysUpsertWithWhereUniqueWithoutInsurersInput[]
    createMany?: accidentcauseover45daysCreateManyInsurersInputEnvelope
    set?: accidentcauseover45daysWhereUniqueInput | accidentcauseover45daysWhereUniqueInput[]
    disconnect?: accidentcauseover45daysWhereUniqueInput | accidentcauseover45daysWhereUniqueInput[]
    delete?: accidentcauseover45daysWhereUniqueInput | accidentcauseover45daysWhereUniqueInput[]
    connect?: accidentcauseover45daysWhereUniqueInput | accidentcauseover45daysWhereUniqueInput[]
    update?: accidentcauseover45daysUpdateWithWhereUniqueWithoutInsurersInput | accidentcauseover45daysUpdateWithWhereUniqueWithoutInsurersInput[]
    updateMany?: accidentcauseover45daysUpdateManyWithWhereWithoutInsurersInput | accidentcauseover45daysUpdateManyWithWhereWithoutInsurersInput[]
    deleteMany?: accidentcauseover45daysScalarWhereInput | accidentcauseover45daysScalarWhereInput[]
  }

  export type accidentplaceUpdateManyWithoutInsurersNestedInput = {
    create?: XOR<accidentplaceCreateWithoutInsurersInput, accidentplaceUncheckedCreateWithoutInsurersInput> | accidentplaceCreateWithoutInsurersInput[] | accidentplaceUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: accidentplaceCreateOrConnectWithoutInsurersInput | accidentplaceCreateOrConnectWithoutInsurersInput[]
    upsert?: accidentplaceUpsertWithWhereUniqueWithoutInsurersInput | accidentplaceUpsertWithWhereUniqueWithoutInsurersInput[]
    createMany?: accidentplaceCreateManyInsurersInputEnvelope
    set?: accidentplaceWhereUniqueInput | accidentplaceWhereUniqueInput[]
    disconnect?: accidentplaceWhereUniqueInput | accidentplaceWhereUniqueInput[]
    delete?: accidentplaceWhereUniqueInput | accidentplaceWhereUniqueInput[]
    connect?: accidentplaceWhereUniqueInput | accidentplaceWhereUniqueInput[]
    update?: accidentplaceUpdateWithWhereUniqueWithoutInsurersInput | accidentplaceUpdateWithWhereUniqueWithoutInsurersInput[]
    updateMany?: accidentplaceUpdateManyWithWhereWithoutInsurersInput | accidentplaceUpdateManyWithWhereWithoutInsurersInput[]
    deleteMany?: accidentplaceScalarWhereInput | accidentplaceScalarWhereInput[]
  }

  export type accidenttransactionsUpdateManyWithoutInsurersNestedInput = {
    create?: XOR<accidenttransactionsCreateWithoutInsurersInput, accidenttransactionsUncheckedCreateWithoutInsurersInput> | accidenttransactionsCreateWithoutInsurersInput[] | accidenttransactionsUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: accidenttransactionsCreateOrConnectWithoutInsurersInput | accidenttransactionsCreateOrConnectWithoutInsurersInput[]
    upsert?: accidenttransactionsUpsertWithWhereUniqueWithoutInsurersInput | accidenttransactionsUpsertWithWhereUniqueWithoutInsurersInput[]
    createMany?: accidenttransactionsCreateManyInsurersInputEnvelope
    set?: accidenttransactionsWhereUniqueInput | accidenttransactionsWhereUniqueInput[]
    disconnect?: accidenttransactionsWhereUniqueInput | accidenttransactionsWhereUniqueInput[]
    delete?: accidenttransactionsWhereUniqueInput | accidenttransactionsWhereUniqueInput[]
    connect?: accidenttransactionsWhereUniqueInput | accidenttransactionsWhereUniqueInput[]
    update?: accidenttransactionsUpdateWithWhereUniqueWithoutInsurersInput | accidenttransactionsUpdateWithWhereUniqueWithoutInsurersInput[]
    updateMany?: accidenttransactionsUpdateManyWithWhereWithoutInsurersInput | accidenttransactionsUpdateManyWithWhereWithoutInsurersInput[]
    deleteMany?: accidenttransactionsScalarWhereInput | accidenttransactionsScalarWhereInput[]
  }

  export type accidenttransactions22UpdateManyWithoutInsurersNestedInput = {
    create?: XOR<accidenttransactions22CreateWithoutInsurersInput, accidenttransactions22UncheckedCreateWithoutInsurersInput> | accidenttransactions22CreateWithoutInsurersInput[] | accidenttransactions22UncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: accidenttransactions22CreateOrConnectWithoutInsurersInput | accidenttransactions22CreateOrConnectWithoutInsurersInput[]
    upsert?: accidenttransactions22UpsertWithWhereUniqueWithoutInsurersInput | accidenttransactions22UpsertWithWhereUniqueWithoutInsurersInput[]
    createMany?: accidenttransactions22CreateManyInsurersInputEnvelope
    set?: accidenttransactions22WhereUniqueInput | accidenttransactions22WhereUniqueInput[]
    disconnect?: accidenttransactions22WhereUniqueInput | accidenttransactions22WhereUniqueInput[]
    delete?: accidenttransactions22WhereUniqueInput | accidenttransactions22WhereUniqueInput[]
    connect?: accidenttransactions22WhereUniqueInput | accidenttransactions22WhereUniqueInput[]
    update?: accidenttransactions22UpdateWithWhereUniqueWithoutInsurersInput | accidenttransactions22UpdateWithWhereUniqueWithoutInsurersInput[]
    updateMany?: accidenttransactions22UpdateManyWithWhereWithoutInsurersInput | accidenttransactions22UpdateManyWithWhereWithoutInsurersInput[]
    deleteMany?: accidenttransactions22ScalarWhereInput | accidenttransactions22ScalarWhereInput[]
  }

  export type causeofinjurysideUpdateManyWithoutInsurersNestedInput = {
    create?: XOR<causeofinjurysideCreateWithoutInsurersInput, causeofinjurysideUncheckedCreateWithoutInsurersInput> | causeofinjurysideCreateWithoutInsurersInput[] | causeofinjurysideUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: causeofinjurysideCreateOrConnectWithoutInsurersInput | causeofinjurysideCreateOrConnectWithoutInsurersInput[]
    upsert?: causeofinjurysideUpsertWithWhereUniqueWithoutInsurersInput | causeofinjurysideUpsertWithWhereUniqueWithoutInsurersInput[]
    createMany?: causeofinjurysideCreateManyInsurersInputEnvelope
    set?: causeofinjurysideWhereUniqueInput | causeofinjurysideWhereUniqueInput[]
    disconnect?: causeofinjurysideWhereUniqueInput | causeofinjurysideWhereUniqueInput[]
    delete?: causeofinjurysideWhereUniqueInput | causeofinjurysideWhereUniqueInput[]
    connect?: causeofinjurysideWhereUniqueInput | causeofinjurysideWhereUniqueInput[]
    update?: causeofinjurysideUpdateWithWhereUniqueWithoutInsurersInput | causeofinjurysideUpdateWithWhereUniqueWithoutInsurersInput[]
    updateMany?: causeofinjurysideUpdateManyWithWhereWithoutInsurersInput | causeofinjurysideUpdateManyWithWhereWithoutInsurersInput[]
    deleteMany?: causeofinjurysideScalarWhereInput | causeofinjurysideScalarWhereInput[]
  }

  export type causeofinjurywoundtypeUpdateManyWithoutInsurersNestedInput = {
    create?: XOR<causeofinjurywoundtypeCreateWithoutInsurersInput, causeofinjurywoundtypeUncheckedCreateWithoutInsurersInput> | causeofinjurywoundtypeCreateWithoutInsurersInput[] | causeofinjurywoundtypeUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: causeofinjurywoundtypeCreateOrConnectWithoutInsurersInput | causeofinjurywoundtypeCreateOrConnectWithoutInsurersInput[]
    upsert?: causeofinjurywoundtypeUpsertWithWhereUniqueWithoutInsurersInput | causeofinjurywoundtypeUpsertWithWhereUniqueWithoutInsurersInput[]
    createMany?: causeofinjurywoundtypeCreateManyInsurersInputEnvelope
    set?: causeofinjurywoundtypeWhereUniqueInput | causeofinjurywoundtypeWhereUniqueInput[]
    disconnect?: causeofinjurywoundtypeWhereUniqueInput | causeofinjurywoundtypeWhereUniqueInput[]
    delete?: causeofinjurywoundtypeWhereUniqueInput | causeofinjurywoundtypeWhereUniqueInput[]
    connect?: causeofinjurywoundtypeWhereUniqueInput | causeofinjurywoundtypeWhereUniqueInput[]
    update?: causeofinjurywoundtypeUpdateWithWhereUniqueWithoutInsurersInput | causeofinjurywoundtypeUpdateWithWhereUniqueWithoutInsurersInput[]
    updateMany?: causeofinjurywoundtypeUpdateManyWithWhereWithoutInsurersInput | causeofinjurywoundtypeUpdateManyWithWhereWithoutInsurersInput[]
    deleteMany?: causeofinjurywoundtypeScalarWhereInput | causeofinjurywoundtypeScalarWhereInput[]
  }

  export type claimantsUpdateManyWithoutInsurersNestedInput = {
    create?: XOR<claimantsCreateWithoutInsurersInput, claimantsUncheckedCreateWithoutInsurersInput> | claimantsCreateWithoutInsurersInput[] | claimantsUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: claimantsCreateOrConnectWithoutInsurersInput | claimantsCreateOrConnectWithoutInsurersInput[]
    upsert?: claimantsUpsertWithWhereUniqueWithoutInsurersInput | claimantsUpsertWithWhereUniqueWithoutInsurersInput[]
    createMany?: claimantsCreateManyInsurersInputEnvelope
    set?: claimantsWhereUniqueInput | claimantsWhereUniqueInput[]
    disconnect?: claimantsWhereUniqueInput | claimantsWhereUniqueInput[]
    delete?: claimantsWhereUniqueInput | claimantsWhereUniqueInput[]
    connect?: claimantsWhereUniqueInput | claimantsWhereUniqueInput[]
    update?: claimantsUpdateWithWhereUniqueWithoutInsurersInput | claimantsUpdateWithWhereUniqueWithoutInsurersInput[]
    updateMany?: claimantsUpdateManyWithWhereWithoutInsurersInput | claimantsUpdateManyWithWhereWithoutInsurersInput[]
    deleteMany?: claimantsScalarWhereInput | claimantsScalarWhereInput[]
  }

  export type claimdocumentsUpdateManyWithoutInsurersNestedInput = {
    create?: XOR<claimdocumentsCreateWithoutInsurersInput, claimdocumentsUncheckedCreateWithoutInsurersInput> | claimdocumentsCreateWithoutInsurersInput[] | claimdocumentsUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: claimdocumentsCreateOrConnectWithoutInsurersInput | claimdocumentsCreateOrConnectWithoutInsurersInput[]
    upsert?: claimdocumentsUpsertWithWhereUniqueWithoutInsurersInput | claimdocumentsUpsertWithWhereUniqueWithoutInsurersInput[]
    createMany?: claimdocumentsCreateManyInsurersInputEnvelope
    set?: claimdocumentsWhereUniqueInput | claimdocumentsWhereUniqueInput[]
    disconnect?: claimdocumentsWhereUniqueInput | claimdocumentsWhereUniqueInput[]
    delete?: claimdocumentsWhereUniqueInput | claimdocumentsWhereUniqueInput[]
    connect?: claimdocumentsWhereUniqueInput | claimdocumentsWhereUniqueInput[]
    update?: claimdocumentsUpdateWithWhereUniqueWithoutInsurersInput | claimdocumentsUpdateWithWhereUniqueWithoutInsurersInput[]
    updateMany?: claimdocumentsUpdateManyWithWhereWithoutInsurersInput | claimdocumentsUpdateManyWithWhereWithoutInsurersInput[]
    deleteMany?: claimdocumentsScalarWhereInput | claimdocumentsScalarWhereInput[]
  }

  export type claimstatusUpdateManyWithoutInsurersNestedInput = {
    create?: XOR<claimstatusCreateWithoutInsurersInput, claimstatusUncheckedCreateWithoutInsurersInput> | claimstatusCreateWithoutInsurersInput[] | claimstatusUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: claimstatusCreateOrConnectWithoutInsurersInput | claimstatusCreateOrConnectWithoutInsurersInput[]
    upsert?: claimstatusUpsertWithWhereUniqueWithoutInsurersInput | claimstatusUpsertWithWhereUniqueWithoutInsurersInput[]
    createMany?: claimstatusCreateManyInsurersInputEnvelope
    set?: claimstatusWhereUniqueInput | claimstatusWhereUniqueInput[]
    disconnect?: claimstatusWhereUniqueInput | claimstatusWhereUniqueInput[]
    delete?: claimstatusWhereUniqueInput | claimstatusWhereUniqueInput[]
    connect?: claimstatusWhereUniqueInput | claimstatusWhereUniqueInput[]
    update?: claimstatusUpdateWithWhereUniqueWithoutInsurersInput | claimstatusUpdateWithWhereUniqueWithoutInsurersInput[]
    updateMany?: claimstatusUpdateManyWithWhereWithoutInsurersInput | claimstatusUpdateManyWithWhereWithoutInsurersInput[]
    deleteMany?: claimstatusScalarWhereInput | claimstatusScalarWhereInput[]
  }

  export type diagnosistypemappingUpdateManyWithoutInsurersNestedInput = {
    create?: XOR<diagnosistypemappingCreateWithoutInsurersInput, diagnosistypemappingUncheckedCreateWithoutInsurersInput> | diagnosistypemappingCreateWithoutInsurersInput[] | diagnosistypemappingUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: diagnosistypemappingCreateOrConnectWithoutInsurersInput | diagnosistypemappingCreateOrConnectWithoutInsurersInput[]
    upsert?: diagnosistypemappingUpsertWithWhereUniqueWithoutInsurersInput | diagnosistypemappingUpsertWithWhereUniqueWithoutInsurersInput[]
    createMany?: diagnosistypemappingCreateManyInsurersInputEnvelope
    set?: diagnosistypemappingWhereUniqueInput | diagnosistypemappingWhereUniqueInput[]
    disconnect?: diagnosistypemappingWhereUniqueInput | diagnosistypemappingWhereUniqueInput[]
    delete?: diagnosistypemappingWhereUniqueInput | diagnosistypemappingWhereUniqueInput[]
    connect?: diagnosistypemappingWhereUniqueInput | diagnosistypemappingWhereUniqueInput[]
    update?: diagnosistypemappingUpdateWithWhereUniqueWithoutInsurersInput | diagnosistypemappingUpdateWithWhereUniqueWithoutInsurersInput[]
    updateMany?: diagnosistypemappingUpdateManyWithWhereWithoutInsurersInput | diagnosistypemappingUpdateManyWithWhereWithoutInsurersInput[]
    deleteMany?: diagnosistypemappingScalarWhereInput | diagnosistypemappingScalarWhereInput[]
  }

  export type documenttypeUpdateManyWithoutInsurersNestedInput = {
    create?: XOR<documenttypeCreateWithoutInsurersInput, documenttypeUncheckedCreateWithoutInsurersInput> | documenttypeCreateWithoutInsurersInput[] | documenttypeUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: documenttypeCreateOrConnectWithoutInsurersInput | documenttypeCreateOrConnectWithoutInsurersInput[]
    upsert?: documenttypeUpsertWithWhereUniqueWithoutInsurersInput | documenttypeUpsertWithWhereUniqueWithoutInsurersInput[]
    createMany?: documenttypeCreateManyInsurersInputEnvelope
    set?: documenttypeWhereUniqueInput | documenttypeWhereUniqueInput[]
    disconnect?: documenttypeWhereUniqueInput | documenttypeWhereUniqueInput[]
    delete?: documenttypeWhereUniqueInput | documenttypeWhereUniqueInput[]
    connect?: documenttypeWhereUniqueInput | documenttypeWhereUniqueInput[]
    update?: documenttypeUpdateWithWhereUniqueWithoutInsurersInput | documenttypeUpdateWithWhereUniqueWithoutInsurersInput[]
    updateMany?: documenttypeUpdateManyWithWhereWithoutInsurersInput | documenttypeUpdateManyWithWhereWithoutInsurersInput[]
    deleteMany?: documenttypeScalarWhereInput | documenttypeScalarWhereInput[]
  }

  export type illnesssurgeryUpdateManyWithoutInsurersNestedInput = {
    create?: XOR<illnesssurgeryCreateWithoutInsurersInput, illnesssurgeryUncheckedCreateWithoutInsurersInput> | illnesssurgeryCreateWithoutInsurersInput[] | illnesssurgeryUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: illnesssurgeryCreateOrConnectWithoutInsurersInput | illnesssurgeryCreateOrConnectWithoutInsurersInput[]
    upsert?: illnesssurgeryUpsertWithWhereUniqueWithoutInsurersInput | illnesssurgeryUpsertWithWhereUniqueWithoutInsurersInput[]
    createMany?: illnesssurgeryCreateManyInsurersInputEnvelope
    set?: illnesssurgeryWhereUniqueInput | illnesssurgeryWhereUniqueInput[]
    disconnect?: illnesssurgeryWhereUniqueInput | illnesssurgeryWhereUniqueInput[]
    delete?: illnesssurgeryWhereUniqueInput | illnesssurgeryWhereUniqueInput[]
    connect?: illnesssurgeryWhereUniqueInput | illnesssurgeryWhereUniqueInput[]
    update?: illnesssurgeryUpdateWithWhereUniqueWithoutInsurersInput | illnesssurgeryUpdateWithWhereUniqueWithoutInsurersInput[]
    updateMany?: illnesssurgeryUpdateManyWithWhereWithoutInsurersInput | illnesssurgeryUpdateManyWithWhereWithoutInsurersInput[]
    deleteMany?: illnesssurgeryScalarWhereInput | illnesssurgeryScalarWhereInput[]
  }

  export type illnesstypeUpdateManyWithoutInsurersNestedInput = {
    create?: XOR<illnesstypeCreateWithoutInsurersInput, illnesstypeUncheckedCreateWithoutInsurersInput> | illnesstypeCreateWithoutInsurersInput[] | illnesstypeUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: illnesstypeCreateOrConnectWithoutInsurersInput | illnesstypeCreateOrConnectWithoutInsurersInput[]
    upsert?: illnesstypeUpsertWithWhereUniqueWithoutInsurersInput | illnesstypeUpsertWithWhereUniqueWithoutInsurersInput[]
    createMany?: illnesstypeCreateManyInsurersInputEnvelope
    set?: illnesstypeWhereUniqueInput | illnesstypeWhereUniqueInput[]
    disconnect?: illnesstypeWhereUniqueInput | illnesstypeWhereUniqueInput[]
    delete?: illnesstypeWhereUniqueInput | illnesstypeWhereUniqueInput[]
    connect?: illnesstypeWhereUniqueInput | illnesstypeWhereUniqueInput[]
    update?: illnesstypeUpdateWithWhereUniqueWithoutInsurersInput | illnesstypeUpdateWithWhereUniqueWithoutInsurersInput[]
    updateMany?: illnesstypeUpdateManyWithWhereWithoutInsurersInput | illnesstypeUpdateManyWithWhereWithoutInsurersInput[]
    deleteMany?: illnesstypeScalarWhereInput | illnesstypeScalarWhereInput[]
  }

  export type policytypeUpdateManyWithoutInsurersNestedInput = {
    create?: XOR<policytypeCreateWithoutInsurersInput, policytypeUncheckedCreateWithoutInsurersInput> | policytypeCreateWithoutInsurersInput[] | policytypeUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: policytypeCreateOrConnectWithoutInsurersInput | policytypeCreateOrConnectWithoutInsurersInput[]
    upsert?: policytypeUpsertWithWhereUniqueWithoutInsurersInput | policytypeUpsertWithWhereUniqueWithoutInsurersInput[]
    createMany?: policytypeCreateManyInsurersInputEnvelope
    set?: policytypeWhereUniqueInput | policytypeWhereUniqueInput[]
    disconnect?: policytypeWhereUniqueInput | policytypeWhereUniqueInput[]
    delete?: policytypeWhereUniqueInput | policytypeWhereUniqueInput[]
    connect?: policytypeWhereUniqueInput | policytypeWhereUniqueInput[]
    update?: policytypeUpdateWithWhereUniqueWithoutInsurersInput | policytypeUpdateWithWhereUniqueWithoutInsurersInput[]
    updateMany?: policytypeUpdateManyWithWhereWithoutInsurersInput | policytypeUpdateManyWithWhereWithoutInsurersInput[]
    deleteMany?: policytypeScalarWhereInput | policytypeScalarWhereInput[]
  }

  export type proceduretransactionsUpdateManyWithoutInsurersNestedInput = {
    create?: XOR<proceduretransactionsCreateWithoutInsurersInput, proceduretransactionsUncheckedCreateWithoutInsurersInput> | proceduretransactionsCreateWithoutInsurersInput[] | proceduretransactionsUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: proceduretransactionsCreateOrConnectWithoutInsurersInput | proceduretransactionsCreateOrConnectWithoutInsurersInput[]
    upsert?: proceduretransactionsUpsertWithWhereUniqueWithoutInsurersInput | proceduretransactionsUpsertWithWhereUniqueWithoutInsurersInput[]
    createMany?: proceduretransactionsCreateManyInsurersInputEnvelope
    set?: proceduretransactionsWhereUniqueInput | proceduretransactionsWhereUniqueInput[]
    disconnect?: proceduretransactionsWhereUniqueInput | proceduretransactionsWhereUniqueInput[]
    delete?: proceduretransactionsWhereUniqueInput | proceduretransactionsWhereUniqueInput[]
    connect?: proceduretransactionsWhereUniqueInput | proceduretransactionsWhereUniqueInput[]
    update?: proceduretransactionsUpdateWithWhereUniqueWithoutInsurersInput | proceduretransactionsUpdateWithWhereUniqueWithoutInsurersInput[]
    updateMany?: proceduretransactionsUpdateManyWithWhereWithoutInsurersInput | proceduretransactionsUpdateManyWithWhereWithoutInsurersInput[]
    deleteMany?: proceduretransactionsScalarWhereInput | proceduretransactionsScalarWhereInput[]
  }

  export type servicesettingUpdateManyWithoutInsurersNestedInput = {
    create?: XOR<servicesettingCreateWithoutInsurersInput, servicesettingUncheckedCreateWithoutInsurersInput> | servicesettingCreateWithoutInsurersInput[] | servicesettingUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: servicesettingCreateOrConnectWithoutInsurersInput | servicesettingCreateOrConnectWithoutInsurersInput[]
    upsert?: servicesettingUpsertWithWhereUniqueWithoutInsurersInput | servicesettingUpsertWithWhereUniqueWithoutInsurersInput[]
    createMany?: servicesettingCreateManyInsurersInputEnvelope
    set?: servicesettingWhereUniqueInput | servicesettingWhereUniqueInput[]
    disconnect?: servicesettingWhereUniqueInput | servicesettingWhereUniqueInput[]
    delete?: servicesettingWhereUniqueInput | servicesettingWhereUniqueInput[]
    connect?: servicesettingWhereUniqueInput | servicesettingWhereUniqueInput[]
    update?: servicesettingUpdateWithWhereUniqueWithoutInsurersInput | servicesettingUpdateWithWhereUniqueWithoutInsurersInput[]
    updateMany?: servicesettingUpdateManyWithWhereWithoutInsurersInput | servicesettingUpdateManyWithWhereWithoutInsurersInput[]
    deleteMany?: servicesettingScalarWhereInput | servicesettingScalarWhereInput[]
  }

  export type accidentcauseover45daysUncheckedUpdateManyWithoutInsurersNestedInput = {
    create?: XOR<accidentcauseover45daysCreateWithoutInsurersInput, accidentcauseover45daysUncheckedCreateWithoutInsurersInput> | accidentcauseover45daysCreateWithoutInsurersInput[] | accidentcauseover45daysUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: accidentcauseover45daysCreateOrConnectWithoutInsurersInput | accidentcauseover45daysCreateOrConnectWithoutInsurersInput[]
    upsert?: accidentcauseover45daysUpsertWithWhereUniqueWithoutInsurersInput | accidentcauseover45daysUpsertWithWhereUniqueWithoutInsurersInput[]
    createMany?: accidentcauseover45daysCreateManyInsurersInputEnvelope
    set?: accidentcauseover45daysWhereUniqueInput | accidentcauseover45daysWhereUniqueInput[]
    disconnect?: accidentcauseover45daysWhereUniqueInput | accidentcauseover45daysWhereUniqueInput[]
    delete?: accidentcauseover45daysWhereUniqueInput | accidentcauseover45daysWhereUniqueInput[]
    connect?: accidentcauseover45daysWhereUniqueInput | accidentcauseover45daysWhereUniqueInput[]
    update?: accidentcauseover45daysUpdateWithWhereUniqueWithoutInsurersInput | accidentcauseover45daysUpdateWithWhereUniqueWithoutInsurersInput[]
    updateMany?: accidentcauseover45daysUpdateManyWithWhereWithoutInsurersInput | accidentcauseover45daysUpdateManyWithWhereWithoutInsurersInput[]
    deleteMany?: accidentcauseover45daysScalarWhereInput | accidentcauseover45daysScalarWhereInput[]
  }

  export type accidentplaceUncheckedUpdateManyWithoutInsurersNestedInput = {
    create?: XOR<accidentplaceCreateWithoutInsurersInput, accidentplaceUncheckedCreateWithoutInsurersInput> | accidentplaceCreateWithoutInsurersInput[] | accidentplaceUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: accidentplaceCreateOrConnectWithoutInsurersInput | accidentplaceCreateOrConnectWithoutInsurersInput[]
    upsert?: accidentplaceUpsertWithWhereUniqueWithoutInsurersInput | accidentplaceUpsertWithWhereUniqueWithoutInsurersInput[]
    createMany?: accidentplaceCreateManyInsurersInputEnvelope
    set?: accidentplaceWhereUniqueInput | accidentplaceWhereUniqueInput[]
    disconnect?: accidentplaceWhereUniqueInput | accidentplaceWhereUniqueInput[]
    delete?: accidentplaceWhereUniqueInput | accidentplaceWhereUniqueInput[]
    connect?: accidentplaceWhereUniqueInput | accidentplaceWhereUniqueInput[]
    update?: accidentplaceUpdateWithWhereUniqueWithoutInsurersInput | accidentplaceUpdateWithWhereUniqueWithoutInsurersInput[]
    updateMany?: accidentplaceUpdateManyWithWhereWithoutInsurersInput | accidentplaceUpdateManyWithWhereWithoutInsurersInput[]
    deleteMany?: accidentplaceScalarWhereInput | accidentplaceScalarWhereInput[]
  }

  export type accidenttransactionsUncheckedUpdateManyWithoutInsurersNestedInput = {
    create?: XOR<accidenttransactionsCreateWithoutInsurersInput, accidenttransactionsUncheckedCreateWithoutInsurersInput> | accidenttransactionsCreateWithoutInsurersInput[] | accidenttransactionsUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: accidenttransactionsCreateOrConnectWithoutInsurersInput | accidenttransactionsCreateOrConnectWithoutInsurersInput[]
    upsert?: accidenttransactionsUpsertWithWhereUniqueWithoutInsurersInput | accidenttransactionsUpsertWithWhereUniqueWithoutInsurersInput[]
    createMany?: accidenttransactionsCreateManyInsurersInputEnvelope
    set?: accidenttransactionsWhereUniqueInput | accidenttransactionsWhereUniqueInput[]
    disconnect?: accidenttransactionsWhereUniqueInput | accidenttransactionsWhereUniqueInput[]
    delete?: accidenttransactionsWhereUniqueInput | accidenttransactionsWhereUniqueInput[]
    connect?: accidenttransactionsWhereUniqueInput | accidenttransactionsWhereUniqueInput[]
    update?: accidenttransactionsUpdateWithWhereUniqueWithoutInsurersInput | accidenttransactionsUpdateWithWhereUniqueWithoutInsurersInput[]
    updateMany?: accidenttransactionsUpdateManyWithWhereWithoutInsurersInput | accidenttransactionsUpdateManyWithWhereWithoutInsurersInput[]
    deleteMany?: accidenttransactionsScalarWhereInput | accidenttransactionsScalarWhereInput[]
  }

  export type accidenttransactions22UncheckedUpdateManyWithoutInsurersNestedInput = {
    create?: XOR<accidenttransactions22CreateWithoutInsurersInput, accidenttransactions22UncheckedCreateWithoutInsurersInput> | accidenttransactions22CreateWithoutInsurersInput[] | accidenttransactions22UncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: accidenttransactions22CreateOrConnectWithoutInsurersInput | accidenttransactions22CreateOrConnectWithoutInsurersInput[]
    upsert?: accidenttransactions22UpsertWithWhereUniqueWithoutInsurersInput | accidenttransactions22UpsertWithWhereUniqueWithoutInsurersInput[]
    createMany?: accidenttransactions22CreateManyInsurersInputEnvelope
    set?: accidenttransactions22WhereUniqueInput | accidenttransactions22WhereUniqueInput[]
    disconnect?: accidenttransactions22WhereUniqueInput | accidenttransactions22WhereUniqueInput[]
    delete?: accidenttransactions22WhereUniqueInput | accidenttransactions22WhereUniqueInput[]
    connect?: accidenttransactions22WhereUniqueInput | accidenttransactions22WhereUniqueInput[]
    update?: accidenttransactions22UpdateWithWhereUniqueWithoutInsurersInput | accidenttransactions22UpdateWithWhereUniqueWithoutInsurersInput[]
    updateMany?: accidenttransactions22UpdateManyWithWhereWithoutInsurersInput | accidenttransactions22UpdateManyWithWhereWithoutInsurersInput[]
    deleteMany?: accidenttransactions22ScalarWhereInput | accidenttransactions22ScalarWhereInput[]
  }

  export type causeofinjurysideUncheckedUpdateManyWithoutInsurersNestedInput = {
    create?: XOR<causeofinjurysideCreateWithoutInsurersInput, causeofinjurysideUncheckedCreateWithoutInsurersInput> | causeofinjurysideCreateWithoutInsurersInput[] | causeofinjurysideUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: causeofinjurysideCreateOrConnectWithoutInsurersInput | causeofinjurysideCreateOrConnectWithoutInsurersInput[]
    upsert?: causeofinjurysideUpsertWithWhereUniqueWithoutInsurersInput | causeofinjurysideUpsertWithWhereUniqueWithoutInsurersInput[]
    createMany?: causeofinjurysideCreateManyInsurersInputEnvelope
    set?: causeofinjurysideWhereUniqueInput | causeofinjurysideWhereUniqueInput[]
    disconnect?: causeofinjurysideWhereUniqueInput | causeofinjurysideWhereUniqueInput[]
    delete?: causeofinjurysideWhereUniqueInput | causeofinjurysideWhereUniqueInput[]
    connect?: causeofinjurysideWhereUniqueInput | causeofinjurysideWhereUniqueInput[]
    update?: causeofinjurysideUpdateWithWhereUniqueWithoutInsurersInput | causeofinjurysideUpdateWithWhereUniqueWithoutInsurersInput[]
    updateMany?: causeofinjurysideUpdateManyWithWhereWithoutInsurersInput | causeofinjurysideUpdateManyWithWhereWithoutInsurersInput[]
    deleteMany?: causeofinjurysideScalarWhereInput | causeofinjurysideScalarWhereInput[]
  }

  export type causeofinjurywoundtypeUncheckedUpdateManyWithoutInsurersNestedInput = {
    create?: XOR<causeofinjurywoundtypeCreateWithoutInsurersInput, causeofinjurywoundtypeUncheckedCreateWithoutInsurersInput> | causeofinjurywoundtypeCreateWithoutInsurersInput[] | causeofinjurywoundtypeUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: causeofinjurywoundtypeCreateOrConnectWithoutInsurersInput | causeofinjurywoundtypeCreateOrConnectWithoutInsurersInput[]
    upsert?: causeofinjurywoundtypeUpsertWithWhereUniqueWithoutInsurersInput | causeofinjurywoundtypeUpsertWithWhereUniqueWithoutInsurersInput[]
    createMany?: causeofinjurywoundtypeCreateManyInsurersInputEnvelope
    set?: causeofinjurywoundtypeWhereUniqueInput | causeofinjurywoundtypeWhereUniqueInput[]
    disconnect?: causeofinjurywoundtypeWhereUniqueInput | causeofinjurywoundtypeWhereUniqueInput[]
    delete?: causeofinjurywoundtypeWhereUniqueInput | causeofinjurywoundtypeWhereUniqueInput[]
    connect?: causeofinjurywoundtypeWhereUniqueInput | causeofinjurywoundtypeWhereUniqueInput[]
    update?: causeofinjurywoundtypeUpdateWithWhereUniqueWithoutInsurersInput | causeofinjurywoundtypeUpdateWithWhereUniqueWithoutInsurersInput[]
    updateMany?: causeofinjurywoundtypeUpdateManyWithWhereWithoutInsurersInput | causeofinjurywoundtypeUpdateManyWithWhereWithoutInsurersInput[]
    deleteMany?: causeofinjurywoundtypeScalarWhereInput | causeofinjurywoundtypeScalarWhereInput[]
  }

  export type claimantsUncheckedUpdateManyWithoutInsurersNestedInput = {
    create?: XOR<claimantsCreateWithoutInsurersInput, claimantsUncheckedCreateWithoutInsurersInput> | claimantsCreateWithoutInsurersInput[] | claimantsUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: claimantsCreateOrConnectWithoutInsurersInput | claimantsCreateOrConnectWithoutInsurersInput[]
    upsert?: claimantsUpsertWithWhereUniqueWithoutInsurersInput | claimantsUpsertWithWhereUniqueWithoutInsurersInput[]
    createMany?: claimantsCreateManyInsurersInputEnvelope
    set?: claimantsWhereUniqueInput | claimantsWhereUniqueInput[]
    disconnect?: claimantsWhereUniqueInput | claimantsWhereUniqueInput[]
    delete?: claimantsWhereUniqueInput | claimantsWhereUniqueInput[]
    connect?: claimantsWhereUniqueInput | claimantsWhereUniqueInput[]
    update?: claimantsUpdateWithWhereUniqueWithoutInsurersInput | claimantsUpdateWithWhereUniqueWithoutInsurersInput[]
    updateMany?: claimantsUpdateManyWithWhereWithoutInsurersInput | claimantsUpdateManyWithWhereWithoutInsurersInput[]
    deleteMany?: claimantsScalarWhereInput | claimantsScalarWhereInput[]
  }

  export type claimdocumentsUncheckedUpdateManyWithoutInsurersNestedInput = {
    create?: XOR<claimdocumentsCreateWithoutInsurersInput, claimdocumentsUncheckedCreateWithoutInsurersInput> | claimdocumentsCreateWithoutInsurersInput[] | claimdocumentsUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: claimdocumentsCreateOrConnectWithoutInsurersInput | claimdocumentsCreateOrConnectWithoutInsurersInput[]
    upsert?: claimdocumentsUpsertWithWhereUniqueWithoutInsurersInput | claimdocumentsUpsertWithWhereUniqueWithoutInsurersInput[]
    createMany?: claimdocumentsCreateManyInsurersInputEnvelope
    set?: claimdocumentsWhereUniqueInput | claimdocumentsWhereUniqueInput[]
    disconnect?: claimdocumentsWhereUniqueInput | claimdocumentsWhereUniqueInput[]
    delete?: claimdocumentsWhereUniqueInput | claimdocumentsWhereUniqueInput[]
    connect?: claimdocumentsWhereUniqueInput | claimdocumentsWhereUniqueInput[]
    update?: claimdocumentsUpdateWithWhereUniqueWithoutInsurersInput | claimdocumentsUpdateWithWhereUniqueWithoutInsurersInput[]
    updateMany?: claimdocumentsUpdateManyWithWhereWithoutInsurersInput | claimdocumentsUpdateManyWithWhereWithoutInsurersInput[]
    deleteMany?: claimdocumentsScalarWhereInput | claimdocumentsScalarWhereInput[]
  }

  export type claimstatusUncheckedUpdateManyWithoutInsurersNestedInput = {
    create?: XOR<claimstatusCreateWithoutInsurersInput, claimstatusUncheckedCreateWithoutInsurersInput> | claimstatusCreateWithoutInsurersInput[] | claimstatusUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: claimstatusCreateOrConnectWithoutInsurersInput | claimstatusCreateOrConnectWithoutInsurersInput[]
    upsert?: claimstatusUpsertWithWhereUniqueWithoutInsurersInput | claimstatusUpsertWithWhereUniqueWithoutInsurersInput[]
    createMany?: claimstatusCreateManyInsurersInputEnvelope
    set?: claimstatusWhereUniqueInput | claimstatusWhereUniqueInput[]
    disconnect?: claimstatusWhereUniqueInput | claimstatusWhereUniqueInput[]
    delete?: claimstatusWhereUniqueInput | claimstatusWhereUniqueInput[]
    connect?: claimstatusWhereUniqueInput | claimstatusWhereUniqueInput[]
    update?: claimstatusUpdateWithWhereUniqueWithoutInsurersInput | claimstatusUpdateWithWhereUniqueWithoutInsurersInput[]
    updateMany?: claimstatusUpdateManyWithWhereWithoutInsurersInput | claimstatusUpdateManyWithWhereWithoutInsurersInput[]
    deleteMany?: claimstatusScalarWhereInput | claimstatusScalarWhereInput[]
  }

  export type diagnosistypemappingUncheckedUpdateManyWithoutInsurersNestedInput = {
    create?: XOR<diagnosistypemappingCreateWithoutInsurersInput, diagnosistypemappingUncheckedCreateWithoutInsurersInput> | diagnosistypemappingCreateWithoutInsurersInput[] | diagnosistypemappingUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: diagnosistypemappingCreateOrConnectWithoutInsurersInput | diagnosistypemappingCreateOrConnectWithoutInsurersInput[]
    upsert?: diagnosistypemappingUpsertWithWhereUniqueWithoutInsurersInput | diagnosistypemappingUpsertWithWhereUniqueWithoutInsurersInput[]
    createMany?: diagnosistypemappingCreateManyInsurersInputEnvelope
    set?: diagnosistypemappingWhereUniqueInput | diagnosistypemappingWhereUniqueInput[]
    disconnect?: diagnosistypemappingWhereUniqueInput | diagnosistypemappingWhereUniqueInput[]
    delete?: diagnosistypemappingWhereUniqueInput | diagnosistypemappingWhereUniqueInput[]
    connect?: diagnosistypemappingWhereUniqueInput | diagnosistypemappingWhereUniqueInput[]
    update?: diagnosistypemappingUpdateWithWhereUniqueWithoutInsurersInput | diagnosistypemappingUpdateWithWhereUniqueWithoutInsurersInput[]
    updateMany?: diagnosistypemappingUpdateManyWithWhereWithoutInsurersInput | diagnosistypemappingUpdateManyWithWhereWithoutInsurersInput[]
    deleteMany?: diagnosistypemappingScalarWhereInput | diagnosistypemappingScalarWhereInput[]
  }

  export type documenttypeUncheckedUpdateManyWithoutInsurersNestedInput = {
    create?: XOR<documenttypeCreateWithoutInsurersInput, documenttypeUncheckedCreateWithoutInsurersInput> | documenttypeCreateWithoutInsurersInput[] | documenttypeUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: documenttypeCreateOrConnectWithoutInsurersInput | documenttypeCreateOrConnectWithoutInsurersInput[]
    upsert?: documenttypeUpsertWithWhereUniqueWithoutInsurersInput | documenttypeUpsertWithWhereUniqueWithoutInsurersInput[]
    createMany?: documenttypeCreateManyInsurersInputEnvelope
    set?: documenttypeWhereUniqueInput | documenttypeWhereUniqueInput[]
    disconnect?: documenttypeWhereUniqueInput | documenttypeWhereUniqueInput[]
    delete?: documenttypeWhereUniqueInput | documenttypeWhereUniqueInput[]
    connect?: documenttypeWhereUniqueInput | documenttypeWhereUniqueInput[]
    update?: documenttypeUpdateWithWhereUniqueWithoutInsurersInput | documenttypeUpdateWithWhereUniqueWithoutInsurersInput[]
    updateMany?: documenttypeUpdateManyWithWhereWithoutInsurersInput | documenttypeUpdateManyWithWhereWithoutInsurersInput[]
    deleteMany?: documenttypeScalarWhereInput | documenttypeScalarWhereInput[]
  }

  export type illnesssurgeryUncheckedUpdateManyWithoutInsurersNestedInput = {
    create?: XOR<illnesssurgeryCreateWithoutInsurersInput, illnesssurgeryUncheckedCreateWithoutInsurersInput> | illnesssurgeryCreateWithoutInsurersInput[] | illnesssurgeryUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: illnesssurgeryCreateOrConnectWithoutInsurersInput | illnesssurgeryCreateOrConnectWithoutInsurersInput[]
    upsert?: illnesssurgeryUpsertWithWhereUniqueWithoutInsurersInput | illnesssurgeryUpsertWithWhereUniqueWithoutInsurersInput[]
    createMany?: illnesssurgeryCreateManyInsurersInputEnvelope
    set?: illnesssurgeryWhereUniqueInput | illnesssurgeryWhereUniqueInput[]
    disconnect?: illnesssurgeryWhereUniqueInput | illnesssurgeryWhereUniqueInput[]
    delete?: illnesssurgeryWhereUniqueInput | illnesssurgeryWhereUniqueInput[]
    connect?: illnesssurgeryWhereUniqueInput | illnesssurgeryWhereUniqueInput[]
    update?: illnesssurgeryUpdateWithWhereUniqueWithoutInsurersInput | illnesssurgeryUpdateWithWhereUniqueWithoutInsurersInput[]
    updateMany?: illnesssurgeryUpdateManyWithWhereWithoutInsurersInput | illnesssurgeryUpdateManyWithWhereWithoutInsurersInput[]
    deleteMany?: illnesssurgeryScalarWhereInput | illnesssurgeryScalarWhereInput[]
  }

  export type illnesstypeUncheckedUpdateManyWithoutInsurersNestedInput = {
    create?: XOR<illnesstypeCreateWithoutInsurersInput, illnesstypeUncheckedCreateWithoutInsurersInput> | illnesstypeCreateWithoutInsurersInput[] | illnesstypeUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: illnesstypeCreateOrConnectWithoutInsurersInput | illnesstypeCreateOrConnectWithoutInsurersInput[]
    upsert?: illnesstypeUpsertWithWhereUniqueWithoutInsurersInput | illnesstypeUpsertWithWhereUniqueWithoutInsurersInput[]
    createMany?: illnesstypeCreateManyInsurersInputEnvelope
    set?: illnesstypeWhereUniqueInput | illnesstypeWhereUniqueInput[]
    disconnect?: illnesstypeWhereUniqueInput | illnesstypeWhereUniqueInput[]
    delete?: illnesstypeWhereUniqueInput | illnesstypeWhereUniqueInput[]
    connect?: illnesstypeWhereUniqueInput | illnesstypeWhereUniqueInput[]
    update?: illnesstypeUpdateWithWhereUniqueWithoutInsurersInput | illnesstypeUpdateWithWhereUniqueWithoutInsurersInput[]
    updateMany?: illnesstypeUpdateManyWithWhereWithoutInsurersInput | illnesstypeUpdateManyWithWhereWithoutInsurersInput[]
    deleteMany?: illnesstypeScalarWhereInput | illnesstypeScalarWhereInput[]
  }

  export type policytypeUncheckedUpdateManyWithoutInsurersNestedInput = {
    create?: XOR<policytypeCreateWithoutInsurersInput, policytypeUncheckedCreateWithoutInsurersInput> | policytypeCreateWithoutInsurersInput[] | policytypeUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: policytypeCreateOrConnectWithoutInsurersInput | policytypeCreateOrConnectWithoutInsurersInput[]
    upsert?: policytypeUpsertWithWhereUniqueWithoutInsurersInput | policytypeUpsertWithWhereUniqueWithoutInsurersInput[]
    createMany?: policytypeCreateManyInsurersInputEnvelope
    set?: policytypeWhereUniqueInput | policytypeWhereUniqueInput[]
    disconnect?: policytypeWhereUniqueInput | policytypeWhereUniqueInput[]
    delete?: policytypeWhereUniqueInput | policytypeWhereUniqueInput[]
    connect?: policytypeWhereUniqueInput | policytypeWhereUniqueInput[]
    update?: policytypeUpdateWithWhereUniqueWithoutInsurersInput | policytypeUpdateWithWhereUniqueWithoutInsurersInput[]
    updateMany?: policytypeUpdateManyWithWhereWithoutInsurersInput | policytypeUpdateManyWithWhereWithoutInsurersInput[]
    deleteMany?: policytypeScalarWhereInput | policytypeScalarWhereInput[]
  }

  export type proceduretransactionsUncheckedUpdateManyWithoutInsurersNestedInput = {
    create?: XOR<proceduretransactionsCreateWithoutInsurersInput, proceduretransactionsUncheckedCreateWithoutInsurersInput> | proceduretransactionsCreateWithoutInsurersInput[] | proceduretransactionsUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: proceduretransactionsCreateOrConnectWithoutInsurersInput | proceduretransactionsCreateOrConnectWithoutInsurersInput[]
    upsert?: proceduretransactionsUpsertWithWhereUniqueWithoutInsurersInput | proceduretransactionsUpsertWithWhereUniqueWithoutInsurersInput[]
    createMany?: proceduretransactionsCreateManyInsurersInputEnvelope
    set?: proceduretransactionsWhereUniqueInput | proceduretransactionsWhereUniqueInput[]
    disconnect?: proceduretransactionsWhereUniqueInput | proceduretransactionsWhereUniqueInput[]
    delete?: proceduretransactionsWhereUniqueInput | proceduretransactionsWhereUniqueInput[]
    connect?: proceduretransactionsWhereUniqueInput | proceduretransactionsWhereUniqueInput[]
    update?: proceduretransactionsUpdateWithWhereUniqueWithoutInsurersInput | proceduretransactionsUpdateWithWhereUniqueWithoutInsurersInput[]
    updateMany?: proceduretransactionsUpdateManyWithWhereWithoutInsurersInput | proceduretransactionsUpdateManyWithWhereWithoutInsurersInput[]
    deleteMany?: proceduretransactionsScalarWhereInput | proceduretransactionsScalarWhereInput[]
  }

  export type servicesettingUncheckedUpdateManyWithoutInsurersNestedInput = {
    create?: XOR<servicesettingCreateWithoutInsurersInput, servicesettingUncheckedCreateWithoutInsurersInput> | servicesettingCreateWithoutInsurersInput[] | servicesettingUncheckedCreateWithoutInsurersInput[]
    connectOrCreate?: servicesettingCreateOrConnectWithoutInsurersInput | servicesettingCreateOrConnectWithoutInsurersInput[]
    upsert?: servicesettingUpsertWithWhereUniqueWithoutInsurersInput | servicesettingUpsertWithWhereUniqueWithoutInsurersInput[]
    createMany?: servicesettingCreateManyInsurersInputEnvelope
    set?: servicesettingWhereUniqueInput | servicesettingWhereUniqueInput[]
    disconnect?: servicesettingWhereUniqueInput | servicesettingWhereUniqueInput[]
    delete?: servicesettingWhereUniqueInput | servicesettingWhereUniqueInput[]
    connect?: servicesettingWhereUniqueInput | servicesettingWhereUniqueInput[]
    update?: servicesettingUpdateWithWhereUniqueWithoutInsurersInput | servicesettingUpdateWithWhereUniqueWithoutInsurersInput[]
    updateMany?: servicesettingUpdateManyWithWhereWithoutInsurersInput | servicesettingUpdateManyWithWhereWithoutInsurersInput[]
    deleteMany?: servicesettingScalarWhereInput | servicesettingScalarWhereInput[]
  }

  export type insurersCreateNestedOneWithoutPolicytypeInput = {
    create?: XOR<insurersCreateWithoutPolicytypeInput, insurersUncheckedCreateWithoutPolicytypeInput>
    connectOrCreate?: insurersCreateOrConnectWithoutPolicytypeInput
    connect?: insurersWhereUniqueInput
  }

  export type insurersUpdateOneWithoutPolicytypeNestedInput = {
    create?: XOR<insurersCreateWithoutPolicytypeInput, insurersUncheckedCreateWithoutPolicytypeInput>
    connectOrCreate?: insurersCreateOrConnectWithoutPolicytypeInput
    upsert?: insurersUpsertWithoutPolicytypeInput
    disconnect?: insurersWhereInput | boolean
    delete?: insurersWhereInput | boolean
    connect?: insurersWhereUniqueInput
    update?: XOR<XOR<insurersUpdateToOneWithWhereWithoutPolicytypeInput, insurersUpdateWithoutPolicytypeInput>, insurersUncheckedUpdateWithoutPolicytypeInput>
  }

  export type insurersCreateNestedOneWithoutServicesettingInput = {
    create?: XOR<insurersCreateWithoutServicesettingInput, insurersUncheckedCreateWithoutServicesettingInput>
    connectOrCreate?: insurersCreateOrConnectWithoutServicesettingInput
    connect?: insurersWhereUniqueInput
  }

  export type insurersUpdateOneWithoutServicesettingNestedInput = {
    create?: XOR<insurersCreateWithoutServicesettingInput, insurersUncheckedCreateWithoutServicesettingInput>
    connectOrCreate?: insurersCreateOrConnectWithoutServicesettingInput
    upsert?: insurersUpsertWithoutServicesettingInput
    disconnect?: insurersWhereInput | boolean
    delete?: insurersWhereInput | boolean
    connect?: insurersWhereUniqueInput
    update?: XOR<XOR<insurersUpdateToOneWithWhereWithoutServicesettingInput, insurersUpdateWithoutServicesettingInput>, insurersUncheckedUpdateWithoutServicesettingInput>
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type claimstatusCreateNestedOneWithoutTransactionclaimstatusInput = {
    create?: XOR<claimstatusCreateWithoutTransactionclaimstatusInput, claimstatusUncheckedCreateWithoutTransactionclaimstatusInput>
    connectOrCreate?: claimstatusCreateOrConnectWithoutTransactionclaimstatusInput
    connect?: claimstatusWhereUniqueInput
  }

  export type claimstatusUpdateOneWithoutTransactionclaimstatusNestedInput = {
    create?: XOR<claimstatusCreateWithoutTransactionclaimstatusInput, claimstatusUncheckedCreateWithoutTransactionclaimstatusInput>
    connectOrCreate?: claimstatusCreateOrConnectWithoutTransactionclaimstatusInput
    upsert?: claimstatusUpsertWithoutTransactionclaimstatusInput
    disconnect?: claimstatusWhereInput | boolean
    delete?: claimstatusWhereInput | boolean
    connect?: claimstatusWhereUniqueInput
    update?: XOR<XOR<claimstatusUpdateToOneWithWhereWithoutTransactionclaimstatusInput, claimstatusUpdateWithoutTransactionclaimstatusInput>, claimstatusUncheckedUpdateWithoutTransactionclaimstatusInput>
  }

  export type insurersCreateNestedOneWithoutAccidenttransactionsInput = {
    create?: XOR<insurersCreateWithoutAccidenttransactionsInput, insurersUncheckedCreateWithoutAccidenttransactionsInput>
    connectOrCreate?: insurersCreateOrConnectWithoutAccidenttransactionsInput
    connect?: insurersWhereUniqueInput
  }

  export type causeofinjurydetailCreateNestedManyWithoutAccidenttransactionsInput = {
    create?: XOR<causeofinjurydetailCreateWithoutAccidenttransactionsInput, causeofinjurydetailUncheckedCreateWithoutAccidenttransactionsInput> | causeofinjurydetailCreateWithoutAccidenttransactionsInput[] | causeofinjurydetailUncheckedCreateWithoutAccidenttransactionsInput[]
    connectOrCreate?: causeofinjurydetailCreateOrConnectWithoutAccidenttransactionsInput | causeofinjurydetailCreateOrConnectWithoutAccidenttransactionsInput[]
    createMany?: causeofinjurydetailCreateManyAccidenttransactionsInputEnvelope
    connect?: causeofinjurydetailWhereUniqueInput | causeofinjurydetailWhereUniqueInput[]
  }

  export type injurydetailCreateNestedManyWithoutAccidenttransactionsInput = {
    create?: XOR<injurydetailCreateWithoutAccidenttransactionsInput, injurydetailUncheckedCreateWithoutAccidenttransactionsInput> | injurydetailCreateWithoutAccidenttransactionsInput[] | injurydetailUncheckedCreateWithoutAccidenttransactionsInput[]
    connectOrCreate?: injurydetailCreateOrConnectWithoutAccidenttransactionsInput | injurydetailCreateOrConnectWithoutAccidenttransactionsInput[]
    createMany?: injurydetailCreateManyAccidenttransactionsInputEnvelope
    connect?: injurydetailWhereUniqueInput | injurydetailWhereUniqueInput[]
  }

  export type causeofinjurydetailUncheckedCreateNestedManyWithoutAccidenttransactionsInput = {
    create?: XOR<causeofinjurydetailCreateWithoutAccidenttransactionsInput, causeofinjurydetailUncheckedCreateWithoutAccidenttransactionsInput> | causeofinjurydetailCreateWithoutAccidenttransactionsInput[] | causeofinjurydetailUncheckedCreateWithoutAccidenttransactionsInput[]
    connectOrCreate?: causeofinjurydetailCreateOrConnectWithoutAccidenttransactionsInput | causeofinjurydetailCreateOrConnectWithoutAccidenttransactionsInput[]
    createMany?: causeofinjurydetailCreateManyAccidenttransactionsInputEnvelope
    connect?: causeofinjurydetailWhereUniqueInput | causeofinjurydetailWhereUniqueInput[]
  }

  export type injurydetailUncheckedCreateNestedManyWithoutAccidenttransactionsInput = {
    create?: XOR<injurydetailCreateWithoutAccidenttransactionsInput, injurydetailUncheckedCreateWithoutAccidenttransactionsInput> | injurydetailCreateWithoutAccidenttransactionsInput[] | injurydetailUncheckedCreateWithoutAccidenttransactionsInput[]
    connectOrCreate?: injurydetailCreateOrConnectWithoutAccidenttransactionsInput | injurydetailCreateOrConnectWithoutAccidenttransactionsInput[]
    createMany?: injurydetailCreateManyAccidenttransactionsInputEnvelope
    connect?: injurydetailWhereUniqueInput | injurydetailWhereUniqueInput[]
  }

  export type insurersUpdateOneWithoutAccidenttransactionsNestedInput = {
    create?: XOR<insurersCreateWithoutAccidenttransactionsInput, insurersUncheckedCreateWithoutAccidenttransactionsInput>
    connectOrCreate?: insurersCreateOrConnectWithoutAccidenttransactionsInput
    upsert?: insurersUpsertWithoutAccidenttransactionsInput
    disconnect?: insurersWhereInput | boolean
    delete?: insurersWhereInput | boolean
    connect?: insurersWhereUniqueInput
    update?: XOR<XOR<insurersUpdateToOneWithWhereWithoutAccidenttransactionsInput, insurersUpdateWithoutAccidenttransactionsInput>, insurersUncheckedUpdateWithoutAccidenttransactionsInput>
  }

  export type causeofinjurydetailUpdateManyWithoutAccidenttransactionsNestedInput = {
    create?: XOR<causeofinjurydetailCreateWithoutAccidenttransactionsInput, causeofinjurydetailUncheckedCreateWithoutAccidenttransactionsInput> | causeofinjurydetailCreateWithoutAccidenttransactionsInput[] | causeofinjurydetailUncheckedCreateWithoutAccidenttransactionsInput[]
    connectOrCreate?: causeofinjurydetailCreateOrConnectWithoutAccidenttransactionsInput | causeofinjurydetailCreateOrConnectWithoutAccidenttransactionsInput[]
    upsert?: causeofinjurydetailUpsertWithWhereUniqueWithoutAccidenttransactionsInput | causeofinjurydetailUpsertWithWhereUniqueWithoutAccidenttransactionsInput[]
    createMany?: causeofinjurydetailCreateManyAccidenttransactionsInputEnvelope
    set?: causeofinjurydetailWhereUniqueInput | causeofinjurydetailWhereUniqueInput[]
    disconnect?: causeofinjurydetailWhereUniqueInput | causeofinjurydetailWhereUniqueInput[]
    delete?: causeofinjurydetailWhereUniqueInput | causeofinjurydetailWhereUniqueInput[]
    connect?: causeofinjurydetailWhereUniqueInput | causeofinjurydetailWhereUniqueInput[]
    update?: causeofinjurydetailUpdateWithWhereUniqueWithoutAccidenttransactionsInput | causeofinjurydetailUpdateWithWhereUniqueWithoutAccidenttransactionsInput[]
    updateMany?: causeofinjurydetailUpdateManyWithWhereWithoutAccidenttransactionsInput | causeofinjurydetailUpdateManyWithWhereWithoutAccidenttransactionsInput[]
    deleteMany?: causeofinjurydetailScalarWhereInput | causeofinjurydetailScalarWhereInput[]
  }

  export type injurydetailUpdateManyWithoutAccidenttransactionsNestedInput = {
    create?: XOR<injurydetailCreateWithoutAccidenttransactionsInput, injurydetailUncheckedCreateWithoutAccidenttransactionsInput> | injurydetailCreateWithoutAccidenttransactionsInput[] | injurydetailUncheckedCreateWithoutAccidenttransactionsInput[]
    connectOrCreate?: injurydetailCreateOrConnectWithoutAccidenttransactionsInput | injurydetailCreateOrConnectWithoutAccidenttransactionsInput[]
    upsert?: injurydetailUpsertWithWhereUniqueWithoutAccidenttransactionsInput | injurydetailUpsertWithWhereUniqueWithoutAccidenttransactionsInput[]
    createMany?: injurydetailCreateManyAccidenttransactionsInputEnvelope
    set?: injurydetailWhereUniqueInput | injurydetailWhereUniqueInput[]
    disconnect?: injurydetailWhereUniqueInput | injurydetailWhereUniqueInput[]
    delete?: injurydetailWhereUniqueInput | injurydetailWhereUniqueInput[]
    connect?: injurydetailWhereUniqueInput | injurydetailWhereUniqueInput[]
    update?: injurydetailUpdateWithWhereUniqueWithoutAccidenttransactionsInput | injurydetailUpdateWithWhereUniqueWithoutAccidenttransactionsInput[]
    updateMany?: injurydetailUpdateManyWithWhereWithoutAccidenttransactionsInput | injurydetailUpdateManyWithWhereWithoutAccidenttransactionsInput[]
    deleteMany?: injurydetailScalarWhereInput | injurydetailScalarWhereInput[]
  }

  export type causeofinjurydetailUncheckedUpdateManyWithoutAccidenttransactionsNestedInput = {
    create?: XOR<causeofinjurydetailCreateWithoutAccidenttransactionsInput, causeofinjurydetailUncheckedCreateWithoutAccidenttransactionsInput> | causeofinjurydetailCreateWithoutAccidenttransactionsInput[] | causeofinjurydetailUncheckedCreateWithoutAccidenttransactionsInput[]
    connectOrCreate?: causeofinjurydetailCreateOrConnectWithoutAccidenttransactionsInput | causeofinjurydetailCreateOrConnectWithoutAccidenttransactionsInput[]
    upsert?: causeofinjurydetailUpsertWithWhereUniqueWithoutAccidenttransactionsInput | causeofinjurydetailUpsertWithWhereUniqueWithoutAccidenttransactionsInput[]
    createMany?: causeofinjurydetailCreateManyAccidenttransactionsInputEnvelope
    set?: causeofinjurydetailWhereUniqueInput | causeofinjurydetailWhereUniqueInput[]
    disconnect?: causeofinjurydetailWhereUniqueInput | causeofinjurydetailWhereUniqueInput[]
    delete?: causeofinjurydetailWhereUniqueInput | causeofinjurydetailWhereUniqueInput[]
    connect?: causeofinjurydetailWhereUniqueInput | causeofinjurydetailWhereUniqueInput[]
    update?: causeofinjurydetailUpdateWithWhereUniqueWithoutAccidenttransactionsInput | causeofinjurydetailUpdateWithWhereUniqueWithoutAccidenttransactionsInput[]
    updateMany?: causeofinjurydetailUpdateManyWithWhereWithoutAccidenttransactionsInput | causeofinjurydetailUpdateManyWithWhereWithoutAccidenttransactionsInput[]
    deleteMany?: causeofinjurydetailScalarWhereInput | causeofinjurydetailScalarWhereInput[]
  }

  export type injurydetailUncheckedUpdateManyWithoutAccidenttransactionsNestedInput = {
    create?: XOR<injurydetailCreateWithoutAccidenttransactionsInput, injurydetailUncheckedCreateWithoutAccidenttransactionsInput> | injurydetailCreateWithoutAccidenttransactionsInput[] | injurydetailUncheckedCreateWithoutAccidenttransactionsInput[]
    connectOrCreate?: injurydetailCreateOrConnectWithoutAccidenttransactionsInput | injurydetailCreateOrConnectWithoutAccidenttransactionsInput[]
    upsert?: injurydetailUpsertWithWhereUniqueWithoutAccidenttransactionsInput | injurydetailUpsertWithWhereUniqueWithoutAccidenttransactionsInput[]
    createMany?: injurydetailCreateManyAccidenttransactionsInputEnvelope
    set?: injurydetailWhereUniqueInput | injurydetailWhereUniqueInput[]
    disconnect?: injurydetailWhereUniqueInput | injurydetailWhereUniqueInput[]
    delete?: injurydetailWhereUniqueInput | injurydetailWhereUniqueInput[]
    connect?: injurydetailWhereUniqueInput | injurydetailWhereUniqueInput[]
    update?: injurydetailUpdateWithWhereUniqueWithoutAccidenttransactionsInput | injurydetailUpdateWithWhereUniqueWithoutAccidenttransactionsInput[]
    updateMany?: injurydetailUpdateManyWithWhereWithoutAccidenttransactionsInput | injurydetailUpdateManyWithWhereWithoutAccidenttransactionsInput[]
    deleteMany?: injurydetailScalarWhereInput | injurydetailScalarWhereInput[]
  }

  export type insurersCreateNestedOneWithoutProceduretransactionsInput = {
    create?: XOR<insurersCreateWithoutProceduretransactionsInput, insurersUncheckedCreateWithoutProceduretransactionsInput>
    connectOrCreate?: insurersCreateOrConnectWithoutProceduretransactionsInput
    connect?: insurersWhereUniqueInput
  }

  export type insurersUpdateOneWithoutProceduretransactionsNestedInput = {
    create?: XOR<insurersCreateWithoutProceduretransactionsInput, insurersUncheckedCreateWithoutProceduretransactionsInput>
    connectOrCreate?: insurersCreateOrConnectWithoutProceduretransactionsInput
    upsert?: insurersUpsertWithoutProceduretransactionsInput
    disconnect?: insurersWhereInput | boolean
    delete?: insurersWhereInput | boolean
    connect?: insurersWhereUniqueInput
    update?: XOR<XOR<insurersUpdateToOneWithWhereWithoutProceduretransactionsInput, insurersUpdateWithoutProceduretransactionsInput>, insurersUncheckedUpdateWithoutProceduretransactionsInput>
  }

  export type insurersCreateNestedOneWithoutAccidenttransactions22Input = {
    create?: XOR<insurersCreateWithoutAccidenttransactions22Input, insurersUncheckedCreateWithoutAccidenttransactions22Input>
    connectOrCreate?: insurersCreateOrConnectWithoutAccidenttransactions22Input
    connect?: insurersWhereUniqueInput
  }

  export type insurersUpdateOneWithoutAccidenttransactions22NestedInput = {
    create?: XOR<insurersCreateWithoutAccidenttransactions22Input, insurersUncheckedCreateWithoutAccidenttransactions22Input>
    connectOrCreate?: insurersCreateOrConnectWithoutAccidenttransactions22Input
    upsert?: insurersUpsertWithoutAccidenttransactions22Input
    disconnect?: insurersWhereInput | boolean
    delete?: insurersWhereInput | boolean
    connect?: insurersWhereUniqueInput
    update?: XOR<XOR<insurersUpdateToOneWithWhereWithoutAccidenttransactions22Input, insurersUpdateWithoutAccidenttransactions22Input>, insurersUncheckedUpdateWithoutAccidenttransactions22Input>
  }

  export type accidenttransactionsCreateNestedOneWithoutCauseofinjurydetailInput = {
    create?: XOR<accidenttransactionsCreateWithoutCauseofinjurydetailInput, accidenttransactionsUncheckedCreateWithoutCauseofinjurydetailInput>
    connectOrCreate?: accidenttransactionsCreateOrConnectWithoutCauseofinjurydetailInput
    connect?: accidenttransactionsWhereUniqueInput
  }

  export type accidenttransactionsUpdateOneWithoutCauseofinjurydetailNestedInput = {
    create?: XOR<accidenttransactionsCreateWithoutCauseofinjurydetailInput, accidenttransactionsUncheckedCreateWithoutCauseofinjurydetailInput>
    connectOrCreate?: accidenttransactionsCreateOrConnectWithoutCauseofinjurydetailInput
    upsert?: accidenttransactionsUpsertWithoutCauseofinjurydetailInput
    disconnect?: accidenttransactionsWhereInput | boolean
    delete?: accidenttransactionsWhereInput | boolean
    connect?: accidenttransactionsWhereUniqueInput
    update?: XOR<XOR<accidenttransactionsUpdateToOneWithWhereWithoutCauseofinjurydetailInput, accidenttransactionsUpdateWithoutCauseofinjurydetailInput>, accidenttransactionsUncheckedUpdateWithoutCauseofinjurydetailInput>
  }

  export type accidenttransactionsCreateNestedOneWithoutInjurydetailInput = {
    create?: XOR<accidenttransactionsCreateWithoutInjurydetailInput, accidenttransactionsUncheckedCreateWithoutInjurydetailInput>
    connectOrCreate?: accidenttransactionsCreateOrConnectWithoutInjurydetailInput
    connect?: accidenttransactionsWhereUniqueInput
  }

  export type accidenttransactionsUpdateOneWithoutInjurydetailNestedInput = {
    create?: XOR<accidenttransactionsCreateWithoutInjurydetailInput, accidenttransactionsUncheckedCreateWithoutInjurydetailInput>
    connectOrCreate?: accidenttransactionsCreateOrConnectWithoutInjurydetailInput
    upsert?: accidenttransactionsUpsertWithoutInjurydetailInput
    disconnect?: accidenttransactionsWhereInput | boolean
    delete?: accidenttransactionsWhereInput | boolean
    connect?: accidenttransactionsWhereUniqueInput
    update?: XOR<XOR<accidenttransactionsUpdateToOneWithWhereWithoutInjurydetailInput, accidenttransactionsUpdateWithoutInjurydetailInput>, accidenttransactionsUncheckedUpdateWithoutInjurydetailInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type insurersCreateWithoutAccidentcauseover45daysInput = {
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentplace?: accidentplaceCreateNestedManyWithoutInsurersInput
    accidenttransactions?: accidenttransactionsCreateNestedManyWithoutInsurersInput
    accidenttransactions22?: accidenttransactions22CreateNestedManyWithoutInsurersInput
    causeofinjuryside?: causeofinjurysideCreateNestedManyWithoutInsurersInput
    causeofinjurywoundtype?: causeofinjurywoundtypeCreateNestedManyWithoutInsurersInput
    claimants?: claimantsCreateNestedManyWithoutInsurersInput
    claimdocuments?: claimdocumentsCreateNestedManyWithoutInsurersInput
    claimstatus?: claimstatusCreateNestedManyWithoutInsurersInput
    diagnosistypemapping?: diagnosistypemappingCreateNestedManyWithoutInsurersInput
    documenttype?: documenttypeCreateNestedManyWithoutInsurersInput
    illnesssurgery?: illnesssurgeryCreateNestedManyWithoutInsurersInput
    illnesstype?: illnesstypeCreateNestedManyWithoutInsurersInput
    policytype?: policytypeCreateNestedManyWithoutInsurersInput
    proceduretransactions?: proceduretransactionsCreateNestedManyWithoutInsurersInput
    servicesetting?: servicesettingCreateNestedManyWithoutInsurersInput
  }

  export type insurersUncheckedCreateWithoutAccidentcauseover45daysInput = {
    id?: number
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentplace?: accidentplaceUncheckedCreateNestedManyWithoutInsurersInput
    accidenttransactions?: accidenttransactionsUncheckedCreateNestedManyWithoutInsurersInput
    accidenttransactions22?: accidenttransactions22UncheckedCreateNestedManyWithoutInsurersInput
    causeofinjuryside?: causeofinjurysideUncheckedCreateNestedManyWithoutInsurersInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUncheckedCreateNestedManyWithoutInsurersInput
    claimants?: claimantsUncheckedCreateNestedManyWithoutInsurersInput
    claimdocuments?: claimdocumentsUncheckedCreateNestedManyWithoutInsurersInput
    claimstatus?: claimstatusUncheckedCreateNestedManyWithoutInsurersInput
    diagnosistypemapping?: diagnosistypemappingUncheckedCreateNestedManyWithoutInsurersInput
    documenttype?: documenttypeUncheckedCreateNestedManyWithoutInsurersInput
    illnesssurgery?: illnesssurgeryUncheckedCreateNestedManyWithoutInsurersInput
    illnesstype?: illnesstypeUncheckedCreateNestedManyWithoutInsurersInput
    policytype?: policytypeUncheckedCreateNestedManyWithoutInsurersInput
    proceduretransactions?: proceduretransactionsUncheckedCreateNestedManyWithoutInsurersInput
    servicesetting?: servicesettingUncheckedCreateNestedManyWithoutInsurersInput
  }

  export type insurersCreateOrConnectWithoutAccidentcauseover45daysInput = {
    where: insurersWhereUniqueInput
    create: XOR<insurersCreateWithoutAccidentcauseover45daysInput, insurersUncheckedCreateWithoutAccidentcauseover45daysInput>
  }

  export type insurersUpsertWithoutAccidentcauseover45daysInput = {
    update: XOR<insurersUpdateWithoutAccidentcauseover45daysInput, insurersUncheckedUpdateWithoutAccidentcauseover45daysInput>
    create: XOR<insurersCreateWithoutAccidentcauseover45daysInput, insurersUncheckedCreateWithoutAccidentcauseover45daysInput>
    where?: insurersWhereInput
  }

  export type insurersUpdateToOneWithWhereWithoutAccidentcauseover45daysInput = {
    where?: insurersWhereInput
    data: XOR<insurersUpdateWithoutAccidentcauseover45daysInput, insurersUncheckedUpdateWithoutAccidentcauseover45daysInput>
  }

  export type insurersUpdateWithoutAccidentcauseover45daysInput = {
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentplace?: accidentplaceUpdateManyWithoutInsurersNestedInput
    accidenttransactions?: accidenttransactionsUpdateManyWithoutInsurersNestedInput
    accidenttransactions22?: accidenttransactions22UpdateManyWithoutInsurersNestedInput
    causeofinjuryside?: causeofinjurysideUpdateManyWithoutInsurersNestedInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUpdateManyWithoutInsurersNestedInput
    claimants?: claimantsUpdateManyWithoutInsurersNestedInput
    claimdocuments?: claimdocumentsUpdateManyWithoutInsurersNestedInput
    claimstatus?: claimstatusUpdateManyWithoutInsurersNestedInput
    diagnosistypemapping?: diagnosistypemappingUpdateManyWithoutInsurersNestedInput
    documenttype?: documenttypeUpdateManyWithoutInsurersNestedInput
    illnesssurgery?: illnesssurgeryUpdateManyWithoutInsurersNestedInput
    illnesstype?: illnesstypeUpdateManyWithoutInsurersNestedInput
    policytype?: policytypeUpdateManyWithoutInsurersNestedInput
    proceduretransactions?: proceduretransactionsUpdateManyWithoutInsurersNestedInput
    servicesetting?: servicesettingUpdateManyWithoutInsurersNestedInput
  }

  export type insurersUncheckedUpdateWithoutAccidentcauseover45daysInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentplace?: accidentplaceUncheckedUpdateManyWithoutInsurersNestedInput
    accidenttransactions?: accidenttransactionsUncheckedUpdateManyWithoutInsurersNestedInput
    accidenttransactions22?: accidenttransactions22UncheckedUpdateManyWithoutInsurersNestedInput
    causeofinjuryside?: causeofinjurysideUncheckedUpdateManyWithoutInsurersNestedInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUncheckedUpdateManyWithoutInsurersNestedInput
    claimants?: claimantsUncheckedUpdateManyWithoutInsurersNestedInput
    claimdocuments?: claimdocumentsUncheckedUpdateManyWithoutInsurersNestedInput
    claimstatus?: claimstatusUncheckedUpdateManyWithoutInsurersNestedInput
    diagnosistypemapping?: diagnosistypemappingUncheckedUpdateManyWithoutInsurersNestedInput
    documenttype?: documenttypeUncheckedUpdateManyWithoutInsurersNestedInput
    illnesssurgery?: illnesssurgeryUncheckedUpdateManyWithoutInsurersNestedInput
    illnesstype?: illnesstypeUncheckedUpdateManyWithoutInsurersNestedInput
    policytype?: policytypeUncheckedUpdateManyWithoutInsurersNestedInput
    proceduretransactions?: proceduretransactionsUncheckedUpdateManyWithoutInsurersNestedInput
    servicesetting?: servicesettingUncheckedUpdateManyWithoutInsurersNestedInput
  }

  export type insurersCreateWithoutAccidentplaceInput = {
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentcauseover45days?: accidentcauseover45daysCreateNestedManyWithoutInsurersInput
    accidenttransactions?: accidenttransactionsCreateNestedManyWithoutInsurersInput
    accidenttransactions22?: accidenttransactions22CreateNestedManyWithoutInsurersInput
    causeofinjuryside?: causeofinjurysideCreateNestedManyWithoutInsurersInput
    causeofinjurywoundtype?: causeofinjurywoundtypeCreateNestedManyWithoutInsurersInput
    claimants?: claimantsCreateNestedManyWithoutInsurersInput
    claimdocuments?: claimdocumentsCreateNestedManyWithoutInsurersInput
    claimstatus?: claimstatusCreateNestedManyWithoutInsurersInput
    diagnosistypemapping?: diagnosistypemappingCreateNestedManyWithoutInsurersInput
    documenttype?: documenttypeCreateNestedManyWithoutInsurersInput
    illnesssurgery?: illnesssurgeryCreateNestedManyWithoutInsurersInput
    illnesstype?: illnesstypeCreateNestedManyWithoutInsurersInput
    policytype?: policytypeCreateNestedManyWithoutInsurersInput
    proceduretransactions?: proceduretransactionsCreateNestedManyWithoutInsurersInput
    servicesetting?: servicesettingCreateNestedManyWithoutInsurersInput
  }

  export type insurersUncheckedCreateWithoutAccidentplaceInput = {
    id?: number
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentcauseover45days?: accidentcauseover45daysUncheckedCreateNestedManyWithoutInsurersInput
    accidenttransactions?: accidenttransactionsUncheckedCreateNestedManyWithoutInsurersInput
    accidenttransactions22?: accidenttransactions22UncheckedCreateNestedManyWithoutInsurersInput
    causeofinjuryside?: causeofinjurysideUncheckedCreateNestedManyWithoutInsurersInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUncheckedCreateNestedManyWithoutInsurersInput
    claimants?: claimantsUncheckedCreateNestedManyWithoutInsurersInput
    claimdocuments?: claimdocumentsUncheckedCreateNestedManyWithoutInsurersInput
    claimstatus?: claimstatusUncheckedCreateNestedManyWithoutInsurersInput
    diagnosistypemapping?: diagnosistypemappingUncheckedCreateNestedManyWithoutInsurersInput
    documenttype?: documenttypeUncheckedCreateNestedManyWithoutInsurersInput
    illnesssurgery?: illnesssurgeryUncheckedCreateNestedManyWithoutInsurersInput
    illnesstype?: illnesstypeUncheckedCreateNestedManyWithoutInsurersInput
    policytype?: policytypeUncheckedCreateNestedManyWithoutInsurersInput
    proceduretransactions?: proceduretransactionsUncheckedCreateNestedManyWithoutInsurersInput
    servicesetting?: servicesettingUncheckedCreateNestedManyWithoutInsurersInput
  }

  export type insurersCreateOrConnectWithoutAccidentplaceInput = {
    where: insurersWhereUniqueInput
    create: XOR<insurersCreateWithoutAccidentplaceInput, insurersUncheckedCreateWithoutAccidentplaceInput>
  }

  export type insurersUpsertWithoutAccidentplaceInput = {
    update: XOR<insurersUpdateWithoutAccidentplaceInput, insurersUncheckedUpdateWithoutAccidentplaceInput>
    create: XOR<insurersCreateWithoutAccidentplaceInput, insurersUncheckedCreateWithoutAccidentplaceInput>
    where?: insurersWhereInput
  }

  export type insurersUpdateToOneWithWhereWithoutAccidentplaceInput = {
    where?: insurersWhereInput
    data: XOR<insurersUpdateWithoutAccidentplaceInput, insurersUncheckedUpdateWithoutAccidentplaceInput>
  }

  export type insurersUpdateWithoutAccidentplaceInput = {
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: accidentcauseover45daysUpdateManyWithoutInsurersNestedInput
    accidenttransactions?: accidenttransactionsUpdateManyWithoutInsurersNestedInput
    accidenttransactions22?: accidenttransactions22UpdateManyWithoutInsurersNestedInput
    causeofinjuryside?: causeofinjurysideUpdateManyWithoutInsurersNestedInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUpdateManyWithoutInsurersNestedInput
    claimants?: claimantsUpdateManyWithoutInsurersNestedInput
    claimdocuments?: claimdocumentsUpdateManyWithoutInsurersNestedInput
    claimstatus?: claimstatusUpdateManyWithoutInsurersNestedInput
    diagnosistypemapping?: diagnosistypemappingUpdateManyWithoutInsurersNestedInput
    documenttype?: documenttypeUpdateManyWithoutInsurersNestedInput
    illnesssurgery?: illnesssurgeryUpdateManyWithoutInsurersNestedInput
    illnesstype?: illnesstypeUpdateManyWithoutInsurersNestedInput
    policytype?: policytypeUpdateManyWithoutInsurersNestedInput
    proceduretransactions?: proceduretransactionsUpdateManyWithoutInsurersNestedInput
    servicesetting?: servicesettingUpdateManyWithoutInsurersNestedInput
  }

  export type insurersUncheckedUpdateWithoutAccidentplaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: accidentcauseover45daysUncheckedUpdateManyWithoutInsurersNestedInput
    accidenttransactions?: accidenttransactionsUncheckedUpdateManyWithoutInsurersNestedInput
    accidenttransactions22?: accidenttransactions22UncheckedUpdateManyWithoutInsurersNestedInput
    causeofinjuryside?: causeofinjurysideUncheckedUpdateManyWithoutInsurersNestedInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUncheckedUpdateManyWithoutInsurersNestedInput
    claimants?: claimantsUncheckedUpdateManyWithoutInsurersNestedInput
    claimdocuments?: claimdocumentsUncheckedUpdateManyWithoutInsurersNestedInput
    claimstatus?: claimstatusUncheckedUpdateManyWithoutInsurersNestedInput
    diagnosistypemapping?: diagnosistypemappingUncheckedUpdateManyWithoutInsurersNestedInput
    documenttype?: documenttypeUncheckedUpdateManyWithoutInsurersNestedInput
    illnesssurgery?: illnesssurgeryUncheckedUpdateManyWithoutInsurersNestedInput
    illnesstype?: illnesstypeUncheckedUpdateManyWithoutInsurersNestedInput
    policytype?: policytypeUncheckedUpdateManyWithoutInsurersNestedInput
    proceduretransactions?: proceduretransactionsUncheckedUpdateManyWithoutInsurersNestedInput
    servicesetting?: servicesettingUncheckedUpdateManyWithoutInsurersNestedInput
  }

  export type insurersCreateWithoutCauseofinjurysideInput = {
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentcauseover45days?: accidentcauseover45daysCreateNestedManyWithoutInsurersInput
    accidentplace?: accidentplaceCreateNestedManyWithoutInsurersInput
    accidenttransactions?: accidenttransactionsCreateNestedManyWithoutInsurersInput
    accidenttransactions22?: accidenttransactions22CreateNestedManyWithoutInsurersInput
    causeofinjurywoundtype?: causeofinjurywoundtypeCreateNestedManyWithoutInsurersInput
    claimants?: claimantsCreateNestedManyWithoutInsurersInput
    claimdocuments?: claimdocumentsCreateNestedManyWithoutInsurersInput
    claimstatus?: claimstatusCreateNestedManyWithoutInsurersInput
    diagnosistypemapping?: diagnosistypemappingCreateNestedManyWithoutInsurersInput
    documenttype?: documenttypeCreateNestedManyWithoutInsurersInput
    illnesssurgery?: illnesssurgeryCreateNestedManyWithoutInsurersInput
    illnesstype?: illnesstypeCreateNestedManyWithoutInsurersInput
    policytype?: policytypeCreateNestedManyWithoutInsurersInput
    proceduretransactions?: proceduretransactionsCreateNestedManyWithoutInsurersInput
    servicesetting?: servicesettingCreateNestedManyWithoutInsurersInput
  }

  export type insurersUncheckedCreateWithoutCauseofinjurysideInput = {
    id?: number
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentcauseover45days?: accidentcauseover45daysUncheckedCreateNestedManyWithoutInsurersInput
    accidentplace?: accidentplaceUncheckedCreateNestedManyWithoutInsurersInput
    accidenttransactions?: accidenttransactionsUncheckedCreateNestedManyWithoutInsurersInput
    accidenttransactions22?: accidenttransactions22UncheckedCreateNestedManyWithoutInsurersInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUncheckedCreateNestedManyWithoutInsurersInput
    claimants?: claimantsUncheckedCreateNestedManyWithoutInsurersInput
    claimdocuments?: claimdocumentsUncheckedCreateNestedManyWithoutInsurersInput
    claimstatus?: claimstatusUncheckedCreateNestedManyWithoutInsurersInput
    diagnosistypemapping?: diagnosistypemappingUncheckedCreateNestedManyWithoutInsurersInput
    documenttype?: documenttypeUncheckedCreateNestedManyWithoutInsurersInput
    illnesssurgery?: illnesssurgeryUncheckedCreateNestedManyWithoutInsurersInput
    illnesstype?: illnesstypeUncheckedCreateNestedManyWithoutInsurersInput
    policytype?: policytypeUncheckedCreateNestedManyWithoutInsurersInput
    proceduretransactions?: proceduretransactionsUncheckedCreateNestedManyWithoutInsurersInput
    servicesetting?: servicesettingUncheckedCreateNestedManyWithoutInsurersInput
  }

  export type insurersCreateOrConnectWithoutCauseofinjurysideInput = {
    where: insurersWhereUniqueInput
    create: XOR<insurersCreateWithoutCauseofinjurysideInput, insurersUncheckedCreateWithoutCauseofinjurysideInput>
  }

  export type insurersUpsertWithoutCauseofinjurysideInput = {
    update: XOR<insurersUpdateWithoutCauseofinjurysideInput, insurersUncheckedUpdateWithoutCauseofinjurysideInput>
    create: XOR<insurersCreateWithoutCauseofinjurysideInput, insurersUncheckedCreateWithoutCauseofinjurysideInput>
    where?: insurersWhereInput
  }

  export type insurersUpdateToOneWithWhereWithoutCauseofinjurysideInput = {
    where?: insurersWhereInput
    data: XOR<insurersUpdateWithoutCauseofinjurysideInput, insurersUncheckedUpdateWithoutCauseofinjurysideInput>
  }

  export type insurersUpdateWithoutCauseofinjurysideInput = {
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: accidentcauseover45daysUpdateManyWithoutInsurersNestedInput
    accidentplace?: accidentplaceUpdateManyWithoutInsurersNestedInput
    accidenttransactions?: accidenttransactionsUpdateManyWithoutInsurersNestedInput
    accidenttransactions22?: accidenttransactions22UpdateManyWithoutInsurersNestedInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUpdateManyWithoutInsurersNestedInput
    claimants?: claimantsUpdateManyWithoutInsurersNestedInput
    claimdocuments?: claimdocumentsUpdateManyWithoutInsurersNestedInput
    claimstatus?: claimstatusUpdateManyWithoutInsurersNestedInput
    diagnosistypemapping?: diagnosistypemappingUpdateManyWithoutInsurersNestedInput
    documenttype?: documenttypeUpdateManyWithoutInsurersNestedInput
    illnesssurgery?: illnesssurgeryUpdateManyWithoutInsurersNestedInput
    illnesstype?: illnesstypeUpdateManyWithoutInsurersNestedInput
    policytype?: policytypeUpdateManyWithoutInsurersNestedInput
    proceduretransactions?: proceduretransactionsUpdateManyWithoutInsurersNestedInput
    servicesetting?: servicesettingUpdateManyWithoutInsurersNestedInput
  }

  export type insurersUncheckedUpdateWithoutCauseofinjurysideInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: accidentcauseover45daysUncheckedUpdateManyWithoutInsurersNestedInput
    accidentplace?: accidentplaceUncheckedUpdateManyWithoutInsurersNestedInput
    accidenttransactions?: accidenttransactionsUncheckedUpdateManyWithoutInsurersNestedInput
    accidenttransactions22?: accidenttransactions22UncheckedUpdateManyWithoutInsurersNestedInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUncheckedUpdateManyWithoutInsurersNestedInput
    claimants?: claimantsUncheckedUpdateManyWithoutInsurersNestedInput
    claimdocuments?: claimdocumentsUncheckedUpdateManyWithoutInsurersNestedInput
    claimstatus?: claimstatusUncheckedUpdateManyWithoutInsurersNestedInput
    diagnosistypemapping?: diagnosistypemappingUncheckedUpdateManyWithoutInsurersNestedInput
    documenttype?: documenttypeUncheckedUpdateManyWithoutInsurersNestedInput
    illnesssurgery?: illnesssurgeryUncheckedUpdateManyWithoutInsurersNestedInput
    illnesstype?: illnesstypeUncheckedUpdateManyWithoutInsurersNestedInput
    policytype?: policytypeUncheckedUpdateManyWithoutInsurersNestedInput
    proceduretransactions?: proceduretransactionsUncheckedUpdateManyWithoutInsurersNestedInput
    servicesetting?: servicesettingUncheckedUpdateManyWithoutInsurersNestedInput
  }

  export type insurersCreateWithoutCauseofinjurywoundtypeInput = {
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentcauseover45days?: accidentcauseover45daysCreateNestedManyWithoutInsurersInput
    accidentplace?: accidentplaceCreateNestedManyWithoutInsurersInput
    accidenttransactions?: accidenttransactionsCreateNestedManyWithoutInsurersInput
    accidenttransactions22?: accidenttransactions22CreateNestedManyWithoutInsurersInput
    causeofinjuryside?: causeofinjurysideCreateNestedManyWithoutInsurersInput
    claimants?: claimantsCreateNestedManyWithoutInsurersInput
    claimdocuments?: claimdocumentsCreateNestedManyWithoutInsurersInput
    claimstatus?: claimstatusCreateNestedManyWithoutInsurersInput
    diagnosistypemapping?: diagnosistypemappingCreateNestedManyWithoutInsurersInput
    documenttype?: documenttypeCreateNestedManyWithoutInsurersInput
    illnesssurgery?: illnesssurgeryCreateNestedManyWithoutInsurersInput
    illnesstype?: illnesstypeCreateNestedManyWithoutInsurersInput
    policytype?: policytypeCreateNestedManyWithoutInsurersInput
    proceduretransactions?: proceduretransactionsCreateNestedManyWithoutInsurersInput
    servicesetting?: servicesettingCreateNestedManyWithoutInsurersInput
  }

  export type insurersUncheckedCreateWithoutCauseofinjurywoundtypeInput = {
    id?: number
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentcauseover45days?: accidentcauseover45daysUncheckedCreateNestedManyWithoutInsurersInput
    accidentplace?: accidentplaceUncheckedCreateNestedManyWithoutInsurersInput
    accidenttransactions?: accidenttransactionsUncheckedCreateNestedManyWithoutInsurersInput
    accidenttransactions22?: accidenttransactions22UncheckedCreateNestedManyWithoutInsurersInput
    causeofinjuryside?: causeofinjurysideUncheckedCreateNestedManyWithoutInsurersInput
    claimants?: claimantsUncheckedCreateNestedManyWithoutInsurersInput
    claimdocuments?: claimdocumentsUncheckedCreateNestedManyWithoutInsurersInput
    claimstatus?: claimstatusUncheckedCreateNestedManyWithoutInsurersInput
    diagnosistypemapping?: diagnosistypemappingUncheckedCreateNestedManyWithoutInsurersInput
    documenttype?: documenttypeUncheckedCreateNestedManyWithoutInsurersInput
    illnesssurgery?: illnesssurgeryUncheckedCreateNestedManyWithoutInsurersInput
    illnesstype?: illnesstypeUncheckedCreateNestedManyWithoutInsurersInput
    policytype?: policytypeUncheckedCreateNestedManyWithoutInsurersInput
    proceduretransactions?: proceduretransactionsUncheckedCreateNestedManyWithoutInsurersInput
    servicesetting?: servicesettingUncheckedCreateNestedManyWithoutInsurersInput
  }

  export type insurersCreateOrConnectWithoutCauseofinjurywoundtypeInput = {
    where: insurersWhereUniqueInput
    create: XOR<insurersCreateWithoutCauseofinjurywoundtypeInput, insurersUncheckedCreateWithoutCauseofinjurywoundtypeInput>
  }

  export type insurersUpsertWithoutCauseofinjurywoundtypeInput = {
    update: XOR<insurersUpdateWithoutCauseofinjurywoundtypeInput, insurersUncheckedUpdateWithoutCauseofinjurywoundtypeInput>
    create: XOR<insurersCreateWithoutCauseofinjurywoundtypeInput, insurersUncheckedCreateWithoutCauseofinjurywoundtypeInput>
    where?: insurersWhereInput
  }

  export type insurersUpdateToOneWithWhereWithoutCauseofinjurywoundtypeInput = {
    where?: insurersWhereInput
    data: XOR<insurersUpdateWithoutCauseofinjurywoundtypeInput, insurersUncheckedUpdateWithoutCauseofinjurywoundtypeInput>
  }

  export type insurersUpdateWithoutCauseofinjurywoundtypeInput = {
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: accidentcauseover45daysUpdateManyWithoutInsurersNestedInput
    accidentplace?: accidentplaceUpdateManyWithoutInsurersNestedInput
    accidenttransactions?: accidenttransactionsUpdateManyWithoutInsurersNestedInput
    accidenttransactions22?: accidenttransactions22UpdateManyWithoutInsurersNestedInput
    causeofinjuryside?: causeofinjurysideUpdateManyWithoutInsurersNestedInput
    claimants?: claimantsUpdateManyWithoutInsurersNestedInput
    claimdocuments?: claimdocumentsUpdateManyWithoutInsurersNestedInput
    claimstatus?: claimstatusUpdateManyWithoutInsurersNestedInput
    diagnosistypemapping?: diagnosistypemappingUpdateManyWithoutInsurersNestedInput
    documenttype?: documenttypeUpdateManyWithoutInsurersNestedInput
    illnesssurgery?: illnesssurgeryUpdateManyWithoutInsurersNestedInput
    illnesstype?: illnesstypeUpdateManyWithoutInsurersNestedInput
    policytype?: policytypeUpdateManyWithoutInsurersNestedInput
    proceduretransactions?: proceduretransactionsUpdateManyWithoutInsurersNestedInput
    servicesetting?: servicesettingUpdateManyWithoutInsurersNestedInput
  }

  export type insurersUncheckedUpdateWithoutCauseofinjurywoundtypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: accidentcauseover45daysUncheckedUpdateManyWithoutInsurersNestedInput
    accidentplace?: accidentplaceUncheckedUpdateManyWithoutInsurersNestedInput
    accidenttransactions?: accidenttransactionsUncheckedUpdateManyWithoutInsurersNestedInput
    accidenttransactions22?: accidenttransactions22UncheckedUpdateManyWithoutInsurersNestedInput
    causeofinjuryside?: causeofinjurysideUncheckedUpdateManyWithoutInsurersNestedInput
    claimants?: claimantsUncheckedUpdateManyWithoutInsurersNestedInput
    claimdocuments?: claimdocumentsUncheckedUpdateManyWithoutInsurersNestedInput
    claimstatus?: claimstatusUncheckedUpdateManyWithoutInsurersNestedInput
    diagnosistypemapping?: diagnosistypemappingUncheckedUpdateManyWithoutInsurersNestedInput
    documenttype?: documenttypeUncheckedUpdateManyWithoutInsurersNestedInput
    illnesssurgery?: illnesssurgeryUncheckedUpdateManyWithoutInsurersNestedInput
    illnesstype?: illnesstypeUncheckedUpdateManyWithoutInsurersNestedInput
    policytype?: policytypeUncheckedUpdateManyWithoutInsurersNestedInput
    proceduretransactions?: proceduretransactionsUncheckedUpdateManyWithoutInsurersNestedInput
    servicesetting?: servicesettingUncheckedUpdateManyWithoutInsurersNestedInput
  }

  export type insurersCreateWithoutClaimantsInput = {
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentcauseover45days?: accidentcauseover45daysCreateNestedManyWithoutInsurersInput
    accidentplace?: accidentplaceCreateNestedManyWithoutInsurersInput
    accidenttransactions?: accidenttransactionsCreateNestedManyWithoutInsurersInput
    accidenttransactions22?: accidenttransactions22CreateNestedManyWithoutInsurersInput
    causeofinjuryside?: causeofinjurysideCreateNestedManyWithoutInsurersInput
    causeofinjurywoundtype?: causeofinjurywoundtypeCreateNestedManyWithoutInsurersInput
    claimdocuments?: claimdocumentsCreateNestedManyWithoutInsurersInput
    claimstatus?: claimstatusCreateNestedManyWithoutInsurersInput
    diagnosistypemapping?: diagnosistypemappingCreateNestedManyWithoutInsurersInput
    documenttype?: documenttypeCreateNestedManyWithoutInsurersInput
    illnesssurgery?: illnesssurgeryCreateNestedManyWithoutInsurersInput
    illnesstype?: illnesstypeCreateNestedManyWithoutInsurersInput
    policytype?: policytypeCreateNestedManyWithoutInsurersInput
    proceduretransactions?: proceduretransactionsCreateNestedManyWithoutInsurersInput
    servicesetting?: servicesettingCreateNestedManyWithoutInsurersInput
  }

  export type insurersUncheckedCreateWithoutClaimantsInput = {
    id?: number
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentcauseover45days?: accidentcauseover45daysUncheckedCreateNestedManyWithoutInsurersInput
    accidentplace?: accidentplaceUncheckedCreateNestedManyWithoutInsurersInput
    accidenttransactions?: accidenttransactionsUncheckedCreateNestedManyWithoutInsurersInput
    accidenttransactions22?: accidenttransactions22UncheckedCreateNestedManyWithoutInsurersInput
    causeofinjuryside?: causeofinjurysideUncheckedCreateNestedManyWithoutInsurersInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUncheckedCreateNestedManyWithoutInsurersInput
    claimdocuments?: claimdocumentsUncheckedCreateNestedManyWithoutInsurersInput
    claimstatus?: claimstatusUncheckedCreateNestedManyWithoutInsurersInput
    diagnosistypemapping?: diagnosistypemappingUncheckedCreateNestedManyWithoutInsurersInput
    documenttype?: documenttypeUncheckedCreateNestedManyWithoutInsurersInput
    illnesssurgery?: illnesssurgeryUncheckedCreateNestedManyWithoutInsurersInput
    illnesstype?: illnesstypeUncheckedCreateNestedManyWithoutInsurersInput
    policytype?: policytypeUncheckedCreateNestedManyWithoutInsurersInput
    proceduretransactions?: proceduretransactionsUncheckedCreateNestedManyWithoutInsurersInput
    servicesetting?: servicesettingUncheckedCreateNestedManyWithoutInsurersInput
  }

  export type insurersCreateOrConnectWithoutClaimantsInput = {
    where: insurersWhereUniqueInput
    create: XOR<insurersCreateWithoutClaimantsInput, insurersUncheckedCreateWithoutClaimantsInput>
  }

  export type insurersUpsertWithoutClaimantsInput = {
    update: XOR<insurersUpdateWithoutClaimantsInput, insurersUncheckedUpdateWithoutClaimantsInput>
    create: XOR<insurersCreateWithoutClaimantsInput, insurersUncheckedCreateWithoutClaimantsInput>
    where?: insurersWhereInput
  }

  export type insurersUpdateToOneWithWhereWithoutClaimantsInput = {
    where?: insurersWhereInput
    data: XOR<insurersUpdateWithoutClaimantsInput, insurersUncheckedUpdateWithoutClaimantsInput>
  }

  export type insurersUpdateWithoutClaimantsInput = {
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: accidentcauseover45daysUpdateManyWithoutInsurersNestedInput
    accidentplace?: accidentplaceUpdateManyWithoutInsurersNestedInput
    accidenttransactions?: accidenttransactionsUpdateManyWithoutInsurersNestedInput
    accidenttransactions22?: accidenttransactions22UpdateManyWithoutInsurersNestedInput
    causeofinjuryside?: causeofinjurysideUpdateManyWithoutInsurersNestedInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUpdateManyWithoutInsurersNestedInput
    claimdocuments?: claimdocumentsUpdateManyWithoutInsurersNestedInput
    claimstatus?: claimstatusUpdateManyWithoutInsurersNestedInput
    diagnosistypemapping?: diagnosistypemappingUpdateManyWithoutInsurersNestedInput
    documenttype?: documenttypeUpdateManyWithoutInsurersNestedInput
    illnesssurgery?: illnesssurgeryUpdateManyWithoutInsurersNestedInput
    illnesstype?: illnesstypeUpdateManyWithoutInsurersNestedInput
    policytype?: policytypeUpdateManyWithoutInsurersNestedInput
    proceduretransactions?: proceduretransactionsUpdateManyWithoutInsurersNestedInput
    servicesetting?: servicesettingUpdateManyWithoutInsurersNestedInput
  }

  export type insurersUncheckedUpdateWithoutClaimantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: accidentcauseover45daysUncheckedUpdateManyWithoutInsurersNestedInput
    accidentplace?: accidentplaceUncheckedUpdateManyWithoutInsurersNestedInput
    accidenttransactions?: accidenttransactionsUncheckedUpdateManyWithoutInsurersNestedInput
    accidenttransactions22?: accidenttransactions22UncheckedUpdateManyWithoutInsurersNestedInput
    causeofinjuryside?: causeofinjurysideUncheckedUpdateManyWithoutInsurersNestedInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUncheckedUpdateManyWithoutInsurersNestedInput
    claimdocuments?: claimdocumentsUncheckedUpdateManyWithoutInsurersNestedInput
    claimstatus?: claimstatusUncheckedUpdateManyWithoutInsurersNestedInput
    diagnosistypemapping?: diagnosistypemappingUncheckedUpdateManyWithoutInsurersNestedInput
    documenttype?: documenttypeUncheckedUpdateManyWithoutInsurersNestedInput
    illnesssurgery?: illnesssurgeryUncheckedUpdateManyWithoutInsurersNestedInput
    illnesstype?: illnesstypeUncheckedUpdateManyWithoutInsurersNestedInput
    policytype?: policytypeUncheckedUpdateManyWithoutInsurersNestedInput
    proceduretransactions?: proceduretransactionsUncheckedUpdateManyWithoutInsurersNestedInput
    servicesetting?: servicesettingUncheckedUpdateManyWithoutInsurersNestedInput
  }

  export type insurersCreateWithoutClaimdocumentsInput = {
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentcauseover45days?: accidentcauseover45daysCreateNestedManyWithoutInsurersInput
    accidentplace?: accidentplaceCreateNestedManyWithoutInsurersInput
    accidenttransactions?: accidenttransactionsCreateNestedManyWithoutInsurersInput
    accidenttransactions22?: accidenttransactions22CreateNestedManyWithoutInsurersInput
    causeofinjuryside?: causeofinjurysideCreateNestedManyWithoutInsurersInput
    causeofinjurywoundtype?: causeofinjurywoundtypeCreateNestedManyWithoutInsurersInput
    claimants?: claimantsCreateNestedManyWithoutInsurersInput
    claimstatus?: claimstatusCreateNestedManyWithoutInsurersInput
    diagnosistypemapping?: diagnosistypemappingCreateNestedManyWithoutInsurersInput
    documenttype?: documenttypeCreateNestedManyWithoutInsurersInput
    illnesssurgery?: illnesssurgeryCreateNestedManyWithoutInsurersInput
    illnesstype?: illnesstypeCreateNestedManyWithoutInsurersInput
    policytype?: policytypeCreateNestedManyWithoutInsurersInput
    proceduretransactions?: proceduretransactionsCreateNestedManyWithoutInsurersInput
    servicesetting?: servicesettingCreateNestedManyWithoutInsurersInput
  }

  export type insurersUncheckedCreateWithoutClaimdocumentsInput = {
    id?: number
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentcauseover45days?: accidentcauseover45daysUncheckedCreateNestedManyWithoutInsurersInput
    accidentplace?: accidentplaceUncheckedCreateNestedManyWithoutInsurersInput
    accidenttransactions?: accidenttransactionsUncheckedCreateNestedManyWithoutInsurersInput
    accidenttransactions22?: accidenttransactions22UncheckedCreateNestedManyWithoutInsurersInput
    causeofinjuryside?: causeofinjurysideUncheckedCreateNestedManyWithoutInsurersInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUncheckedCreateNestedManyWithoutInsurersInput
    claimants?: claimantsUncheckedCreateNestedManyWithoutInsurersInput
    claimstatus?: claimstatusUncheckedCreateNestedManyWithoutInsurersInput
    diagnosistypemapping?: diagnosistypemappingUncheckedCreateNestedManyWithoutInsurersInput
    documenttype?: documenttypeUncheckedCreateNestedManyWithoutInsurersInput
    illnesssurgery?: illnesssurgeryUncheckedCreateNestedManyWithoutInsurersInput
    illnesstype?: illnesstypeUncheckedCreateNestedManyWithoutInsurersInput
    policytype?: policytypeUncheckedCreateNestedManyWithoutInsurersInput
    proceduretransactions?: proceduretransactionsUncheckedCreateNestedManyWithoutInsurersInput
    servicesetting?: servicesettingUncheckedCreateNestedManyWithoutInsurersInput
  }

  export type insurersCreateOrConnectWithoutClaimdocumentsInput = {
    where: insurersWhereUniqueInput
    create: XOR<insurersCreateWithoutClaimdocumentsInput, insurersUncheckedCreateWithoutClaimdocumentsInput>
  }

  export type insurersUpsertWithoutClaimdocumentsInput = {
    update: XOR<insurersUpdateWithoutClaimdocumentsInput, insurersUncheckedUpdateWithoutClaimdocumentsInput>
    create: XOR<insurersCreateWithoutClaimdocumentsInput, insurersUncheckedCreateWithoutClaimdocumentsInput>
    where?: insurersWhereInput
  }

  export type insurersUpdateToOneWithWhereWithoutClaimdocumentsInput = {
    where?: insurersWhereInput
    data: XOR<insurersUpdateWithoutClaimdocumentsInput, insurersUncheckedUpdateWithoutClaimdocumentsInput>
  }

  export type insurersUpdateWithoutClaimdocumentsInput = {
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: accidentcauseover45daysUpdateManyWithoutInsurersNestedInput
    accidentplace?: accidentplaceUpdateManyWithoutInsurersNestedInput
    accidenttransactions?: accidenttransactionsUpdateManyWithoutInsurersNestedInput
    accidenttransactions22?: accidenttransactions22UpdateManyWithoutInsurersNestedInput
    causeofinjuryside?: causeofinjurysideUpdateManyWithoutInsurersNestedInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUpdateManyWithoutInsurersNestedInput
    claimants?: claimantsUpdateManyWithoutInsurersNestedInput
    claimstatus?: claimstatusUpdateManyWithoutInsurersNestedInput
    diagnosistypemapping?: diagnosistypemappingUpdateManyWithoutInsurersNestedInput
    documenttype?: documenttypeUpdateManyWithoutInsurersNestedInput
    illnesssurgery?: illnesssurgeryUpdateManyWithoutInsurersNestedInput
    illnesstype?: illnesstypeUpdateManyWithoutInsurersNestedInput
    policytype?: policytypeUpdateManyWithoutInsurersNestedInput
    proceduretransactions?: proceduretransactionsUpdateManyWithoutInsurersNestedInput
    servicesetting?: servicesettingUpdateManyWithoutInsurersNestedInput
  }

  export type insurersUncheckedUpdateWithoutClaimdocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: accidentcauseover45daysUncheckedUpdateManyWithoutInsurersNestedInput
    accidentplace?: accidentplaceUncheckedUpdateManyWithoutInsurersNestedInput
    accidenttransactions?: accidenttransactionsUncheckedUpdateManyWithoutInsurersNestedInput
    accidenttransactions22?: accidenttransactions22UncheckedUpdateManyWithoutInsurersNestedInput
    causeofinjuryside?: causeofinjurysideUncheckedUpdateManyWithoutInsurersNestedInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUncheckedUpdateManyWithoutInsurersNestedInput
    claimants?: claimantsUncheckedUpdateManyWithoutInsurersNestedInput
    claimstatus?: claimstatusUncheckedUpdateManyWithoutInsurersNestedInput
    diagnosistypemapping?: diagnosistypemappingUncheckedUpdateManyWithoutInsurersNestedInput
    documenttype?: documenttypeUncheckedUpdateManyWithoutInsurersNestedInput
    illnesssurgery?: illnesssurgeryUncheckedUpdateManyWithoutInsurersNestedInput
    illnesstype?: illnesstypeUncheckedUpdateManyWithoutInsurersNestedInput
    policytype?: policytypeUncheckedUpdateManyWithoutInsurersNestedInput
    proceduretransactions?: proceduretransactionsUncheckedUpdateManyWithoutInsurersNestedInput
    servicesetting?: servicesettingUncheckedUpdateManyWithoutInsurersNestedInput
  }

  export type insurersCreateWithoutClaimstatusInput = {
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentcauseover45days?: accidentcauseover45daysCreateNestedManyWithoutInsurersInput
    accidentplace?: accidentplaceCreateNestedManyWithoutInsurersInput
    accidenttransactions?: accidenttransactionsCreateNestedManyWithoutInsurersInput
    accidenttransactions22?: accidenttransactions22CreateNestedManyWithoutInsurersInput
    causeofinjuryside?: causeofinjurysideCreateNestedManyWithoutInsurersInput
    causeofinjurywoundtype?: causeofinjurywoundtypeCreateNestedManyWithoutInsurersInput
    claimants?: claimantsCreateNestedManyWithoutInsurersInput
    claimdocuments?: claimdocumentsCreateNestedManyWithoutInsurersInput
    diagnosistypemapping?: diagnosistypemappingCreateNestedManyWithoutInsurersInput
    documenttype?: documenttypeCreateNestedManyWithoutInsurersInput
    illnesssurgery?: illnesssurgeryCreateNestedManyWithoutInsurersInput
    illnesstype?: illnesstypeCreateNestedManyWithoutInsurersInput
    policytype?: policytypeCreateNestedManyWithoutInsurersInput
    proceduretransactions?: proceduretransactionsCreateNestedManyWithoutInsurersInput
    servicesetting?: servicesettingCreateNestedManyWithoutInsurersInput
  }

  export type insurersUncheckedCreateWithoutClaimstatusInput = {
    id?: number
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentcauseover45days?: accidentcauseover45daysUncheckedCreateNestedManyWithoutInsurersInput
    accidentplace?: accidentplaceUncheckedCreateNestedManyWithoutInsurersInput
    accidenttransactions?: accidenttransactionsUncheckedCreateNestedManyWithoutInsurersInput
    accidenttransactions22?: accidenttransactions22UncheckedCreateNestedManyWithoutInsurersInput
    causeofinjuryside?: causeofinjurysideUncheckedCreateNestedManyWithoutInsurersInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUncheckedCreateNestedManyWithoutInsurersInput
    claimants?: claimantsUncheckedCreateNestedManyWithoutInsurersInput
    claimdocuments?: claimdocumentsUncheckedCreateNestedManyWithoutInsurersInput
    diagnosistypemapping?: diagnosistypemappingUncheckedCreateNestedManyWithoutInsurersInput
    documenttype?: documenttypeUncheckedCreateNestedManyWithoutInsurersInput
    illnesssurgery?: illnesssurgeryUncheckedCreateNestedManyWithoutInsurersInput
    illnesstype?: illnesstypeUncheckedCreateNestedManyWithoutInsurersInput
    policytype?: policytypeUncheckedCreateNestedManyWithoutInsurersInput
    proceduretransactions?: proceduretransactionsUncheckedCreateNestedManyWithoutInsurersInput
    servicesetting?: servicesettingUncheckedCreateNestedManyWithoutInsurersInput
  }

  export type insurersCreateOrConnectWithoutClaimstatusInput = {
    where: insurersWhereUniqueInput
    create: XOR<insurersCreateWithoutClaimstatusInput, insurersUncheckedCreateWithoutClaimstatusInput>
  }

  export type transactionclaimstatusCreateWithoutClaimstatusInput = {
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    batchnumber?: string | null
    claimno?: string | null
    invoicenumber?: string | null
    status_changed_at?: Date | string | null
    note?: string | null
    totalapproveamount?: string | null
    paymentdate?: string | null
  }

  export type transactionclaimstatusUncheckedCreateWithoutClaimstatusInput = {
    id?: number
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    batchnumber?: string | null
    claimno?: string | null
    invoicenumber?: string | null
    status_changed_at?: Date | string | null
    note?: string | null
    totalapproveamount?: string | null
    paymentdate?: string | null
  }

  export type transactionclaimstatusCreateOrConnectWithoutClaimstatusInput = {
    where: transactionclaimstatusWhereUniqueInput
    create: XOR<transactionclaimstatusCreateWithoutClaimstatusInput, transactionclaimstatusUncheckedCreateWithoutClaimstatusInput>
  }

  export type transactionclaimstatusCreateManyClaimstatusInputEnvelope = {
    data: transactionclaimstatusCreateManyClaimstatusInput | transactionclaimstatusCreateManyClaimstatusInput[]
    skipDuplicates?: boolean
  }

  export type insurersUpsertWithoutClaimstatusInput = {
    update: XOR<insurersUpdateWithoutClaimstatusInput, insurersUncheckedUpdateWithoutClaimstatusInput>
    create: XOR<insurersCreateWithoutClaimstatusInput, insurersUncheckedCreateWithoutClaimstatusInput>
    where?: insurersWhereInput
  }

  export type insurersUpdateToOneWithWhereWithoutClaimstatusInput = {
    where?: insurersWhereInput
    data: XOR<insurersUpdateWithoutClaimstatusInput, insurersUncheckedUpdateWithoutClaimstatusInput>
  }

  export type insurersUpdateWithoutClaimstatusInput = {
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: accidentcauseover45daysUpdateManyWithoutInsurersNestedInput
    accidentplace?: accidentplaceUpdateManyWithoutInsurersNestedInput
    accidenttransactions?: accidenttransactionsUpdateManyWithoutInsurersNestedInput
    accidenttransactions22?: accidenttransactions22UpdateManyWithoutInsurersNestedInput
    causeofinjuryside?: causeofinjurysideUpdateManyWithoutInsurersNestedInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUpdateManyWithoutInsurersNestedInput
    claimants?: claimantsUpdateManyWithoutInsurersNestedInput
    claimdocuments?: claimdocumentsUpdateManyWithoutInsurersNestedInput
    diagnosistypemapping?: diagnosistypemappingUpdateManyWithoutInsurersNestedInput
    documenttype?: documenttypeUpdateManyWithoutInsurersNestedInput
    illnesssurgery?: illnesssurgeryUpdateManyWithoutInsurersNestedInput
    illnesstype?: illnesstypeUpdateManyWithoutInsurersNestedInput
    policytype?: policytypeUpdateManyWithoutInsurersNestedInput
    proceduretransactions?: proceduretransactionsUpdateManyWithoutInsurersNestedInput
    servicesetting?: servicesettingUpdateManyWithoutInsurersNestedInput
  }

  export type insurersUncheckedUpdateWithoutClaimstatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: accidentcauseover45daysUncheckedUpdateManyWithoutInsurersNestedInput
    accidentplace?: accidentplaceUncheckedUpdateManyWithoutInsurersNestedInput
    accidenttransactions?: accidenttransactionsUncheckedUpdateManyWithoutInsurersNestedInput
    accidenttransactions22?: accidenttransactions22UncheckedUpdateManyWithoutInsurersNestedInput
    causeofinjuryside?: causeofinjurysideUncheckedUpdateManyWithoutInsurersNestedInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUncheckedUpdateManyWithoutInsurersNestedInput
    claimants?: claimantsUncheckedUpdateManyWithoutInsurersNestedInput
    claimdocuments?: claimdocumentsUncheckedUpdateManyWithoutInsurersNestedInput
    diagnosistypemapping?: diagnosistypemappingUncheckedUpdateManyWithoutInsurersNestedInput
    documenttype?: documenttypeUncheckedUpdateManyWithoutInsurersNestedInput
    illnesssurgery?: illnesssurgeryUncheckedUpdateManyWithoutInsurersNestedInput
    illnesstype?: illnesstypeUncheckedUpdateManyWithoutInsurersNestedInput
    policytype?: policytypeUncheckedUpdateManyWithoutInsurersNestedInput
    proceduretransactions?: proceduretransactionsUncheckedUpdateManyWithoutInsurersNestedInput
    servicesetting?: servicesettingUncheckedUpdateManyWithoutInsurersNestedInput
  }

  export type transactionclaimstatusUpsertWithWhereUniqueWithoutClaimstatusInput = {
    where: transactionclaimstatusWhereUniqueInput
    update: XOR<transactionclaimstatusUpdateWithoutClaimstatusInput, transactionclaimstatusUncheckedUpdateWithoutClaimstatusInput>
    create: XOR<transactionclaimstatusCreateWithoutClaimstatusInput, transactionclaimstatusUncheckedCreateWithoutClaimstatusInput>
  }

  export type transactionclaimstatusUpdateWithWhereUniqueWithoutClaimstatusInput = {
    where: transactionclaimstatusWhereUniqueInput
    data: XOR<transactionclaimstatusUpdateWithoutClaimstatusInput, transactionclaimstatusUncheckedUpdateWithoutClaimstatusInput>
  }

  export type transactionclaimstatusUpdateManyWithWhereWithoutClaimstatusInput = {
    where: transactionclaimstatusScalarWhereInput
    data: XOR<transactionclaimstatusUpdateManyMutationInput, transactionclaimstatusUncheckedUpdateManyWithoutClaimstatusInput>
  }

  export type transactionclaimstatusScalarWhereInput = {
    AND?: transactionclaimstatusScalarWhereInput | transactionclaimstatusScalarWhereInput[]
    OR?: transactionclaimstatusScalarWhereInput[]
    NOT?: transactionclaimstatusScalarWhereInput | transactionclaimstatusScalarWhereInput[]
    id?: IntFilter<"transactionclaimstatus"> | number
    insurerid?: IntNullableFilter<"transactionclaimstatus"> | number | null
    refid?: StringNullableFilter<"transactionclaimstatus"> | string | null
    transactionno?: StringNullableFilter<"transactionclaimstatus"> | string | null
    hn?: StringNullableFilter<"transactionclaimstatus"> | string | null
    vn?: StringNullableFilter<"transactionclaimstatus"> | string | null
    batchnumber?: StringNullableFilter<"transactionclaimstatus"> | string | null
    claimno?: StringNullableFilter<"transactionclaimstatus"> | string | null
    invoicenumber?: StringNullableFilter<"transactionclaimstatus"> | string | null
    status_changed_at?: DateTimeNullableFilter<"transactionclaimstatus"> | Date | string | null
    note?: StringNullableFilter<"transactionclaimstatus"> | string | null
    totalapproveamount?: StringNullableFilter<"transactionclaimstatus"> | string | null
    paymentdate?: StringNullableFilter<"transactionclaimstatus"> | string | null
    claimstatuscode?: StringNullableFilter<"transactionclaimstatus"> | string | null
  }

  export type insurersCreateWithoutDiagnosistypemappingInput = {
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentcauseover45days?: accidentcauseover45daysCreateNestedManyWithoutInsurersInput
    accidentplace?: accidentplaceCreateNestedManyWithoutInsurersInput
    accidenttransactions?: accidenttransactionsCreateNestedManyWithoutInsurersInput
    accidenttransactions22?: accidenttransactions22CreateNestedManyWithoutInsurersInput
    causeofinjuryside?: causeofinjurysideCreateNestedManyWithoutInsurersInput
    causeofinjurywoundtype?: causeofinjurywoundtypeCreateNestedManyWithoutInsurersInput
    claimants?: claimantsCreateNestedManyWithoutInsurersInput
    claimdocuments?: claimdocumentsCreateNestedManyWithoutInsurersInput
    claimstatus?: claimstatusCreateNestedManyWithoutInsurersInput
    documenttype?: documenttypeCreateNestedManyWithoutInsurersInput
    illnesssurgery?: illnesssurgeryCreateNestedManyWithoutInsurersInput
    illnesstype?: illnesstypeCreateNestedManyWithoutInsurersInput
    policytype?: policytypeCreateNestedManyWithoutInsurersInput
    proceduretransactions?: proceduretransactionsCreateNestedManyWithoutInsurersInput
    servicesetting?: servicesettingCreateNestedManyWithoutInsurersInput
  }

  export type insurersUncheckedCreateWithoutDiagnosistypemappingInput = {
    id?: number
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentcauseover45days?: accidentcauseover45daysUncheckedCreateNestedManyWithoutInsurersInput
    accidentplace?: accidentplaceUncheckedCreateNestedManyWithoutInsurersInput
    accidenttransactions?: accidenttransactionsUncheckedCreateNestedManyWithoutInsurersInput
    accidenttransactions22?: accidenttransactions22UncheckedCreateNestedManyWithoutInsurersInput
    causeofinjuryside?: causeofinjurysideUncheckedCreateNestedManyWithoutInsurersInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUncheckedCreateNestedManyWithoutInsurersInput
    claimants?: claimantsUncheckedCreateNestedManyWithoutInsurersInput
    claimdocuments?: claimdocumentsUncheckedCreateNestedManyWithoutInsurersInput
    claimstatus?: claimstatusUncheckedCreateNestedManyWithoutInsurersInput
    documenttype?: documenttypeUncheckedCreateNestedManyWithoutInsurersInput
    illnesssurgery?: illnesssurgeryUncheckedCreateNestedManyWithoutInsurersInput
    illnesstype?: illnesstypeUncheckedCreateNestedManyWithoutInsurersInput
    policytype?: policytypeUncheckedCreateNestedManyWithoutInsurersInput
    proceduretransactions?: proceduretransactionsUncheckedCreateNestedManyWithoutInsurersInput
    servicesetting?: servicesettingUncheckedCreateNestedManyWithoutInsurersInput
  }

  export type insurersCreateOrConnectWithoutDiagnosistypemappingInput = {
    where: insurersWhereUniqueInput
    create: XOR<insurersCreateWithoutDiagnosistypemappingInput, insurersUncheckedCreateWithoutDiagnosistypemappingInput>
  }

  export type insurersUpsertWithoutDiagnosistypemappingInput = {
    update: XOR<insurersUpdateWithoutDiagnosistypemappingInput, insurersUncheckedUpdateWithoutDiagnosistypemappingInput>
    create: XOR<insurersCreateWithoutDiagnosistypemappingInput, insurersUncheckedCreateWithoutDiagnosistypemappingInput>
    where?: insurersWhereInput
  }

  export type insurersUpdateToOneWithWhereWithoutDiagnosistypemappingInput = {
    where?: insurersWhereInput
    data: XOR<insurersUpdateWithoutDiagnosistypemappingInput, insurersUncheckedUpdateWithoutDiagnosistypemappingInput>
  }

  export type insurersUpdateWithoutDiagnosistypemappingInput = {
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: accidentcauseover45daysUpdateManyWithoutInsurersNestedInput
    accidentplace?: accidentplaceUpdateManyWithoutInsurersNestedInput
    accidenttransactions?: accidenttransactionsUpdateManyWithoutInsurersNestedInput
    accidenttransactions22?: accidenttransactions22UpdateManyWithoutInsurersNestedInput
    causeofinjuryside?: causeofinjurysideUpdateManyWithoutInsurersNestedInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUpdateManyWithoutInsurersNestedInput
    claimants?: claimantsUpdateManyWithoutInsurersNestedInput
    claimdocuments?: claimdocumentsUpdateManyWithoutInsurersNestedInput
    claimstatus?: claimstatusUpdateManyWithoutInsurersNestedInput
    documenttype?: documenttypeUpdateManyWithoutInsurersNestedInput
    illnesssurgery?: illnesssurgeryUpdateManyWithoutInsurersNestedInput
    illnesstype?: illnesstypeUpdateManyWithoutInsurersNestedInput
    policytype?: policytypeUpdateManyWithoutInsurersNestedInput
    proceduretransactions?: proceduretransactionsUpdateManyWithoutInsurersNestedInput
    servicesetting?: servicesettingUpdateManyWithoutInsurersNestedInput
  }

  export type insurersUncheckedUpdateWithoutDiagnosistypemappingInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: accidentcauseover45daysUncheckedUpdateManyWithoutInsurersNestedInput
    accidentplace?: accidentplaceUncheckedUpdateManyWithoutInsurersNestedInput
    accidenttransactions?: accidenttransactionsUncheckedUpdateManyWithoutInsurersNestedInput
    accidenttransactions22?: accidenttransactions22UncheckedUpdateManyWithoutInsurersNestedInput
    causeofinjuryside?: causeofinjurysideUncheckedUpdateManyWithoutInsurersNestedInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUncheckedUpdateManyWithoutInsurersNestedInput
    claimants?: claimantsUncheckedUpdateManyWithoutInsurersNestedInput
    claimdocuments?: claimdocumentsUncheckedUpdateManyWithoutInsurersNestedInput
    claimstatus?: claimstatusUncheckedUpdateManyWithoutInsurersNestedInput
    documenttype?: documenttypeUncheckedUpdateManyWithoutInsurersNestedInput
    illnesssurgery?: illnesssurgeryUncheckedUpdateManyWithoutInsurersNestedInput
    illnesstype?: illnesstypeUncheckedUpdateManyWithoutInsurersNestedInput
    policytype?: policytypeUncheckedUpdateManyWithoutInsurersNestedInput
    proceduretransactions?: proceduretransactionsUncheckedUpdateManyWithoutInsurersNestedInput
    servicesetting?: servicesettingUncheckedUpdateManyWithoutInsurersNestedInput
  }

  export type insurersCreateWithoutDocumenttypeInput = {
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentcauseover45days?: accidentcauseover45daysCreateNestedManyWithoutInsurersInput
    accidentplace?: accidentplaceCreateNestedManyWithoutInsurersInput
    accidenttransactions?: accidenttransactionsCreateNestedManyWithoutInsurersInput
    accidenttransactions22?: accidenttransactions22CreateNestedManyWithoutInsurersInput
    causeofinjuryside?: causeofinjurysideCreateNestedManyWithoutInsurersInput
    causeofinjurywoundtype?: causeofinjurywoundtypeCreateNestedManyWithoutInsurersInput
    claimants?: claimantsCreateNestedManyWithoutInsurersInput
    claimdocuments?: claimdocumentsCreateNestedManyWithoutInsurersInput
    claimstatus?: claimstatusCreateNestedManyWithoutInsurersInput
    diagnosistypemapping?: diagnosistypemappingCreateNestedManyWithoutInsurersInput
    illnesssurgery?: illnesssurgeryCreateNestedManyWithoutInsurersInput
    illnesstype?: illnesstypeCreateNestedManyWithoutInsurersInput
    policytype?: policytypeCreateNestedManyWithoutInsurersInput
    proceduretransactions?: proceduretransactionsCreateNestedManyWithoutInsurersInput
    servicesetting?: servicesettingCreateNestedManyWithoutInsurersInput
  }

  export type insurersUncheckedCreateWithoutDocumenttypeInput = {
    id?: number
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentcauseover45days?: accidentcauseover45daysUncheckedCreateNestedManyWithoutInsurersInput
    accidentplace?: accidentplaceUncheckedCreateNestedManyWithoutInsurersInput
    accidenttransactions?: accidenttransactionsUncheckedCreateNestedManyWithoutInsurersInput
    accidenttransactions22?: accidenttransactions22UncheckedCreateNestedManyWithoutInsurersInput
    causeofinjuryside?: causeofinjurysideUncheckedCreateNestedManyWithoutInsurersInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUncheckedCreateNestedManyWithoutInsurersInput
    claimants?: claimantsUncheckedCreateNestedManyWithoutInsurersInput
    claimdocuments?: claimdocumentsUncheckedCreateNestedManyWithoutInsurersInput
    claimstatus?: claimstatusUncheckedCreateNestedManyWithoutInsurersInput
    diagnosistypemapping?: diagnosistypemappingUncheckedCreateNestedManyWithoutInsurersInput
    illnesssurgery?: illnesssurgeryUncheckedCreateNestedManyWithoutInsurersInput
    illnesstype?: illnesstypeUncheckedCreateNestedManyWithoutInsurersInput
    policytype?: policytypeUncheckedCreateNestedManyWithoutInsurersInput
    proceduretransactions?: proceduretransactionsUncheckedCreateNestedManyWithoutInsurersInput
    servicesetting?: servicesettingUncheckedCreateNestedManyWithoutInsurersInput
  }

  export type insurersCreateOrConnectWithoutDocumenttypeInput = {
    where: insurersWhereUniqueInput
    create: XOR<insurersCreateWithoutDocumenttypeInput, insurersUncheckedCreateWithoutDocumenttypeInput>
  }

  export type insurersUpsertWithoutDocumenttypeInput = {
    update: XOR<insurersUpdateWithoutDocumenttypeInput, insurersUncheckedUpdateWithoutDocumenttypeInput>
    create: XOR<insurersCreateWithoutDocumenttypeInput, insurersUncheckedCreateWithoutDocumenttypeInput>
    where?: insurersWhereInput
  }

  export type insurersUpdateToOneWithWhereWithoutDocumenttypeInput = {
    where?: insurersWhereInput
    data: XOR<insurersUpdateWithoutDocumenttypeInput, insurersUncheckedUpdateWithoutDocumenttypeInput>
  }

  export type insurersUpdateWithoutDocumenttypeInput = {
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: accidentcauseover45daysUpdateManyWithoutInsurersNestedInput
    accidentplace?: accidentplaceUpdateManyWithoutInsurersNestedInput
    accidenttransactions?: accidenttransactionsUpdateManyWithoutInsurersNestedInput
    accidenttransactions22?: accidenttransactions22UpdateManyWithoutInsurersNestedInput
    causeofinjuryside?: causeofinjurysideUpdateManyWithoutInsurersNestedInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUpdateManyWithoutInsurersNestedInput
    claimants?: claimantsUpdateManyWithoutInsurersNestedInput
    claimdocuments?: claimdocumentsUpdateManyWithoutInsurersNestedInput
    claimstatus?: claimstatusUpdateManyWithoutInsurersNestedInput
    diagnosistypemapping?: diagnosistypemappingUpdateManyWithoutInsurersNestedInput
    illnesssurgery?: illnesssurgeryUpdateManyWithoutInsurersNestedInput
    illnesstype?: illnesstypeUpdateManyWithoutInsurersNestedInput
    policytype?: policytypeUpdateManyWithoutInsurersNestedInput
    proceduretransactions?: proceduretransactionsUpdateManyWithoutInsurersNestedInput
    servicesetting?: servicesettingUpdateManyWithoutInsurersNestedInput
  }

  export type insurersUncheckedUpdateWithoutDocumenttypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: accidentcauseover45daysUncheckedUpdateManyWithoutInsurersNestedInput
    accidentplace?: accidentplaceUncheckedUpdateManyWithoutInsurersNestedInput
    accidenttransactions?: accidenttransactionsUncheckedUpdateManyWithoutInsurersNestedInput
    accidenttransactions22?: accidenttransactions22UncheckedUpdateManyWithoutInsurersNestedInput
    causeofinjuryside?: causeofinjurysideUncheckedUpdateManyWithoutInsurersNestedInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUncheckedUpdateManyWithoutInsurersNestedInput
    claimants?: claimantsUncheckedUpdateManyWithoutInsurersNestedInput
    claimdocuments?: claimdocumentsUncheckedUpdateManyWithoutInsurersNestedInput
    claimstatus?: claimstatusUncheckedUpdateManyWithoutInsurersNestedInput
    diagnosistypemapping?: diagnosistypemappingUncheckedUpdateManyWithoutInsurersNestedInput
    illnesssurgery?: illnesssurgeryUncheckedUpdateManyWithoutInsurersNestedInput
    illnesstype?: illnesstypeUncheckedUpdateManyWithoutInsurersNestedInput
    policytype?: policytypeUncheckedUpdateManyWithoutInsurersNestedInput
    proceduretransactions?: proceduretransactionsUncheckedUpdateManyWithoutInsurersNestedInput
    servicesetting?: servicesettingUncheckedUpdateManyWithoutInsurersNestedInput
  }

  export type insurersCreateWithoutIllnesssurgeryInput = {
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentcauseover45days?: accidentcauseover45daysCreateNestedManyWithoutInsurersInput
    accidentplace?: accidentplaceCreateNestedManyWithoutInsurersInput
    accidenttransactions?: accidenttransactionsCreateNestedManyWithoutInsurersInput
    accidenttransactions22?: accidenttransactions22CreateNestedManyWithoutInsurersInput
    causeofinjuryside?: causeofinjurysideCreateNestedManyWithoutInsurersInput
    causeofinjurywoundtype?: causeofinjurywoundtypeCreateNestedManyWithoutInsurersInput
    claimants?: claimantsCreateNestedManyWithoutInsurersInput
    claimdocuments?: claimdocumentsCreateNestedManyWithoutInsurersInput
    claimstatus?: claimstatusCreateNestedManyWithoutInsurersInput
    diagnosistypemapping?: diagnosistypemappingCreateNestedManyWithoutInsurersInput
    documenttype?: documenttypeCreateNestedManyWithoutInsurersInput
    illnesstype?: illnesstypeCreateNestedManyWithoutInsurersInput
    policytype?: policytypeCreateNestedManyWithoutInsurersInput
    proceduretransactions?: proceduretransactionsCreateNestedManyWithoutInsurersInput
    servicesetting?: servicesettingCreateNestedManyWithoutInsurersInput
  }

  export type insurersUncheckedCreateWithoutIllnesssurgeryInput = {
    id?: number
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentcauseover45days?: accidentcauseover45daysUncheckedCreateNestedManyWithoutInsurersInput
    accidentplace?: accidentplaceUncheckedCreateNestedManyWithoutInsurersInput
    accidenttransactions?: accidenttransactionsUncheckedCreateNestedManyWithoutInsurersInput
    accidenttransactions22?: accidenttransactions22UncheckedCreateNestedManyWithoutInsurersInput
    causeofinjuryside?: causeofinjurysideUncheckedCreateNestedManyWithoutInsurersInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUncheckedCreateNestedManyWithoutInsurersInput
    claimants?: claimantsUncheckedCreateNestedManyWithoutInsurersInput
    claimdocuments?: claimdocumentsUncheckedCreateNestedManyWithoutInsurersInput
    claimstatus?: claimstatusUncheckedCreateNestedManyWithoutInsurersInput
    diagnosistypemapping?: diagnosistypemappingUncheckedCreateNestedManyWithoutInsurersInput
    documenttype?: documenttypeUncheckedCreateNestedManyWithoutInsurersInput
    illnesstype?: illnesstypeUncheckedCreateNestedManyWithoutInsurersInput
    policytype?: policytypeUncheckedCreateNestedManyWithoutInsurersInput
    proceduretransactions?: proceduretransactionsUncheckedCreateNestedManyWithoutInsurersInput
    servicesetting?: servicesettingUncheckedCreateNestedManyWithoutInsurersInput
  }

  export type insurersCreateOrConnectWithoutIllnesssurgeryInput = {
    where: insurersWhereUniqueInput
    create: XOR<insurersCreateWithoutIllnesssurgeryInput, insurersUncheckedCreateWithoutIllnesssurgeryInput>
  }

  export type insurersUpsertWithoutIllnesssurgeryInput = {
    update: XOR<insurersUpdateWithoutIllnesssurgeryInput, insurersUncheckedUpdateWithoutIllnesssurgeryInput>
    create: XOR<insurersCreateWithoutIllnesssurgeryInput, insurersUncheckedCreateWithoutIllnesssurgeryInput>
    where?: insurersWhereInput
  }

  export type insurersUpdateToOneWithWhereWithoutIllnesssurgeryInput = {
    where?: insurersWhereInput
    data: XOR<insurersUpdateWithoutIllnesssurgeryInput, insurersUncheckedUpdateWithoutIllnesssurgeryInput>
  }

  export type insurersUpdateWithoutIllnesssurgeryInput = {
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: accidentcauseover45daysUpdateManyWithoutInsurersNestedInput
    accidentplace?: accidentplaceUpdateManyWithoutInsurersNestedInput
    accidenttransactions?: accidenttransactionsUpdateManyWithoutInsurersNestedInput
    accidenttransactions22?: accidenttransactions22UpdateManyWithoutInsurersNestedInput
    causeofinjuryside?: causeofinjurysideUpdateManyWithoutInsurersNestedInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUpdateManyWithoutInsurersNestedInput
    claimants?: claimantsUpdateManyWithoutInsurersNestedInput
    claimdocuments?: claimdocumentsUpdateManyWithoutInsurersNestedInput
    claimstatus?: claimstatusUpdateManyWithoutInsurersNestedInput
    diagnosistypemapping?: diagnosistypemappingUpdateManyWithoutInsurersNestedInput
    documenttype?: documenttypeUpdateManyWithoutInsurersNestedInput
    illnesstype?: illnesstypeUpdateManyWithoutInsurersNestedInput
    policytype?: policytypeUpdateManyWithoutInsurersNestedInput
    proceduretransactions?: proceduretransactionsUpdateManyWithoutInsurersNestedInput
    servicesetting?: servicesettingUpdateManyWithoutInsurersNestedInput
  }

  export type insurersUncheckedUpdateWithoutIllnesssurgeryInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: accidentcauseover45daysUncheckedUpdateManyWithoutInsurersNestedInput
    accidentplace?: accidentplaceUncheckedUpdateManyWithoutInsurersNestedInput
    accidenttransactions?: accidenttransactionsUncheckedUpdateManyWithoutInsurersNestedInput
    accidenttransactions22?: accidenttransactions22UncheckedUpdateManyWithoutInsurersNestedInput
    causeofinjuryside?: causeofinjurysideUncheckedUpdateManyWithoutInsurersNestedInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUncheckedUpdateManyWithoutInsurersNestedInput
    claimants?: claimantsUncheckedUpdateManyWithoutInsurersNestedInput
    claimdocuments?: claimdocumentsUncheckedUpdateManyWithoutInsurersNestedInput
    claimstatus?: claimstatusUncheckedUpdateManyWithoutInsurersNestedInput
    diagnosistypemapping?: diagnosistypemappingUncheckedUpdateManyWithoutInsurersNestedInput
    documenttype?: documenttypeUncheckedUpdateManyWithoutInsurersNestedInput
    illnesstype?: illnesstypeUncheckedUpdateManyWithoutInsurersNestedInput
    policytype?: policytypeUncheckedUpdateManyWithoutInsurersNestedInput
    proceduretransactions?: proceduretransactionsUncheckedUpdateManyWithoutInsurersNestedInput
    servicesetting?: servicesettingUncheckedUpdateManyWithoutInsurersNestedInput
  }

  export type insurersCreateWithoutIllnesstypeInput = {
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentcauseover45days?: accidentcauseover45daysCreateNestedManyWithoutInsurersInput
    accidentplace?: accidentplaceCreateNestedManyWithoutInsurersInput
    accidenttransactions?: accidenttransactionsCreateNestedManyWithoutInsurersInput
    accidenttransactions22?: accidenttransactions22CreateNestedManyWithoutInsurersInput
    causeofinjuryside?: causeofinjurysideCreateNestedManyWithoutInsurersInput
    causeofinjurywoundtype?: causeofinjurywoundtypeCreateNestedManyWithoutInsurersInput
    claimants?: claimantsCreateNestedManyWithoutInsurersInput
    claimdocuments?: claimdocumentsCreateNestedManyWithoutInsurersInput
    claimstatus?: claimstatusCreateNestedManyWithoutInsurersInput
    diagnosistypemapping?: diagnosistypemappingCreateNestedManyWithoutInsurersInput
    documenttype?: documenttypeCreateNestedManyWithoutInsurersInput
    illnesssurgery?: illnesssurgeryCreateNestedManyWithoutInsurersInput
    policytype?: policytypeCreateNestedManyWithoutInsurersInput
    proceduretransactions?: proceduretransactionsCreateNestedManyWithoutInsurersInput
    servicesetting?: servicesettingCreateNestedManyWithoutInsurersInput
  }

  export type insurersUncheckedCreateWithoutIllnesstypeInput = {
    id?: number
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentcauseover45days?: accidentcauseover45daysUncheckedCreateNestedManyWithoutInsurersInput
    accidentplace?: accidentplaceUncheckedCreateNestedManyWithoutInsurersInput
    accidenttransactions?: accidenttransactionsUncheckedCreateNestedManyWithoutInsurersInput
    accidenttransactions22?: accidenttransactions22UncheckedCreateNestedManyWithoutInsurersInput
    causeofinjuryside?: causeofinjurysideUncheckedCreateNestedManyWithoutInsurersInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUncheckedCreateNestedManyWithoutInsurersInput
    claimants?: claimantsUncheckedCreateNestedManyWithoutInsurersInput
    claimdocuments?: claimdocumentsUncheckedCreateNestedManyWithoutInsurersInput
    claimstatus?: claimstatusUncheckedCreateNestedManyWithoutInsurersInput
    diagnosistypemapping?: diagnosistypemappingUncheckedCreateNestedManyWithoutInsurersInput
    documenttype?: documenttypeUncheckedCreateNestedManyWithoutInsurersInput
    illnesssurgery?: illnesssurgeryUncheckedCreateNestedManyWithoutInsurersInput
    policytype?: policytypeUncheckedCreateNestedManyWithoutInsurersInput
    proceduretransactions?: proceduretransactionsUncheckedCreateNestedManyWithoutInsurersInput
    servicesetting?: servicesettingUncheckedCreateNestedManyWithoutInsurersInput
  }

  export type insurersCreateOrConnectWithoutIllnesstypeInput = {
    where: insurersWhereUniqueInput
    create: XOR<insurersCreateWithoutIllnesstypeInput, insurersUncheckedCreateWithoutIllnesstypeInput>
  }

  export type insurersUpsertWithoutIllnesstypeInput = {
    update: XOR<insurersUpdateWithoutIllnesstypeInput, insurersUncheckedUpdateWithoutIllnesstypeInput>
    create: XOR<insurersCreateWithoutIllnesstypeInput, insurersUncheckedCreateWithoutIllnesstypeInput>
    where?: insurersWhereInput
  }

  export type insurersUpdateToOneWithWhereWithoutIllnesstypeInput = {
    where?: insurersWhereInput
    data: XOR<insurersUpdateWithoutIllnesstypeInput, insurersUncheckedUpdateWithoutIllnesstypeInput>
  }

  export type insurersUpdateWithoutIllnesstypeInput = {
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: accidentcauseover45daysUpdateManyWithoutInsurersNestedInput
    accidentplace?: accidentplaceUpdateManyWithoutInsurersNestedInput
    accidenttransactions?: accidenttransactionsUpdateManyWithoutInsurersNestedInput
    accidenttransactions22?: accidenttransactions22UpdateManyWithoutInsurersNestedInput
    causeofinjuryside?: causeofinjurysideUpdateManyWithoutInsurersNestedInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUpdateManyWithoutInsurersNestedInput
    claimants?: claimantsUpdateManyWithoutInsurersNestedInput
    claimdocuments?: claimdocumentsUpdateManyWithoutInsurersNestedInput
    claimstatus?: claimstatusUpdateManyWithoutInsurersNestedInput
    diagnosistypemapping?: diagnosistypemappingUpdateManyWithoutInsurersNestedInput
    documenttype?: documenttypeUpdateManyWithoutInsurersNestedInput
    illnesssurgery?: illnesssurgeryUpdateManyWithoutInsurersNestedInput
    policytype?: policytypeUpdateManyWithoutInsurersNestedInput
    proceduretransactions?: proceduretransactionsUpdateManyWithoutInsurersNestedInput
    servicesetting?: servicesettingUpdateManyWithoutInsurersNestedInput
  }

  export type insurersUncheckedUpdateWithoutIllnesstypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: accidentcauseover45daysUncheckedUpdateManyWithoutInsurersNestedInput
    accidentplace?: accidentplaceUncheckedUpdateManyWithoutInsurersNestedInput
    accidenttransactions?: accidenttransactionsUncheckedUpdateManyWithoutInsurersNestedInput
    accidenttransactions22?: accidenttransactions22UncheckedUpdateManyWithoutInsurersNestedInput
    causeofinjuryside?: causeofinjurysideUncheckedUpdateManyWithoutInsurersNestedInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUncheckedUpdateManyWithoutInsurersNestedInput
    claimants?: claimantsUncheckedUpdateManyWithoutInsurersNestedInput
    claimdocuments?: claimdocumentsUncheckedUpdateManyWithoutInsurersNestedInput
    claimstatus?: claimstatusUncheckedUpdateManyWithoutInsurersNestedInput
    diagnosistypemapping?: diagnosistypemappingUncheckedUpdateManyWithoutInsurersNestedInput
    documenttype?: documenttypeUncheckedUpdateManyWithoutInsurersNestedInput
    illnesssurgery?: illnesssurgeryUncheckedUpdateManyWithoutInsurersNestedInput
    policytype?: policytypeUncheckedUpdateManyWithoutInsurersNestedInput
    proceduretransactions?: proceduretransactionsUncheckedUpdateManyWithoutInsurersNestedInput
    servicesetting?: servicesettingUncheckedUpdateManyWithoutInsurersNestedInput
  }

  export type accidentcauseover45daysCreateWithoutInsurersInput = {
    causeovercode: string
    causeoverdesc?: string | null
  }

  export type accidentcauseover45daysUncheckedCreateWithoutInsurersInput = {
    id?: number
    causeovercode: string
    causeoverdesc?: string | null
  }

  export type accidentcauseover45daysCreateOrConnectWithoutInsurersInput = {
    where: accidentcauseover45daysWhereUniqueInput
    create: XOR<accidentcauseover45daysCreateWithoutInsurersInput, accidentcauseover45daysUncheckedCreateWithoutInsurersInput>
  }

  export type accidentcauseover45daysCreateManyInsurersInputEnvelope = {
    data: accidentcauseover45daysCreateManyInsurersInput | accidentcauseover45daysCreateManyInsurersInput[]
    skipDuplicates?: boolean
  }

  export type accidentplaceCreateWithoutInsurersInput = {
    accidentplacecode: string
    accidentplacename?: string | null
  }

  export type accidentplaceUncheckedCreateWithoutInsurersInput = {
    id?: number
    accidentplacecode: string
    accidentplacename?: string | null
  }

  export type accidentplaceCreateOrConnectWithoutInsurersInput = {
    where: accidentplaceWhereUniqueInput
    create: XOR<accidentplaceCreateWithoutInsurersInput, accidentplaceUncheckedCreateWithoutInsurersInput>
  }

  export type accidentplaceCreateManyInsurersInputEnvelope = {
    data: accidentplaceCreateManyInsurersInput | accidentplaceCreateManyInsurersInput[]
    skipDuplicates?: boolean
  }

  export type accidenttransactionsCreateWithoutInsurersInput = {
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    accidentplace?: string | null
    accidentdate?: string | null
    causeofinjurydetail?: causeofinjurydetailCreateNestedManyWithoutAccidenttransactionsInput
    injurydetail?: injurydetailCreateNestedManyWithoutAccidenttransactionsInput
  }

  export type accidenttransactionsUncheckedCreateWithoutInsurersInput = {
    id?: number
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    accidentplace?: string | null
    accidentdate?: string | null
    causeofinjurydetail?: causeofinjurydetailUncheckedCreateNestedManyWithoutAccidenttransactionsInput
    injurydetail?: injurydetailUncheckedCreateNestedManyWithoutAccidenttransactionsInput
  }

  export type accidenttransactionsCreateOrConnectWithoutInsurersInput = {
    where: accidenttransactionsWhereUniqueInput
    create: XOR<accidenttransactionsCreateWithoutInsurersInput, accidenttransactionsUncheckedCreateWithoutInsurersInput>
  }

  export type accidenttransactionsCreateManyInsurersInputEnvelope = {
    data: accidenttransactionsCreateManyInsurersInput | accidenttransactionsCreateManyInsurersInput[]
    skipDuplicates?: boolean
  }

  export type accidenttransactions22CreateWithoutInsurersInput = {
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    accidentplace?: string | null
    accidentdate?: string | null
    causeofinjury?: string | null
    commentofinjury?: string | null
    woundtype?: string | null
    injuryside?: string | null
    injuryarea?: string | null
  }

  export type accidenttransactions22UncheckedCreateWithoutInsurersInput = {
    id?: number
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    accidentplace?: string | null
    accidentdate?: string | null
    causeofinjury?: string | null
    commentofinjury?: string | null
    woundtype?: string | null
    injuryside?: string | null
    injuryarea?: string | null
  }

  export type accidenttransactions22CreateOrConnectWithoutInsurersInput = {
    where: accidenttransactions22WhereUniqueInput
    create: XOR<accidenttransactions22CreateWithoutInsurersInput, accidenttransactions22UncheckedCreateWithoutInsurersInput>
  }

  export type accidenttransactions22CreateManyInsurersInputEnvelope = {
    data: accidenttransactions22CreateManyInsurersInput | accidenttransactions22CreateManyInsurersInput[]
    skipDuplicates?: boolean
  }

  export type causeofinjurysideCreateWithoutInsurersInput = {
    injurysidename: string
    injurysidecode?: string | null
  }

  export type causeofinjurysideUncheckedCreateWithoutInsurersInput = {
    id?: number
    injurysidename: string
    injurysidecode?: string | null
  }

  export type causeofinjurysideCreateOrConnectWithoutInsurersInput = {
    where: causeofinjurysideWhereUniqueInput
    create: XOR<causeofinjurysideCreateWithoutInsurersInput, causeofinjurysideUncheckedCreateWithoutInsurersInput>
  }

  export type causeofinjurysideCreateManyInsurersInputEnvelope = {
    data: causeofinjurysideCreateManyInsurersInput | causeofinjurysideCreateManyInsurersInput[]
    skipDuplicates?: boolean
  }

  export type causeofinjurywoundtypeCreateWithoutInsurersInput = {
    woundtypename: string
    woundtypecode?: string | null
  }

  export type causeofinjurywoundtypeUncheckedCreateWithoutInsurersInput = {
    id?: number
    woundtypename: string
    woundtypecode?: string | null
  }

  export type causeofinjurywoundtypeCreateOrConnectWithoutInsurersInput = {
    where: causeofinjurywoundtypeWhereUniqueInput
    create: XOR<causeofinjurywoundtypeCreateWithoutInsurersInput, causeofinjurywoundtypeUncheckedCreateWithoutInsurersInput>
  }

  export type causeofinjurywoundtypeCreateManyInsurersInputEnvelope = {
    data: causeofinjurywoundtypeCreateManyInsurersInput | causeofinjurywoundtypeCreateManyInsurersInput[]
    skipDuplicates?: boolean
  }

  export type claimantsCreateWithoutInsurersInput = {
    national_id?: string | null
    passportnumber?: string | null
    hn?: string | null
    patientid?: number | null
    title_th?: string | null
    givenname_th?: string | null
    surname_th?: string | null
    title_en?: string | null
    givenname_en?: string | null
    surname_en?: string | null
    mobilephone?: string | null
    statusactive?: boolean | null
    dateofbirth?: string | null
    gender?: string | null
    registrationdate?: Date | string | null
  }

  export type claimantsUncheckedCreateWithoutInsurersInput = {
    id?: number
    national_id?: string | null
    passportnumber?: string | null
    hn?: string | null
    patientid?: number | null
    title_th?: string | null
    givenname_th?: string | null
    surname_th?: string | null
    title_en?: string | null
    givenname_en?: string | null
    surname_en?: string | null
    mobilephone?: string | null
    statusactive?: boolean | null
    dateofbirth?: string | null
    gender?: string | null
    registrationdate?: Date | string | null
  }

  export type claimantsCreateOrConnectWithoutInsurersInput = {
    where: claimantsWhereUniqueInput
    create: XOR<claimantsCreateWithoutInsurersInput, claimantsUncheckedCreateWithoutInsurersInput>
  }

  export type claimantsCreateManyInsurersInputEnvelope = {
    data: claimantsCreateManyInsurersInput | claimantsCreateManyInsurersInput[]
    skipDuplicates?: boolean
  }

  export type claimdocumentsCreateWithoutInsurersInput = {
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    documentname?: string | null
    documenttypecode?: string | null
    documenttypename?: string | null
    serverpath?: string | null
    filepath: string
    filesize?: bigint | number | null
    filemimetype?: string | null
    uploaddate?: Date | string | null
    uploadedby?: string | null
  }

  export type claimdocumentsUncheckedCreateWithoutInsurersInput = {
    id?: number
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    documentname?: string | null
    documenttypecode?: string | null
    documenttypename?: string | null
    serverpath?: string | null
    filepath: string
    filesize?: bigint | number | null
    filemimetype?: string | null
    uploaddate?: Date | string | null
    uploadedby?: string | null
  }

  export type claimdocumentsCreateOrConnectWithoutInsurersInput = {
    where: claimdocumentsWhereUniqueInput
    create: XOR<claimdocumentsCreateWithoutInsurersInput, claimdocumentsUncheckedCreateWithoutInsurersInput>
  }

  export type claimdocumentsCreateManyInsurersInputEnvelope = {
    data: claimdocumentsCreateManyInsurersInput | claimdocumentsCreateManyInsurersInput[]
    skipDuplicates?: boolean
  }

  export type claimstatusCreateWithoutInsurersInput = {
    claimstatuscode: string
    claimstatusdesc_th?: string | null
    claimstatusdesc_en?: string | null
    transactionclaimstatus?: transactionclaimstatusCreateNestedManyWithoutClaimstatusInput
  }

  export type claimstatusUncheckedCreateWithoutInsurersInput = {
    id?: number
    claimstatuscode: string
    claimstatusdesc_th?: string | null
    claimstatusdesc_en?: string | null
    transactionclaimstatus?: transactionclaimstatusUncheckedCreateNestedManyWithoutClaimstatusInput
  }

  export type claimstatusCreateOrConnectWithoutInsurersInput = {
    where: claimstatusWhereUniqueInput
    create: XOR<claimstatusCreateWithoutInsurersInput, claimstatusUncheckedCreateWithoutInsurersInput>
  }

  export type claimstatusCreateManyInsurersInputEnvelope = {
    data: claimstatusCreateManyInsurersInput | claimstatusCreateManyInsurersInput[]
    skipDuplicates?: boolean
  }

  export type diagnosistypemappingCreateWithoutInsurersInput = {
    dxtypecodetrakcare: string
    dxtypenametrakcare?: string | null
    dxtypecodeinsurance?: string | null
    dxtypenameinsurance?: string | null
  }

  export type diagnosistypemappingUncheckedCreateWithoutInsurersInput = {
    id?: number
    dxtypecodetrakcare: string
    dxtypenametrakcare?: string | null
    dxtypecodeinsurance?: string | null
    dxtypenameinsurance?: string | null
  }

  export type diagnosistypemappingCreateOrConnectWithoutInsurersInput = {
    where: diagnosistypemappingWhereUniqueInput
    create: XOR<diagnosistypemappingCreateWithoutInsurersInput, diagnosistypemappingUncheckedCreateWithoutInsurersInput>
  }

  export type diagnosistypemappingCreateManyInsurersInputEnvelope = {
    data: diagnosistypemappingCreateManyInsurersInput | diagnosistypemappingCreateManyInsurersInput[]
    skipDuplicates?: boolean
  }

  export type documenttypeCreateWithoutInsurersInput = {
    documenttypecode: string
    documenttypename?: string | null
  }

  export type documenttypeUncheckedCreateWithoutInsurersInput = {
    id?: number
    documenttypecode: string
    documenttypename?: string | null
  }

  export type documenttypeCreateOrConnectWithoutInsurersInput = {
    where: documenttypeWhereUniqueInput
    create: XOR<documenttypeCreateWithoutInsurersInput, documenttypeUncheckedCreateWithoutInsurersInput>
  }

  export type documenttypeCreateManyInsurersInputEnvelope = {
    data: documenttypeCreateManyInsurersInput | documenttypeCreateManyInsurersInput[]
    skipDuplicates?: boolean
  }

  export type illnesssurgeryCreateWithoutInsurersInput = {
    iscode: string
    isdesc?: string | null
  }

  export type illnesssurgeryUncheckedCreateWithoutInsurersInput = {
    id?: number
    iscode: string
    isdesc?: string | null
  }

  export type illnesssurgeryCreateOrConnectWithoutInsurersInput = {
    where: illnesssurgeryWhereUniqueInput
    create: XOR<illnesssurgeryCreateWithoutInsurersInput, illnesssurgeryUncheckedCreateWithoutInsurersInput>
  }

  export type illnesssurgeryCreateManyInsurersInputEnvelope = {
    data: illnesssurgeryCreateManyInsurersInput | illnesssurgeryCreateManyInsurersInput[]
    skipDuplicates?: boolean
  }

  export type illnesstypeCreateWithoutInsurersInput = {
    illnesstypecode: string
    illnesstypedesc?: string | null
  }

  export type illnesstypeUncheckedCreateWithoutInsurersInput = {
    id?: number
    illnesstypecode: string
    illnesstypedesc?: string | null
  }

  export type illnesstypeCreateOrConnectWithoutInsurersInput = {
    where: illnesstypeWhereUniqueInput
    create: XOR<illnesstypeCreateWithoutInsurersInput, illnesstypeUncheckedCreateWithoutInsurersInput>
  }

  export type illnesstypeCreateManyInsurersInputEnvelope = {
    data: illnesstypeCreateManyInsurersInput | illnesstypeCreateManyInsurersInput[]
    skipDuplicates?: boolean
  }

  export type policytypeCreateWithoutInsurersInput = {
    policytypecode: string
    policytypedesc?: string | null
  }

  export type policytypeUncheckedCreateWithoutInsurersInput = {
    id?: number
    policytypecode: string
    policytypedesc?: string | null
  }

  export type policytypeCreateOrConnectWithoutInsurersInput = {
    where: policytypeWhereUniqueInput
    create: XOR<policytypeCreateWithoutInsurersInput, policytypeUncheckedCreateWithoutInsurersInput>
  }

  export type policytypeCreateManyInsurersInputEnvelope = {
    data: policytypeCreateManyInsurersInput | policytypeCreateManyInsurersInput[]
    skipDuplicates?: boolean
  }

  export type proceduretransactionsCreateWithoutInsurersInput = {
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    icd9?: string | null
    procedurename?: string | null
    proceduredate?: string | null
  }

  export type proceduretransactionsUncheckedCreateWithoutInsurersInput = {
    id?: number
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    icd9?: string | null
    procedurename?: string | null
    proceduredate?: string | null
  }

  export type proceduretransactionsCreateOrConnectWithoutInsurersInput = {
    where: proceduretransactionsWhereUniqueInput
    create: XOR<proceduretransactionsCreateWithoutInsurersInput, proceduretransactionsUncheckedCreateWithoutInsurersInput>
  }

  export type proceduretransactionsCreateManyInsurersInputEnvelope = {
    data: proceduretransactionsCreateManyInsurersInput | proceduretransactionsCreateManyInsurersInput[]
    skipDuplicates?: boolean
  }

  export type servicesettingCreateWithoutInsurersInput = {
    servicesettingcode: string
    servicesettingdesc: string
  }

  export type servicesettingUncheckedCreateWithoutInsurersInput = {
    id?: number
    servicesettingcode: string
    servicesettingdesc: string
  }

  export type servicesettingCreateOrConnectWithoutInsurersInput = {
    where: servicesettingWhereUniqueInput
    create: XOR<servicesettingCreateWithoutInsurersInput, servicesettingUncheckedCreateWithoutInsurersInput>
  }

  export type servicesettingCreateManyInsurersInputEnvelope = {
    data: servicesettingCreateManyInsurersInput | servicesettingCreateManyInsurersInput[]
    skipDuplicates?: boolean
  }

  export type accidentcauseover45daysUpsertWithWhereUniqueWithoutInsurersInput = {
    where: accidentcauseover45daysWhereUniqueInput
    update: XOR<accidentcauseover45daysUpdateWithoutInsurersInput, accidentcauseover45daysUncheckedUpdateWithoutInsurersInput>
    create: XOR<accidentcauseover45daysCreateWithoutInsurersInput, accidentcauseover45daysUncheckedCreateWithoutInsurersInput>
  }

  export type accidentcauseover45daysUpdateWithWhereUniqueWithoutInsurersInput = {
    where: accidentcauseover45daysWhereUniqueInput
    data: XOR<accidentcauseover45daysUpdateWithoutInsurersInput, accidentcauseover45daysUncheckedUpdateWithoutInsurersInput>
  }

  export type accidentcauseover45daysUpdateManyWithWhereWithoutInsurersInput = {
    where: accidentcauseover45daysScalarWhereInput
    data: XOR<accidentcauseover45daysUpdateManyMutationInput, accidentcauseover45daysUncheckedUpdateManyWithoutInsurersInput>
  }

  export type accidentcauseover45daysScalarWhereInput = {
    AND?: accidentcauseover45daysScalarWhereInput | accidentcauseover45daysScalarWhereInput[]
    OR?: accidentcauseover45daysScalarWhereInput[]
    NOT?: accidentcauseover45daysScalarWhereInput | accidentcauseover45daysScalarWhereInput[]
    id?: IntFilter<"accidentcauseover45days"> | number
    causeovercode?: StringFilter<"accidentcauseover45days"> | string
    causeoverdesc?: StringNullableFilter<"accidentcauseover45days"> | string | null
    insurerid?: IntNullableFilter<"accidentcauseover45days"> | number | null
  }

  export type accidentplaceUpsertWithWhereUniqueWithoutInsurersInput = {
    where: accidentplaceWhereUniqueInput
    update: XOR<accidentplaceUpdateWithoutInsurersInput, accidentplaceUncheckedUpdateWithoutInsurersInput>
    create: XOR<accidentplaceCreateWithoutInsurersInput, accidentplaceUncheckedCreateWithoutInsurersInput>
  }

  export type accidentplaceUpdateWithWhereUniqueWithoutInsurersInput = {
    where: accidentplaceWhereUniqueInput
    data: XOR<accidentplaceUpdateWithoutInsurersInput, accidentplaceUncheckedUpdateWithoutInsurersInput>
  }

  export type accidentplaceUpdateManyWithWhereWithoutInsurersInput = {
    where: accidentplaceScalarWhereInput
    data: XOR<accidentplaceUpdateManyMutationInput, accidentplaceUncheckedUpdateManyWithoutInsurersInput>
  }

  export type accidentplaceScalarWhereInput = {
    AND?: accidentplaceScalarWhereInput | accidentplaceScalarWhereInput[]
    OR?: accidentplaceScalarWhereInput[]
    NOT?: accidentplaceScalarWhereInput | accidentplaceScalarWhereInput[]
    id?: IntFilter<"accidentplace"> | number
    accidentplacecode?: StringFilter<"accidentplace"> | string
    accidentplacename?: StringNullableFilter<"accidentplace"> | string | null
    insurerid?: IntNullableFilter<"accidentplace"> | number | null
  }

  export type accidenttransactionsUpsertWithWhereUniqueWithoutInsurersInput = {
    where: accidenttransactionsWhereUniqueInput
    update: XOR<accidenttransactionsUpdateWithoutInsurersInput, accidenttransactionsUncheckedUpdateWithoutInsurersInput>
    create: XOR<accidenttransactionsCreateWithoutInsurersInput, accidenttransactionsUncheckedCreateWithoutInsurersInput>
  }

  export type accidenttransactionsUpdateWithWhereUniqueWithoutInsurersInput = {
    where: accidenttransactionsWhereUniqueInput
    data: XOR<accidenttransactionsUpdateWithoutInsurersInput, accidenttransactionsUncheckedUpdateWithoutInsurersInput>
  }

  export type accidenttransactionsUpdateManyWithWhereWithoutInsurersInput = {
    where: accidenttransactionsScalarWhereInput
    data: XOR<accidenttransactionsUpdateManyMutationInput, accidenttransactionsUncheckedUpdateManyWithoutInsurersInput>
  }

  export type accidenttransactionsScalarWhereInput = {
    AND?: accidenttransactionsScalarWhereInput | accidenttransactionsScalarWhereInput[]
    OR?: accidenttransactionsScalarWhereInput[]
    NOT?: accidenttransactionsScalarWhereInput | accidenttransactionsScalarWhereInput[]
    id?: IntFilter<"accidenttransactions"> | number
    insurerid?: IntNullableFilter<"accidenttransactions"> | number | null
    refid?: StringNullableFilter<"accidenttransactions"> | string | null
    transactionno?: StringNullableFilter<"accidenttransactions"> | string | null
    hn?: StringNullableFilter<"accidenttransactions"> | string | null
    vn?: StringNullableFilter<"accidenttransactions"> | string | null
    accidentplace?: StringNullableFilter<"accidenttransactions"> | string | null
    accidentdate?: StringNullableFilter<"accidenttransactions"> | string | null
  }

  export type accidenttransactions22UpsertWithWhereUniqueWithoutInsurersInput = {
    where: accidenttransactions22WhereUniqueInput
    update: XOR<accidenttransactions22UpdateWithoutInsurersInput, accidenttransactions22UncheckedUpdateWithoutInsurersInput>
    create: XOR<accidenttransactions22CreateWithoutInsurersInput, accidenttransactions22UncheckedCreateWithoutInsurersInput>
  }

  export type accidenttransactions22UpdateWithWhereUniqueWithoutInsurersInput = {
    where: accidenttransactions22WhereUniqueInput
    data: XOR<accidenttransactions22UpdateWithoutInsurersInput, accidenttransactions22UncheckedUpdateWithoutInsurersInput>
  }

  export type accidenttransactions22UpdateManyWithWhereWithoutInsurersInput = {
    where: accidenttransactions22ScalarWhereInput
    data: XOR<accidenttransactions22UpdateManyMutationInput, accidenttransactions22UncheckedUpdateManyWithoutInsurersInput>
  }

  export type accidenttransactions22ScalarWhereInput = {
    AND?: accidenttransactions22ScalarWhereInput | accidenttransactions22ScalarWhereInput[]
    OR?: accidenttransactions22ScalarWhereInput[]
    NOT?: accidenttransactions22ScalarWhereInput | accidenttransactions22ScalarWhereInput[]
    id?: IntFilter<"accidenttransactions22"> | number
    insurerid?: IntNullableFilter<"accidenttransactions22"> | number | null
    refid?: StringNullableFilter<"accidenttransactions22"> | string | null
    transactionno?: StringNullableFilter<"accidenttransactions22"> | string | null
    hn?: StringNullableFilter<"accidenttransactions22"> | string | null
    vn?: StringNullableFilter<"accidenttransactions22"> | string | null
    accidentplace?: StringNullableFilter<"accidenttransactions22"> | string | null
    accidentdate?: StringNullableFilter<"accidenttransactions22"> | string | null
    causeofinjury?: StringNullableFilter<"accidenttransactions22"> | string | null
    commentofinjury?: StringNullableFilter<"accidenttransactions22"> | string | null
    woundtype?: StringNullableFilter<"accidenttransactions22"> | string | null
    injuryside?: StringNullableFilter<"accidenttransactions22"> | string | null
    injuryarea?: StringNullableFilter<"accidenttransactions22"> | string | null
  }

  export type causeofinjurysideUpsertWithWhereUniqueWithoutInsurersInput = {
    where: causeofinjurysideWhereUniqueInput
    update: XOR<causeofinjurysideUpdateWithoutInsurersInput, causeofinjurysideUncheckedUpdateWithoutInsurersInput>
    create: XOR<causeofinjurysideCreateWithoutInsurersInput, causeofinjurysideUncheckedCreateWithoutInsurersInput>
  }

  export type causeofinjurysideUpdateWithWhereUniqueWithoutInsurersInput = {
    where: causeofinjurysideWhereUniqueInput
    data: XOR<causeofinjurysideUpdateWithoutInsurersInput, causeofinjurysideUncheckedUpdateWithoutInsurersInput>
  }

  export type causeofinjurysideUpdateManyWithWhereWithoutInsurersInput = {
    where: causeofinjurysideScalarWhereInput
    data: XOR<causeofinjurysideUpdateManyMutationInput, causeofinjurysideUncheckedUpdateManyWithoutInsurersInput>
  }

  export type causeofinjurysideScalarWhereInput = {
    AND?: causeofinjurysideScalarWhereInput | causeofinjurysideScalarWhereInput[]
    OR?: causeofinjurysideScalarWhereInput[]
    NOT?: causeofinjurysideScalarWhereInput | causeofinjurysideScalarWhereInput[]
    id?: IntFilter<"causeofinjuryside"> | number
    injurysidename?: StringFilter<"causeofinjuryside"> | string
    injurysidecode?: StringNullableFilter<"causeofinjuryside"> | string | null
    insurerid?: IntNullableFilter<"causeofinjuryside"> | number | null
  }

  export type causeofinjurywoundtypeUpsertWithWhereUniqueWithoutInsurersInput = {
    where: causeofinjurywoundtypeWhereUniqueInput
    update: XOR<causeofinjurywoundtypeUpdateWithoutInsurersInput, causeofinjurywoundtypeUncheckedUpdateWithoutInsurersInput>
    create: XOR<causeofinjurywoundtypeCreateWithoutInsurersInput, causeofinjurywoundtypeUncheckedCreateWithoutInsurersInput>
  }

  export type causeofinjurywoundtypeUpdateWithWhereUniqueWithoutInsurersInput = {
    where: causeofinjurywoundtypeWhereUniqueInput
    data: XOR<causeofinjurywoundtypeUpdateWithoutInsurersInput, causeofinjurywoundtypeUncheckedUpdateWithoutInsurersInput>
  }

  export type causeofinjurywoundtypeUpdateManyWithWhereWithoutInsurersInput = {
    where: causeofinjurywoundtypeScalarWhereInput
    data: XOR<causeofinjurywoundtypeUpdateManyMutationInput, causeofinjurywoundtypeUncheckedUpdateManyWithoutInsurersInput>
  }

  export type causeofinjurywoundtypeScalarWhereInput = {
    AND?: causeofinjurywoundtypeScalarWhereInput | causeofinjurywoundtypeScalarWhereInput[]
    OR?: causeofinjurywoundtypeScalarWhereInput[]
    NOT?: causeofinjurywoundtypeScalarWhereInput | causeofinjurywoundtypeScalarWhereInput[]
    id?: IntFilter<"causeofinjurywoundtype"> | number
    woundtypename?: StringFilter<"causeofinjurywoundtype"> | string
    woundtypecode?: StringNullableFilter<"causeofinjurywoundtype"> | string | null
    insurerid?: IntNullableFilter<"causeofinjurywoundtype"> | number | null
  }

  export type claimantsUpsertWithWhereUniqueWithoutInsurersInput = {
    where: claimantsWhereUniqueInput
    update: XOR<claimantsUpdateWithoutInsurersInput, claimantsUncheckedUpdateWithoutInsurersInput>
    create: XOR<claimantsCreateWithoutInsurersInput, claimantsUncheckedCreateWithoutInsurersInput>
  }

  export type claimantsUpdateWithWhereUniqueWithoutInsurersInput = {
    where: claimantsWhereUniqueInput
    data: XOR<claimantsUpdateWithoutInsurersInput, claimantsUncheckedUpdateWithoutInsurersInput>
  }

  export type claimantsUpdateManyWithWhereWithoutInsurersInput = {
    where: claimantsScalarWhereInput
    data: XOR<claimantsUpdateManyMutationInput, claimantsUncheckedUpdateManyWithoutInsurersInput>
  }

  export type claimantsScalarWhereInput = {
    AND?: claimantsScalarWhereInput | claimantsScalarWhereInput[]
    OR?: claimantsScalarWhereInput[]
    NOT?: claimantsScalarWhereInput | claimantsScalarWhereInput[]
    id?: IntFilter<"claimants"> | number
    national_id?: StringNullableFilter<"claimants"> | string | null
    passportnumber?: StringNullableFilter<"claimants"> | string | null
    hn?: StringNullableFilter<"claimants"> | string | null
    patientid?: IntNullableFilter<"claimants"> | number | null
    title_th?: StringNullableFilter<"claimants"> | string | null
    givenname_th?: StringNullableFilter<"claimants"> | string | null
    surname_th?: StringNullableFilter<"claimants"> | string | null
    title_en?: StringNullableFilter<"claimants"> | string | null
    givenname_en?: StringNullableFilter<"claimants"> | string | null
    surname_en?: StringNullableFilter<"claimants"> | string | null
    mobilephone?: StringNullableFilter<"claimants"> | string | null
    statusactive?: BoolNullableFilter<"claimants"> | boolean | null
    dateofbirth?: StringNullableFilter<"claimants"> | string | null
    gender?: StringNullableFilter<"claimants"> | string | null
    registrationdate?: DateTimeNullableFilter<"claimants"> | Date | string | null
    insurerid?: IntNullableFilter<"claimants"> | number | null
  }

  export type claimdocumentsUpsertWithWhereUniqueWithoutInsurersInput = {
    where: claimdocumentsWhereUniqueInput
    update: XOR<claimdocumentsUpdateWithoutInsurersInput, claimdocumentsUncheckedUpdateWithoutInsurersInput>
    create: XOR<claimdocumentsCreateWithoutInsurersInput, claimdocumentsUncheckedCreateWithoutInsurersInput>
  }

  export type claimdocumentsUpdateWithWhereUniqueWithoutInsurersInput = {
    where: claimdocumentsWhereUniqueInput
    data: XOR<claimdocumentsUpdateWithoutInsurersInput, claimdocumentsUncheckedUpdateWithoutInsurersInput>
  }

  export type claimdocumentsUpdateManyWithWhereWithoutInsurersInput = {
    where: claimdocumentsScalarWhereInput
    data: XOR<claimdocumentsUpdateManyMutationInput, claimdocumentsUncheckedUpdateManyWithoutInsurersInput>
  }

  export type claimdocumentsScalarWhereInput = {
    AND?: claimdocumentsScalarWhereInput | claimdocumentsScalarWhereInput[]
    OR?: claimdocumentsScalarWhereInput[]
    NOT?: claimdocumentsScalarWhereInput | claimdocumentsScalarWhereInput[]
    id?: IntFilter<"claimdocuments"> | number
    insurerid?: IntNullableFilter<"claimdocuments"> | number | null
    refid?: StringNullableFilter<"claimdocuments"> | string | null
    transactionno?: StringNullableFilter<"claimdocuments"> | string | null
    hn?: StringNullableFilter<"claimdocuments"> | string | null
    vn?: StringNullableFilter<"claimdocuments"> | string | null
    documentname?: StringNullableFilter<"claimdocuments"> | string | null
    documenttypecode?: StringNullableFilter<"claimdocuments"> | string | null
    documenttypename?: StringNullableFilter<"claimdocuments"> | string | null
    serverpath?: StringNullableFilter<"claimdocuments"> | string | null
    filepath?: StringFilter<"claimdocuments"> | string
    filesize?: BigIntNullableFilter<"claimdocuments"> | bigint | number | null
    filemimetype?: StringNullableFilter<"claimdocuments"> | string | null
    uploaddate?: DateTimeNullableFilter<"claimdocuments"> | Date | string | null
    uploadedby?: StringNullableFilter<"claimdocuments"> | string | null
  }

  export type claimstatusUpsertWithWhereUniqueWithoutInsurersInput = {
    where: claimstatusWhereUniqueInput
    update: XOR<claimstatusUpdateWithoutInsurersInput, claimstatusUncheckedUpdateWithoutInsurersInput>
    create: XOR<claimstatusCreateWithoutInsurersInput, claimstatusUncheckedCreateWithoutInsurersInput>
  }

  export type claimstatusUpdateWithWhereUniqueWithoutInsurersInput = {
    where: claimstatusWhereUniqueInput
    data: XOR<claimstatusUpdateWithoutInsurersInput, claimstatusUncheckedUpdateWithoutInsurersInput>
  }

  export type claimstatusUpdateManyWithWhereWithoutInsurersInput = {
    where: claimstatusScalarWhereInput
    data: XOR<claimstatusUpdateManyMutationInput, claimstatusUncheckedUpdateManyWithoutInsurersInput>
  }

  export type claimstatusScalarWhereInput = {
    AND?: claimstatusScalarWhereInput | claimstatusScalarWhereInput[]
    OR?: claimstatusScalarWhereInput[]
    NOT?: claimstatusScalarWhereInput | claimstatusScalarWhereInput[]
    id?: IntFilter<"claimstatus"> | number
    claimstatuscode?: StringFilter<"claimstatus"> | string
    claimstatusdesc_th?: StringNullableFilter<"claimstatus"> | string | null
    claimstatusdesc_en?: StringNullableFilter<"claimstatus"> | string | null
    insurerid?: IntNullableFilter<"claimstatus"> | number | null
  }

  export type diagnosistypemappingUpsertWithWhereUniqueWithoutInsurersInput = {
    where: diagnosistypemappingWhereUniqueInput
    update: XOR<diagnosistypemappingUpdateWithoutInsurersInput, diagnosistypemappingUncheckedUpdateWithoutInsurersInput>
    create: XOR<diagnosistypemappingCreateWithoutInsurersInput, diagnosistypemappingUncheckedCreateWithoutInsurersInput>
  }

  export type diagnosistypemappingUpdateWithWhereUniqueWithoutInsurersInput = {
    where: diagnosistypemappingWhereUniqueInput
    data: XOR<diagnosistypemappingUpdateWithoutInsurersInput, diagnosistypemappingUncheckedUpdateWithoutInsurersInput>
  }

  export type diagnosistypemappingUpdateManyWithWhereWithoutInsurersInput = {
    where: diagnosistypemappingScalarWhereInput
    data: XOR<diagnosistypemappingUpdateManyMutationInput, diagnosistypemappingUncheckedUpdateManyWithoutInsurersInput>
  }

  export type diagnosistypemappingScalarWhereInput = {
    AND?: diagnosistypemappingScalarWhereInput | diagnosistypemappingScalarWhereInput[]
    OR?: diagnosistypemappingScalarWhereInput[]
    NOT?: diagnosistypemappingScalarWhereInput | diagnosistypemappingScalarWhereInput[]
    id?: IntFilter<"diagnosistypemapping"> | number
    dxtypecodetrakcare?: StringFilter<"diagnosistypemapping"> | string
    dxtypenametrakcare?: StringNullableFilter<"diagnosistypemapping"> | string | null
    dxtypecodeinsurance?: StringNullableFilter<"diagnosistypemapping"> | string | null
    dxtypenameinsurance?: StringNullableFilter<"diagnosistypemapping"> | string | null
    insurerid?: IntNullableFilter<"diagnosistypemapping"> | number | null
  }

  export type documenttypeUpsertWithWhereUniqueWithoutInsurersInput = {
    where: documenttypeWhereUniqueInput
    update: XOR<documenttypeUpdateWithoutInsurersInput, documenttypeUncheckedUpdateWithoutInsurersInput>
    create: XOR<documenttypeCreateWithoutInsurersInput, documenttypeUncheckedCreateWithoutInsurersInput>
  }

  export type documenttypeUpdateWithWhereUniqueWithoutInsurersInput = {
    where: documenttypeWhereUniqueInput
    data: XOR<documenttypeUpdateWithoutInsurersInput, documenttypeUncheckedUpdateWithoutInsurersInput>
  }

  export type documenttypeUpdateManyWithWhereWithoutInsurersInput = {
    where: documenttypeScalarWhereInput
    data: XOR<documenttypeUpdateManyMutationInput, documenttypeUncheckedUpdateManyWithoutInsurersInput>
  }

  export type documenttypeScalarWhereInput = {
    AND?: documenttypeScalarWhereInput | documenttypeScalarWhereInput[]
    OR?: documenttypeScalarWhereInput[]
    NOT?: documenttypeScalarWhereInput | documenttypeScalarWhereInput[]
    id?: IntFilter<"documenttype"> | number
    documenttypecode?: StringFilter<"documenttype"> | string
    documenttypename?: StringNullableFilter<"documenttype"> | string | null
    insurerid?: IntNullableFilter<"documenttype"> | number | null
  }

  export type illnesssurgeryUpsertWithWhereUniqueWithoutInsurersInput = {
    where: illnesssurgeryWhereUniqueInput
    update: XOR<illnesssurgeryUpdateWithoutInsurersInput, illnesssurgeryUncheckedUpdateWithoutInsurersInput>
    create: XOR<illnesssurgeryCreateWithoutInsurersInput, illnesssurgeryUncheckedCreateWithoutInsurersInput>
  }

  export type illnesssurgeryUpdateWithWhereUniqueWithoutInsurersInput = {
    where: illnesssurgeryWhereUniqueInput
    data: XOR<illnesssurgeryUpdateWithoutInsurersInput, illnesssurgeryUncheckedUpdateWithoutInsurersInput>
  }

  export type illnesssurgeryUpdateManyWithWhereWithoutInsurersInput = {
    where: illnesssurgeryScalarWhereInput
    data: XOR<illnesssurgeryUpdateManyMutationInput, illnesssurgeryUncheckedUpdateManyWithoutInsurersInput>
  }

  export type illnesssurgeryScalarWhereInput = {
    AND?: illnesssurgeryScalarWhereInput | illnesssurgeryScalarWhereInput[]
    OR?: illnesssurgeryScalarWhereInput[]
    NOT?: illnesssurgeryScalarWhereInput | illnesssurgeryScalarWhereInput[]
    id?: IntFilter<"illnesssurgery"> | number
    iscode?: StringFilter<"illnesssurgery"> | string
    isdesc?: StringNullableFilter<"illnesssurgery"> | string | null
    insurerid?: IntNullableFilter<"illnesssurgery"> | number | null
  }

  export type illnesstypeUpsertWithWhereUniqueWithoutInsurersInput = {
    where: illnesstypeWhereUniqueInput
    update: XOR<illnesstypeUpdateWithoutInsurersInput, illnesstypeUncheckedUpdateWithoutInsurersInput>
    create: XOR<illnesstypeCreateWithoutInsurersInput, illnesstypeUncheckedCreateWithoutInsurersInput>
  }

  export type illnesstypeUpdateWithWhereUniqueWithoutInsurersInput = {
    where: illnesstypeWhereUniqueInput
    data: XOR<illnesstypeUpdateWithoutInsurersInput, illnesstypeUncheckedUpdateWithoutInsurersInput>
  }

  export type illnesstypeUpdateManyWithWhereWithoutInsurersInput = {
    where: illnesstypeScalarWhereInput
    data: XOR<illnesstypeUpdateManyMutationInput, illnesstypeUncheckedUpdateManyWithoutInsurersInput>
  }

  export type illnesstypeScalarWhereInput = {
    AND?: illnesstypeScalarWhereInput | illnesstypeScalarWhereInput[]
    OR?: illnesstypeScalarWhereInput[]
    NOT?: illnesstypeScalarWhereInput | illnesstypeScalarWhereInput[]
    id?: IntFilter<"illnesstype"> | number
    illnesstypecode?: StringFilter<"illnesstype"> | string
    illnesstypedesc?: StringNullableFilter<"illnesstype"> | string | null
    insurerid?: IntNullableFilter<"illnesstype"> | number | null
  }

  export type policytypeUpsertWithWhereUniqueWithoutInsurersInput = {
    where: policytypeWhereUniqueInput
    update: XOR<policytypeUpdateWithoutInsurersInput, policytypeUncheckedUpdateWithoutInsurersInput>
    create: XOR<policytypeCreateWithoutInsurersInput, policytypeUncheckedCreateWithoutInsurersInput>
  }

  export type policytypeUpdateWithWhereUniqueWithoutInsurersInput = {
    where: policytypeWhereUniqueInput
    data: XOR<policytypeUpdateWithoutInsurersInput, policytypeUncheckedUpdateWithoutInsurersInput>
  }

  export type policytypeUpdateManyWithWhereWithoutInsurersInput = {
    where: policytypeScalarWhereInput
    data: XOR<policytypeUpdateManyMutationInput, policytypeUncheckedUpdateManyWithoutInsurersInput>
  }

  export type policytypeScalarWhereInput = {
    AND?: policytypeScalarWhereInput | policytypeScalarWhereInput[]
    OR?: policytypeScalarWhereInput[]
    NOT?: policytypeScalarWhereInput | policytypeScalarWhereInput[]
    id?: IntFilter<"policytype"> | number
    policytypecode?: StringFilter<"policytype"> | string
    policytypedesc?: StringNullableFilter<"policytype"> | string | null
    insurerid?: IntNullableFilter<"policytype"> | number | null
  }

  export type proceduretransactionsUpsertWithWhereUniqueWithoutInsurersInput = {
    where: proceduretransactionsWhereUniqueInput
    update: XOR<proceduretransactionsUpdateWithoutInsurersInput, proceduretransactionsUncheckedUpdateWithoutInsurersInput>
    create: XOR<proceduretransactionsCreateWithoutInsurersInput, proceduretransactionsUncheckedCreateWithoutInsurersInput>
  }

  export type proceduretransactionsUpdateWithWhereUniqueWithoutInsurersInput = {
    where: proceduretransactionsWhereUniqueInput
    data: XOR<proceduretransactionsUpdateWithoutInsurersInput, proceduretransactionsUncheckedUpdateWithoutInsurersInput>
  }

  export type proceduretransactionsUpdateManyWithWhereWithoutInsurersInput = {
    where: proceduretransactionsScalarWhereInput
    data: XOR<proceduretransactionsUpdateManyMutationInput, proceduretransactionsUncheckedUpdateManyWithoutInsurersInput>
  }

  export type proceduretransactionsScalarWhereInput = {
    AND?: proceduretransactionsScalarWhereInput | proceduretransactionsScalarWhereInput[]
    OR?: proceduretransactionsScalarWhereInput[]
    NOT?: proceduretransactionsScalarWhereInput | proceduretransactionsScalarWhereInput[]
    id?: IntFilter<"proceduretransactions"> | number
    insurerid?: IntNullableFilter<"proceduretransactions"> | number | null
    refid?: StringNullableFilter<"proceduretransactions"> | string | null
    transactionno?: StringNullableFilter<"proceduretransactions"> | string | null
    hn?: StringNullableFilter<"proceduretransactions"> | string | null
    vn?: StringNullableFilter<"proceduretransactions"> | string | null
    icd9?: StringNullableFilter<"proceduretransactions"> | string | null
    procedurename?: StringNullableFilter<"proceduretransactions"> | string | null
    proceduredate?: StringNullableFilter<"proceduretransactions"> | string | null
  }

  export type servicesettingUpsertWithWhereUniqueWithoutInsurersInput = {
    where: servicesettingWhereUniqueInput
    update: XOR<servicesettingUpdateWithoutInsurersInput, servicesettingUncheckedUpdateWithoutInsurersInput>
    create: XOR<servicesettingCreateWithoutInsurersInput, servicesettingUncheckedCreateWithoutInsurersInput>
  }

  export type servicesettingUpdateWithWhereUniqueWithoutInsurersInput = {
    where: servicesettingWhereUniqueInput
    data: XOR<servicesettingUpdateWithoutInsurersInput, servicesettingUncheckedUpdateWithoutInsurersInput>
  }

  export type servicesettingUpdateManyWithWhereWithoutInsurersInput = {
    where: servicesettingScalarWhereInput
    data: XOR<servicesettingUpdateManyMutationInput, servicesettingUncheckedUpdateManyWithoutInsurersInput>
  }

  export type servicesettingScalarWhereInput = {
    AND?: servicesettingScalarWhereInput | servicesettingScalarWhereInput[]
    OR?: servicesettingScalarWhereInput[]
    NOT?: servicesettingScalarWhereInput | servicesettingScalarWhereInput[]
    id?: IntFilter<"servicesetting"> | number
    servicesettingcode?: StringFilter<"servicesetting"> | string
    servicesettingdesc?: StringFilter<"servicesetting"> | string
    insurerid?: IntNullableFilter<"servicesetting"> | number | null
  }

  export type insurersCreateWithoutPolicytypeInput = {
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentcauseover45days?: accidentcauseover45daysCreateNestedManyWithoutInsurersInput
    accidentplace?: accidentplaceCreateNestedManyWithoutInsurersInput
    accidenttransactions?: accidenttransactionsCreateNestedManyWithoutInsurersInput
    accidenttransactions22?: accidenttransactions22CreateNestedManyWithoutInsurersInput
    causeofinjuryside?: causeofinjurysideCreateNestedManyWithoutInsurersInput
    causeofinjurywoundtype?: causeofinjurywoundtypeCreateNestedManyWithoutInsurersInput
    claimants?: claimantsCreateNestedManyWithoutInsurersInput
    claimdocuments?: claimdocumentsCreateNestedManyWithoutInsurersInput
    claimstatus?: claimstatusCreateNestedManyWithoutInsurersInput
    diagnosistypemapping?: diagnosistypemappingCreateNestedManyWithoutInsurersInput
    documenttype?: documenttypeCreateNestedManyWithoutInsurersInput
    illnesssurgery?: illnesssurgeryCreateNestedManyWithoutInsurersInput
    illnesstype?: illnesstypeCreateNestedManyWithoutInsurersInput
    proceduretransactions?: proceduretransactionsCreateNestedManyWithoutInsurersInput
    servicesetting?: servicesettingCreateNestedManyWithoutInsurersInput
  }

  export type insurersUncheckedCreateWithoutPolicytypeInput = {
    id?: number
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentcauseover45days?: accidentcauseover45daysUncheckedCreateNestedManyWithoutInsurersInput
    accidentplace?: accidentplaceUncheckedCreateNestedManyWithoutInsurersInput
    accidenttransactions?: accidenttransactionsUncheckedCreateNestedManyWithoutInsurersInput
    accidenttransactions22?: accidenttransactions22UncheckedCreateNestedManyWithoutInsurersInput
    causeofinjuryside?: causeofinjurysideUncheckedCreateNestedManyWithoutInsurersInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUncheckedCreateNestedManyWithoutInsurersInput
    claimants?: claimantsUncheckedCreateNestedManyWithoutInsurersInput
    claimdocuments?: claimdocumentsUncheckedCreateNestedManyWithoutInsurersInput
    claimstatus?: claimstatusUncheckedCreateNestedManyWithoutInsurersInput
    diagnosistypemapping?: diagnosistypemappingUncheckedCreateNestedManyWithoutInsurersInput
    documenttype?: documenttypeUncheckedCreateNestedManyWithoutInsurersInput
    illnesssurgery?: illnesssurgeryUncheckedCreateNestedManyWithoutInsurersInput
    illnesstype?: illnesstypeUncheckedCreateNestedManyWithoutInsurersInput
    proceduretransactions?: proceduretransactionsUncheckedCreateNestedManyWithoutInsurersInput
    servicesetting?: servicesettingUncheckedCreateNestedManyWithoutInsurersInput
  }

  export type insurersCreateOrConnectWithoutPolicytypeInput = {
    where: insurersWhereUniqueInput
    create: XOR<insurersCreateWithoutPolicytypeInput, insurersUncheckedCreateWithoutPolicytypeInput>
  }

  export type insurersUpsertWithoutPolicytypeInput = {
    update: XOR<insurersUpdateWithoutPolicytypeInput, insurersUncheckedUpdateWithoutPolicytypeInput>
    create: XOR<insurersCreateWithoutPolicytypeInput, insurersUncheckedCreateWithoutPolicytypeInput>
    where?: insurersWhereInput
  }

  export type insurersUpdateToOneWithWhereWithoutPolicytypeInput = {
    where?: insurersWhereInput
    data: XOR<insurersUpdateWithoutPolicytypeInput, insurersUncheckedUpdateWithoutPolicytypeInput>
  }

  export type insurersUpdateWithoutPolicytypeInput = {
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: accidentcauseover45daysUpdateManyWithoutInsurersNestedInput
    accidentplace?: accidentplaceUpdateManyWithoutInsurersNestedInput
    accidenttransactions?: accidenttransactionsUpdateManyWithoutInsurersNestedInput
    accidenttransactions22?: accidenttransactions22UpdateManyWithoutInsurersNestedInput
    causeofinjuryside?: causeofinjurysideUpdateManyWithoutInsurersNestedInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUpdateManyWithoutInsurersNestedInput
    claimants?: claimantsUpdateManyWithoutInsurersNestedInput
    claimdocuments?: claimdocumentsUpdateManyWithoutInsurersNestedInput
    claimstatus?: claimstatusUpdateManyWithoutInsurersNestedInput
    diagnosistypemapping?: diagnosistypemappingUpdateManyWithoutInsurersNestedInput
    documenttype?: documenttypeUpdateManyWithoutInsurersNestedInput
    illnesssurgery?: illnesssurgeryUpdateManyWithoutInsurersNestedInput
    illnesstype?: illnesstypeUpdateManyWithoutInsurersNestedInput
    proceduretransactions?: proceduretransactionsUpdateManyWithoutInsurersNestedInput
    servicesetting?: servicesettingUpdateManyWithoutInsurersNestedInput
  }

  export type insurersUncheckedUpdateWithoutPolicytypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: accidentcauseover45daysUncheckedUpdateManyWithoutInsurersNestedInput
    accidentplace?: accidentplaceUncheckedUpdateManyWithoutInsurersNestedInput
    accidenttransactions?: accidenttransactionsUncheckedUpdateManyWithoutInsurersNestedInput
    accidenttransactions22?: accidenttransactions22UncheckedUpdateManyWithoutInsurersNestedInput
    causeofinjuryside?: causeofinjurysideUncheckedUpdateManyWithoutInsurersNestedInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUncheckedUpdateManyWithoutInsurersNestedInput
    claimants?: claimantsUncheckedUpdateManyWithoutInsurersNestedInput
    claimdocuments?: claimdocumentsUncheckedUpdateManyWithoutInsurersNestedInput
    claimstatus?: claimstatusUncheckedUpdateManyWithoutInsurersNestedInput
    diagnosistypemapping?: diagnosistypemappingUncheckedUpdateManyWithoutInsurersNestedInput
    documenttype?: documenttypeUncheckedUpdateManyWithoutInsurersNestedInput
    illnesssurgery?: illnesssurgeryUncheckedUpdateManyWithoutInsurersNestedInput
    illnesstype?: illnesstypeUncheckedUpdateManyWithoutInsurersNestedInput
    proceduretransactions?: proceduretransactionsUncheckedUpdateManyWithoutInsurersNestedInput
    servicesetting?: servicesettingUncheckedUpdateManyWithoutInsurersNestedInput
  }

  export type insurersCreateWithoutServicesettingInput = {
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentcauseover45days?: accidentcauseover45daysCreateNestedManyWithoutInsurersInput
    accidentplace?: accidentplaceCreateNestedManyWithoutInsurersInput
    accidenttransactions?: accidenttransactionsCreateNestedManyWithoutInsurersInput
    accidenttransactions22?: accidenttransactions22CreateNestedManyWithoutInsurersInput
    causeofinjuryside?: causeofinjurysideCreateNestedManyWithoutInsurersInput
    causeofinjurywoundtype?: causeofinjurywoundtypeCreateNestedManyWithoutInsurersInput
    claimants?: claimantsCreateNestedManyWithoutInsurersInput
    claimdocuments?: claimdocumentsCreateNestedManyWithoutInsurersInput
    claimstatus?: claimstatusCreateNestedManyWithoutInsurersInput
    diagnosistypemapping?: diagnosistypemappingCreateNestedManyWithoutInsurersInput
    documenttype?: documenttypeCreateNestedManyWithoutInsurersInput
    illnesssurgery?: illnesssurgeryCreateNestedManyWithoutInsurersInput
    illnesstype?: illnesstypeCreateNestedManyWithoutInsurersInput
    policytype?: policytypeCreateNestedManyWithoutInsurersInput
    proceduretransactions?: proceduretransactionsCreateNestedManyWithoutInsurersInput
  }

  export type insurersUncheckedCreateWithoutServicesettingInput = {
    id?: number
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentcauseover45days?: accidentcauseover45daysUncheckedCreateNestedManyWithoutInsurersInput
    accidentplace?: accidentplaceUncheckedCreateNestedManyWithoutInsurersInput
    accidenttransactions?: accidenttransactionsUncheckedCreateNestedManyWithoutInsurersInput
    accidenttransactions22?: accidenttransactions22UncheckedCreateNestedManyWithoutInsurersInput
    causeofinjuryside?: causeofinjurysideUncheckedCreateNestedManyWithoutInsurersInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUncheckedCreateNestedManyWithoutInsurersInput
    claimants?: claimantsUncheckedCreateNestedManyWithoutInsurersInput
    claimdocuments?: claimdocumentsUncheckedCreateNestedManyWithoutInsurersInput
    claimstatus?: claimstatusUncheckedCreateNestedManyWithoutInsurersInput
    diagnosistypemapping?: diagnosistypemappingUncheckedCreateNestedManyWithoutInsurersInput
    documenttype?: documenttypeUncheckedCreateNestedManyWithoutInsurersInput
    illnesssurgery?: illnesssurgeryUncheckedCreateNestedManyWithoutInsurersInput
    illnesstype?: illnesstypeUncheckedCreateNestedManyWithoutInsurersInput
    policytype?: policytypeUncheckedCreateNestedManyWithoutInsurersInput
    proceduretransactions?: proceduretransactionsUncheckedCreateNestedManyWithoutInsurersInput
  }

  export type insurersCreateOrConnectWithoutServicesettingInput = {
    where: insurersWhereUniqueInput
    create: XOR<insurersCreateWithoutServicesettingInput, insurersUncheckedCreateWithoutServicesettingInput>
  }

  export type insurersUpsertWithoutServicesettingInput = {
    update: XOR<insurersUpdateWithoutServicesettingInput, insurersUncheckedUpdateWithoutServicesettingInput>
    create: XOR<insurersCreateWithoutServicesettingInput, insurersUncheckedCreateWithoutServicesettingInput>
    where?: insurersWhereInput
  }

  export type insurersUpdateToOneWithWhereWithoutServicesettingInput = {
    where?: insurersWhereInput
    data: XOR<insurersUpdateWithoutServicesettingInput, insurersUncheckedUpdateWithoutServicesettingInput>
  }

  export type insurersUpdateWithoutServicesettingInput = {
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: accidentcauseover45daysUpdateManyWithoutInsurersNestedInput
    accidentplace?: accidentplaceUpdateManyWithoutInsurersNestedInput
    accidenttransactions?: accidenttransactionsUpdateManyWithoutInsurersNestedInput
    accidenttransactions22?: accidenttransactions22UpdateManyWithoutInsurersNestedInput
    causeofinjuryside?: causeofinjurysideUpdateManyWithoutInsurersNestedInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUpdateManyWithoutInsurersNestedInput
    claimants?: claimantsUpdateManyWithoutInsurersNestedInput
    claimdocuments?: claimdocumentsUpdateManyWithoutInsurersNestedInput
    claimstatus?: claimstatusUpdateManyWithoutInsurersNestedInput
    diagnosistypemapping?: diagnosistypemappingUpdateManyWithoutInsurersNestedInput
    documenttype?: documenttypeUpdateManyWithoutInsurersNestedInput
    illnesssurgery?: illnesssurgeryUpdateManyWithoutInsurersNestedInput
    illnesstype?: illnesstypeUpdateManyWithoutInsurersNestedInput
    policytype?: policytypeUpdateManyWithoutInsurersNestedInput
    proceduretransactions?: proceduretransactionsUpdateManyWithoutInsurersNestedInput
  }

  export type insurersUncheckedUpdateWithoutServicesettingInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: accidentcauseover45daysUncheckedUpdateManyWithoutInsurersNestedInput
    accidentplace?: accidentplaceUncheckedUpdateManyWithoutInsurersNestedInput
    accidenttransactions?: accidenttransactionsUncheckedUpdateManyWithoutInsurersNestedInput
    accidenttransactions22?: accidenttransactions22UncheckedUpdateManyWithoutInsurersNestedInput
    causeofinjuryside?: causeofinjurysideUncheckedUpdateManyWithoutInsurersNestedInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUncheckedUpdateManyWithoutInsurersNestedInput
    claimants?: claimantsUncheckedUpdateManyWithoutInsurersNestedInput
    claimdocuments?: claimdocumentsUncheckedUpdateManyWithoutInsurersNestedInput
    claimstatus?: claimstatusUncheckedUpdateManyWithoutInsurersNestedInput
    diagnosistypemapping?: diagnosistypemappingUncheckedUpdateManyWithoutInsurersNestedInput
    documenttype?: documenttypeUncheckedUpdateManyWithoutInsurersNestedInput
    illnesssurgery?: illnesssurgeryUncheckedUpdateManyWithoutInsurersNestedInput
    illnesstype?: illnesstypeUncheckedUpdateManyWithoutInsurersNestedInput
    policytype?: policytypeUncheckedUpdateManyWithoutInsurersNestedInput
    proceduretransactions?: proceduretransactionsUncheckedUpdateManyWithoutInsurersNestedInput
  }

  export type claimstatusCreateWithoutTransactionclaimstatusInput = {
    claimstatuscode: string
    claimstatusdesc_th?: string | null
    claimstatusdesc_en?: string | null
    insurers?: insurersCreateNestedOneWithoutClaimstatusInput
  }

  export type claimstatusUncheckedCreateWithoutTransactionclaimstatusInput = {
    id?: number
    claimstatuscode: string
    claimstatusdesc_th?: string | null
    claimstatusdesc_en?: string | null
    insurerid?: number | null
  }

  export type claimstatusCreateOrConnectWithoutTransactionclaimstatusInput = {
    where: claimstatusWhereUniqueInput
    create: XOR<claimstatusCreateWithoutTransactionclaimstatusInput, claimstatusUncheckedCreateWithoutTransactionclaimstatusInput>
  }

  export type claimstatusUpsertWithoutTransactionclaimstatusInput = {
    update: XOR<claimstatusUpdateWithoutTransactionclaimstatusInput, claimstatusUncheckedUpdateWithoutTransactionclaimstatusInput>
    create: XOR<claimstatusCreateWithoutTransactionclaimstatusInput, claimstatusUncheckedCreateWithoutTransactionclaimstatusInput>
    where?: claimstatusWhereInput
  }

  export type claimstatusUpdateToOneWithWhereWithoutTransactionclaimstatusInput = {
    where?: claimstatusWhereInput
    data: XOR<claimstatusUpdateWithoutTransactionclaimstatusInput, claimstatusUncheckedUpdateWithoutTransactionclaimstatusInput>
  }

  export type claimstatusUpdateWithoutTransactionclaimstatusInput = {
    claimstatuscode?: StringFieldUpdateOperationsInput | string
    claimstatusdesc_th?: NullableStringFieldUpdateOperationsInput | string | null
    claimstatusdesc_en?: NullableStringFieldUpdateOperationsInput | string | null
    insurers?: insurersUpdateOneWithoutClaimstatusNestedInput
  }

  export type claimstatusUncheckedUpdateWithoutTransactionclaimstatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    claimstatuscode?: StringFieldUpdateOperationsInput | string
    claimstatusdesc_th?: NullableStringFieldUpdateOperationsInput | string | null
    claimstatusdesc_en?: NullableStringFieldUpdateOperationsInput | string | null
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type insurersCreateWithoutAccidenttransactionsInput = {
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentcauseover45days?: accidentcauseover45daysCreateNestedManyWithoutInsurersInput
    accidentplace?: accidentplaceCreateNestedManyWithoutInsurersInput
    accidenttransactions22?: accidenttransactions22CreateNestedManyWithoutInsurersInput
    causeofinjuryside?: causeofinjurysideCreateNestedManyWithoutInsurersInput
    causeofinjurywoundtype?: causeofinjurywoundtypeCreateNestedManyWithoutInsurersInput
    claimants?: claimantsCreateNestedManyWithoutInsurersInput
    claimdocuments?: claimdocumentsCreateNestedManyWithoutInsurersInput
    claimstatus?: claimstatusCreateNestedManyWithoutInsurersInput
    diagnosistypemapping?: diagnosistypemappingCreateNestedManyWithoutInsurersInput
    documenttype?: documenttypeCreateNestedManyWithoutInsurersInput
    illnesssurgery?: illnesssurgeryCreateNestedManyWithoutInsurersInput
    illnesstype?: illnesstypeCreateNestedManyWithoutInsurersInput
    policytype?: policytypeCreateNestedManyWithoutInsurersInput
    proceduretransactions?: proceduretransactionsCreateNestedManyWithoutInsurersInput
    servicesetting?: servicesettingCreateNestedManyWithoutInsurersInput
  }

  export type insurersUncheckedCreateWithoutAccidenttransactionsInput = {
    id?: number
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentcauseover45days?: accidentcauseover45daysUncheckedCreateNestedManyWithoutInsurersInput
    accidentplace?: accidentplaceUncheckedCreateNestedManyWithoutInsurersInput
    accidenttransactions22?: accidenttransactions22UncheckedCreateNestedManyWithoutInsurersInput
    causeofinjuryside?: causeofinjurysideUncheckedCreateNestedManyWithoutInsurersInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUncheckedCreateNestedManyWithoutInsurersInput
    claimants?: claimantsUncheckedCreateNestedManyWithoutInsurersInput
    claimdocuments?: claimdocumentsUncheckedCreateNestedManyWithoutInsurersInput
    claimstatus?: claimstatusUncheckedCreateNestedManyWithoutInsurersInput
    diagnosistypemapping?: diagnosistypemappingUncheckedCreateNestedManyWithoutInsurersInput
    documenttype?: documenttypeUncheckedCreateNestedManyWithoutInsurersInput
    illnesssurgery?: illnesssurgeryUncheckedCreateNestedManyWithoutInsurersInput
    illnesstype?: illnesstypeUncheckedCreateNestedManyWithoutInsurersInput
    policytype?: policytypeUncheckedCreateNestedManyWithoutInsurersInput
    proceduretransactions?: proceduretransactionsUncheckedCreateNestedManyWithoutInsurersInput
    servicesetting?: servicesettingUncheckedCreateNestedManyWithoutInsurersInput
  }

  export type insurersCreateOrConnectWithoutAccidenttransactionsInput = {
    where: insurersWhereUniqueInput
    create: XOR<insurersCreateWithoutAccidenttransactionsInput, insurersUncheckedCreateWithoutAccidenttransactionsInput>
  }

  export type causeofinjurydetailCreateWithoutAccidenttransactionsInput = {
    causeofinjury?: string | null
    commentofinjury?: string | null
  }

  export type causeofinjurydetailUncheckedCreateWithoutAccidenttransactionsInput = {
    id?: number
    causeofinjury?: string | null
    commentofinjury?: string | null
  }

  export type causeofinjurydetailCreateOrConnectWithoutAccidenttransactionsInput = {
    where: causeofinjurydetailWhereUniqueInput
    create: XOR<causeofinjurydetailCreateWithoutAccidenttransactionsInput, causeofinjurydetailUncheckedCreateWithoutAccidenttransactionsInput>
  }

  export type causeofinjurydetailCreateManyAccidenttransactionsInputEnvelope = {
    data: causeofinjurydetailCreateManyAccidenttransactionsInput | causeofinjurydetailCreateManyAccidenttransactionsInput[]
    skipDuplicates?: boolean
  }

  export type injurydetailCreateWithoutAccidenttransactionsInput = {
    woundtype?: string | null
    injuryside?: string | null
    injuryarea?: string | null
  }

  export type injurydetailUncheckedCreateWithoutAccidenttransactionsInput = {
    id?: number
    woundtype?: string | null
    injuryside?: string | null
    injuryarea?: string | null
  }

  export type injurydetailCreateOrConnectWithoutAccidenttransactionsInput = {
    where: injurydetailWhereUniqueInput
    create: XOR<injurydetailCreateWithoutAccidenttransactionsInput, injurydetailUncheckedCreateWithoutAccidenttransactionsInput>
  }

  export type injurydetailCreateManyAccidenttransactionsInputEnvelope = {
    data: injurydetailCreateManyAccidenttransactionsInput | injurydetailCreateManyAccidenttransactionsInput[]
    skipDuplicates?: boolean
  }

  export type insurersUpsertWithoutAccidenttransactionsInput = {
    update: XOR<insurersUpdateWithoutAccidenttransactionsInput, insurersUncheckedUpdateWithoutAccidenttransactionsInput>
    create: XOR<insurersCreateWithoutAccidenttransactionsInput, insurersUncheckedCreateWithoutAccidenttransactionsInput>
    where?: insurersWhereInput
  }

  export type insurersUpdateToOneWithWhereWithoutAccidenttransactionsInput = {
    where?: insurersWhereInput
    data: XOR<insurersUpdateWithoutAccidenttransactionsInput, insurersUncheckedUpdateWithoutAccidenttransactionsInput>
  }

  export type insurersUpdateWithoutAccidenttransactionsInput = {
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: accidentcauseover45daysUpdateManyWithoutInsurersNestedInput
    accidentplace?: accidentplaceUpdateManyWithoutInsurersNestedInput
    accidenttransactions22?: accidenttransactions22UpdateManyWithoutInsurersNestedInput
    causeofinjuryside?: causeofinjurysideUpdateManyWithoutInsurersNestedInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUpdateManyWithoutInsurersNestedInput
    claimants?: claimantsUpdateManyWithoutInsurersNestedInput
    claimdocuments?: claimdocumentsUpdateManyWithoutInsurersNestedInput
    claimstatus?: claimstatusUpdateManyWithoutInsurersNestedInput
    diagnosistypemapping?: diagnosistypemappingUpdateManyWithoutInsurersNestedInput
    documenttype?: documenttypeUpdateManyWithoutInsurersNestedInput
    illnesssurgery?: illnesssurgeryUpdateManyWithoutInsurersNestedInput
    illnesstype?: illnesstypeUpdateManyWithoutInsurersNestedInput
    policytype?: policytypeUpdateManyWithoutInsurersNestedInput
    proceduretransactions?: proceduretransactionsUpdateManyWithoutInsurersNestedInput
    servicesetting?: servicesettingUpdateManyWithoutInsurersNestedInput
  }

  export type insurersUncheckedUpdateWithoutAccidenttransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: accidentcauseover45daysUncheckedUpdateManyWithoutInsurersNestedInput
    accidentplace?: accidentplaceUncheckedUpdateManyWithoutInsurersNestedInput
    accidenttransactions22?: accidenttransactions22UncheckedUpdateManyWithoutInsurersNestedInput
    causeofinjuryside?: causeofinjurysideUncheckedUpdateManyWithoutInsurersNestedInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUncheckedUpdateManyWithoutInsurersNestedInput
    claimants?: claimantsUncheckedUpdateManyWithoutInsurersNestedInput
    claimdocuments?: claimdocumentsUncheckedUpdateManyWithoutInsurersNestedInput
    claimstatus?: claimstatusUncheckedUpdateManyWithoutInsurersNestedInput
    diagnosistypemapping?: diagnosistypemappingUncheckedUpdateManyWithoutInsurersNestedInput
    documenttype?: documenttypeUncheckedUpdateManyWithoutInsurersNestedInput
    illnesssurgery?: illnesssurgeryUncheckedUpdateManyWithoutInsurersNestedInput
    illnesstype?: illnesstypeUncheckedUpdateManyWithoutInsurersNestedInput
    policytype?: policytypeUncheckedUpdateManyWithoutInsurersNestedInput
    proceduretransactions?: proceduretransactionsUncheckedUpdateManyWithoutInsurersNestedInput
    servicesetting?: servicesettingUncheckedUpdateManyWithoutInsurersNestedInput
  }

  export type causeofinjurydetailUpsertWithWhereUniqueWithoutAccidenttransactionsInput = {
    where: causeofinjurydetailWhereUniqueInput
    update: XOR<causeofinjurydetailUpdateWithoutAccidenttransactionsInput, causeofinjurydetailUncheckedUpdateWithoutAccidenttransactionsInput>
    create: XOR<causeofinjurydetailCreateWithoutAccidenttransactionsInput, causeofinjurydetailUncheckedCreateWithoutAccidenttransactionsInput>
  }

  export type causeofinjurydetailUpdateWithWhereUniqueWithoutAccidenttransactionsInput = {
    where: causeofinjurydetailWhereUniqueInput
    data: XOR<causeofinjurydetailUpdateWithoutAccidenttransactionsInput, causeofinjurydetailUncheckedUpdateWithoutAccidenttransactionsInput>
  }

  export type causeofinjurydetailUpdateManyWithWhereWithoutAccidenttransactionsInput = {
    where: causeofinjurydetailScalarWhereInput
    data: XOR<causeofinjurydetailUpdateManyMutationInput, causeofinjurydetailUncheckedUpdateManyWithoutAccidenttransactionsInput>
  }

  export type causeofinjurydetailScalarWhereInput = {
    AND?: causeofinjurydetailScalarWhereInput | causeofinjurydetailScalarWhereInput[]
    OR?: causeofinjurydetailScalarWhereInput[]
    NOT?: causeofinjurydetailScalarWhereInput | causeofinjurydetailScalarWhereInput[]
    id?: IntFilter<"causeofinjurydetail"> | number
    accidentid?: IntNullableFilter<"causeofinjurydetail"> | number | null
    causeofinjury?: StringNullableFilter<"causeofinjurydetail"> | string | null
    commentofinjury?: StringNullableFilter<"causeofinjurydetail"> | string | null
  }

  export type injurydetailUpsertWithWhereUniqueWithoutAccidenttransactionsInput = {
    where: injurydetailWhereUniqueInput
    update: XOR<injurydetailUpdateWithoutAccidenttransactionsInput, injurydetailUncheckedUpdateWithoutAccidenttransactionsInput>
    create: XOR<injurydetailCreateWithoutAccidenttransactionsInput, injurydetailUncheckedCreateWithoutAccidenttransactionsInput>
  }

  export type injurydetailUpdateWithWhereUniqueWithoutAccidenttransactionsInput = {
    where: injurydetailWhereUniqueInput
    data: XOR<injurydetailUpdateWithoutAccidenttransactionsInput, injurydetailUncheckedUpdateWithoutAccidenttransactionsInput>
  }

  export type injurydetailUpdateManyWithWhereWithoutAccidenttransactionsInput = {
    where: injurydetailScalarWhereInput
    data: XOR<injurydetailUpdateManyMutationInput, injurydetailUncheckedUpdateManyWithoutAccidenttransactionsInput>
  }

  export type injurydetailScalarWhereInput = {
    AND?: injurydetailScalarWhereInput | injurydetailScalarWhereInput[]
    OR?: injurydetailScalarWhereInput[]
    NOT?: injurydetailScalarWhereInput | injurydetailScalarWhereInput[]
    id?: IntFilter<"injurydetail"> | number
    accidentid?: IntNullableFilter<"injurydetail"> | number | null
    woundtype?: StringNullableFilter<"injurydetail"> | string | null
    injuryside?: StringNullableFilter<"injurydetail"> | string | null
    injuryarea?: StringNullableFilter<"injurydetail"> | string | null
  }

  export type insurersCreateWithoutProceduretransactionsInput = {
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentcauseover45days?: accidentcauseover45daysCreateNestedManyWithoutInsurersInput
    accidentplace?: accidentplaceCreateNestedManyWithoutInsurersInput
    accidenttransactions?: accidenttransactionsCreateNestedManyWithoutInsurersInput
    accidenttransactions22?: accidenttransactions22CreateNestedManyWithoutInsurersInput
    causeofinjuryside?: causeofinjurysideCreateNestedManyWithoutInsurersInput
    causeofinjurywoundtype?: causeofinjurywoundtypeCreateNestedManyWithoutInsurersInput
    claimants?: claimantsCreateNestedManyWithoutInsurersInput
    claimdocuments?: claimdocumentsCreateNestedManyWithoutInsurersInput
    claimstatus?: claimstatusCreateNestedManyWithoutInsurersInput
    diagnosistypemapping?: diagnosistypemappingCreateNestedManyWithoutInsurersInput
    documenttype?: documenttypeCreateNestedManyWithoutInsurersInput
    illnesssurgery?: illnesssurgeryCreateNestedManyWithoutInsurersInput
    illnesstype?: illnesstypeCreateNestedManyWithoutInsurersInput
    policytype?: policytypeCreateNestedManyWithoutInsurersInput
    servicesetting?: servicesettingCreateNestedManyWithoutInsurersInput
  }

  export type insurersUncheckedCreateWithoutProceduretransactionsInput = {
    id?: number
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentcauseover45days?: accidentcauseover45daysUncheckedCreateNestedManyWithoutInsurersInput
    accidentplace?: accidentplaceUncheckedCreateNestedManyWithoutInsurersInput
    accidenttransactions?: accidenttransactionsUncheckedCreateNestedManyWithoutInsurersInput
    accidenttransactions22?: accidenttransactions22UncheckedCreateNestedManyWithoutInsurersInput
    causeofinjuryside?: causeofinjurysideUncheckedCreateNestedManyWithoutInsurersInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUncheckedCreateNestedManyWithoutInsurersInput
    claimants?: claimantsUncheckedCreateNestedManyWithoutInsurersInput
    claimdocuments?: claimdocumentsUncheckedCreateNestedManyWithoutInsurersInput
    claimstatus?: claimstatusUncheckedCreateNestedManyWithoutInsurersInput
    diagnosistypemapping?: diagnosistypemappingUncheckedCreateNestedManyWithoutInsurersInput
    documenttype?: documenttypeUncheckedCreateNestedManyWithoutInsurersInput
    illnesssurgery?: illnesssurgeryUncheckedCreateNestedManyWithoutInsurersInput
    illnesstype?: illnesstypeUncheckedCreateNestedManyWithoutInsurersInput
    policytype?: policytypeUncheckedCreateNestedManyWithoutInsurersInput
    servicesetting?: servicesettingUncheckedCreateNestedManyWithoutInsurersInput
  }

  export type insurersCreateOrConnectWithoutProceduretransactionsInput = {
    where: insurersWhereUniqueInput
    create: XOR<insurersCreateWithoutProceduretransactionsInput, insurersUncheckedCreateWithoutProceduretransactionsInput>
  }

  export type insurersUpsertWithoutProceduretransactionsInput = {
    update: XOR<insurersUpdateWithoutProceduretransactionsInput, insurersUncheckedUpdateWithoutProceduretransactionsInput>
    create: XOR<insurersCreateWithoutProceduretransactionsInput, insurersUncheckedCreateWithoutProceduretransactionsInput>
    where?: insurersWhereInput
  }

  export type insurersUpdateToOneWithWhereWithoutProceduretransactionsInput = {
    where?: insurersWhereInput
    data: XOR<insurersUpdateWithoutProceduretransactionsInput, insurersUncheckedUpdateWithoutProceduretransactionsInput>
  }

  export type insurersUpdateWithoutProceduretransactionsInput = {
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: accidentcauseover45daysUpdateManyWithoutInsurersNestedInput
    accidentplace?: accidentplaceUpdateManyWithoutInsurersNestedInput
    accidenttransactions?: accidenttransactionsUpdateManyWithoutInsurersNestedInput
    accidenttransactions22?: accidenttransactions22UpdateManyWithoutInsurersNestedInput
    causeofinjuryside?: causeofinjurysideUpdateManyWithoutInsurersNestedInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUpdateManyWithoutInsurersNestedInput
    claimants?: claimantsUpdateManyWithoutInsurersNestedInput
    claimdocuments?: claimdocumentsUpdateManyWithoutInsurersNestedInput
    claimstatus?: claimstatusUpdateManyWithoutInsurersNestedInput
    diagnosistypemapping?: diagnosistypemappingUpdateManyWithoutInsurersNestedInput
    documenttype?: documenttypeUpdateManyWithoutInsurersNestedInput
    illnesssurgery?: illnesssurgeryUpdateManyWithoutInsurersNestedInput
    illnesstype?: illnesstypeUpdateManyWithoutInsurersNestedInput
    policytype?: policytypeUpdateManyWithoutInsurersNestedInput
    servicesetting?: servicesettingUpdateManyWithoutInsurersNestedInput
  }

  export type insurersUncheckedUpdateWithoutProceduretransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: accidentcauseover45daysUncheckedUpdateManyWithoutInsurersNestedInput
    accidentplace?: accidentplaceUncheckedUpdateManyWithoutInsurersNestedInput
    accidenttransactions?: accidenttransactionsUncheckedUpdateManyWithoutInsurersNestedInput
    accidenttransactions22?: accidenttransactions22UncheckedUpdateManyWithoutInsurersNestedInput
    causeofinjuryside?: causeofinjurysideUncheckedUpdateManyWithoutInsurersNestedInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUncheckedUpdateManyWithoutInsurersNestedInput
    claimants?: claimantsUncheckedUpdateManyWithoutInsurersNestedInput
    claimdocuments?: claimdocumentsUncheckedUpdateManyWithoutInsurersNestedInput
    claimstatus?: claimstatusUncheckedUpdateManyWithoutInsurersNestedInput
    diagnosistypemapping?: diagnosistypemappingUncheckedUpdateManyWithoutInsurersNestedInput
    documenttype?: documenttypeUncheckedUpdateManyWithoutInsurersNestedInput
    illnesssurgery?: illnesssurgeryUncheckedUpdateManyWithoutInsurersNestedInput
    illnesstype?: illnesstypeUncheckedUpdateManyWithoutInsurersNestedInput
    policytype?: policytypeUncheckedUpdateManyWithoutInsurersNestedInput
    servicesetting?: servicesettingUncheckedUpdateManyWithoutInsurersNestedInput
  }

  export type insurersCreateWithoutAccidenttransactions22Input = {
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentcauseover45days?: accidentcauseover45daysCreateNestedManyWithoutInsurersInput
    accidentplace?: accidentplaceCreateNestedManyWithoutInsurersInput
    accidenttransactions?: accidenttransactionsCreateNestedManyWithoutInsurersInput
    causeofinjuryside?: causeofinjurysideCreateNestedManyWithoutInsurersInput
    causeofinjurywoundtype?: causeofinjurywoundtypeCreateNestedManyWithoutInsurersInput
    claimants?: claimantsCreateNestedManyWithoutInsurersInput
    claimdocuments?: claimdocumentsCreateNestedManyWithoutInsurersInput
    claimstatus?: claimstatusCreateNestedManyWithoutInsurersInput
    diagnosistypemapping?: diagnosistypemappingCreateNestedManyWithoutInsurersInput
    documenttype?: documenttypeCreateNestedManyWithoutInsurersInput
    illnesssurgery?: illnesssurgeryCreateNestedManyWithoutInsurersInput
    illnesstype?: illnesstypeCreateNestedManyWithoutInsurersInput
    policytype?: policytypeCreateNestedManyWithoutInsurersInput
    proceduretransactions?: proceduretransactionsCreateNestedManyWithoutInsurersInput
    servicesetting?: servicesettingCreateNestedManyWithoutInsurersInput
  }

  export type insurersUncheckedCreateWithoutAccidenttransactions22Input = {
    id?: number
    insurerid: number
    insurercode?: number | null
    insurername?: string | null
    accidentcauseover45days?: accidentcauseover45daysUncheckedCreateNestedManyWithoutInsurersInput
    accidentplace?: accidentplaceUncheckedCreateNestedManyWithoutInsurersInput
    accidenttransactions?: accidenttransactionsUncheckedCreateNestedManyWithoutInsurersInput
    causeofinjuryside?: causeofinjurysideUncheckedCreateNestedManyWithoutInsurersInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUncheckedCreateNestedManyWithoutInsurersInput
    claimants?: claimantsUncheckedCreateNestedManyWithoutInsurersInput
    claimdocuments?: claimdocumentsUncheckedCreateNestedManyWithoutInsurersInput
    claimstatus?: claimstatusUncheckedCreateNestedManyWithoutInsurersInput
    diagnosistypemapping?: diagnosistypemappingUncheckedCreateNestedManyWithoutInsurersInput
    documenttype?: documenttypeUncheckedCreateNestedManyWithoutInsurersInput
    illnesssurgery?: illnesssurgeryUncheckedCreateNestedManyWithoutInsurersInput
    illnesstype?: illnesstypeUncheckedCreateNestedManyWithoutInsurersInput
    policytype?: policytypeUncheckedCreateNestedManyWithoutInsurersInput
    proceduretransactions?: proceduretransactionsUncheckedCreateNestedManyWithoutInsurersInput
    servicesetting?: servicesettingUncheckedCreateNestedManyWithoutInsurersInput
  }

  export type insurersCreateOrConnectWithoutAccidenttransactions22Input = {
    where: insurersWhereUniqueInput
    create: XOR<insurersCreateWithoutAccidenttransactions22Input, insurersUncheckedCreateWithoutAccidenttransactions22Input>
  }

  export type insurersUpsertWithoutAccidenttransactions22Input = {
    update: XOR<insurersUpdateWithoutAccidenttransactions22Input, insurersUncheckedUpdateWithoutAccidenttransactions22Input>
    create: XOR<insurersCreateWithoutAccidenttransactions22Input, insurersUncheckedCreateWithoutAccidenttransactions22Input>
    where?: insurersWhereInput
  }

  export type insurersUpdateToOneWithWhereWithoutAccidenttransactions22Input = {
    where?: insurersWhereInput
    data: XOR<insurersUpdateWithoutAccidenttransactions22Input, insurersUncheckedUpdateWithoutAccidenttransactions22Input>
  }

  export type insurersUpdateWithoutAccidenttransactions22Input = {
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: accidentcauseover45daysUpdateManyWithoutInsurersNestedInput
    accidentplace?: accidentplaceUpdateManyWithoutInsurersNestedInput
    accidenttransactions?: accidenttransactionsUpdateManyWithoutInsurersNestedInput
    causeofinjuryside?: causeofinjurysideUpdateManyWithoutInsurersNestedInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUpdateManyWithoutInsurersNestedInput
    claimants?: claimantsUpdateManyWithoutInsurersNestedInput
    claimdocuments?: claimdocumentsUpdateManyWithoutInsurersNestedInput
    claimstatus?: claimstatusUpdateManyWithoutInsurersNestedInput
    diagnosistypemapping?: diagnosistypemappingUpdateManyWithoutInsurersNestedInput
    documenttype?: documenttypeUpdateManyWithoutInsurersNestedInput
    illnesssurgery?: illnesssurgeryUpdateManyWithoutInsurersNestedInput
    illnesstype?: illnesstypeUpdateManyWithoutInsurersNestedInput
    policytype?: policytypeUpdateManyWithoutInsurersNestedInput
    proceduretransactions?: proceduretransactionsUpdateManyWithoutInsurersNestedInput
    servicesetting?: servicesettingUpdateManyWithoutInsurersNestedInput
  }

  export type insurersUncheckedUpdateWithoutAccidenttransactions22Input = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: IntFieldUpdateOperationsInput | number
    insurercode?: NullableIntFieldUpdateOperationsInput | number | null
    insurername?: NullableStringFieldUpdateOperationsInput | string | null
    accidentcauseover45days?: accidentcauseover45daysUncheckedUpdateManyWithoutInsurersNestedInput
    accidentplace?: accidentplaceUncheckedUpdateManyWithoutInsurersNestedInput
    accidenttransactions?: accidenttransactionsUncheckedUpdateManyWithoutInsurersNestedInput
    causeofinjuryside?: causeofinjurysideUncheckedUpdateManyWithoutInsurersNestedInput
    causeofinjurywoundtype?: causeofinjurywoundtypeUncheckedUpdateManyWithoutInsurersNestedInput
    claimants?: claimantsUncheckedUpdateManyWithoutInsurersNestedInput
    claimdocuments?: claimdocumentsUncheckedUpdateManyWithoutInsurersNestedInput
    claimstatus?: claimstatusUncheckedUpdateManyWithoutInsurersNestedInput
    diagnosistypemapping?: diagnosistypemappingUncheckedUpdateManyWithoutInsurersNestedInput
    documenttype?: documenttypeUncheckedUpdateManyWithoutInsurersNestedInput
    illnesssurgery?: illnesssurgeryUncheckedUpdateManyWithoutInsurersNestedInput
    illnesstype?: illnesstypeUncheckedUpdateManyWithoutInsurersNestedInput
    policytype?: policytypeUncheckedUpdateManyWithoutInsurersNestedInput
    proceduretransactions?: proceduretransactionsUncheckedUpdateManyWithoutInsurersNestedInput
    servicesetting?: servicesettingUncheckedUpdateManyWithoutInsurersNestedInput
  }

  export type accidenttransactionsCreateWithoutCauseofinjurydetailInput = {
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    accidentplace?: string | null
    accidentdate?: string | null
    insurers?: insurersCreateNestedOneWithoutAccidenttransactionsInput
    injurydetail?: injurydetailCreateNestedManyWithoutAccidenttransactionsInput
  }

  export type accidenttransactionsUncheckedCreateWithoutCauseofinjurydetailInput = {
    id?: number
    insurerid?: number | null
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    accidentplace?: string | null
    accidentdate?: string | null
    injurydetail?: injurydetailUncheckedCreateNestedManyWithoutAccidenttransactionsInput
  }

  export type accidenttransactionsCreateOrConnectWithoutCauseofinjurydetailInput = {
    where: accidenttransactionsWhereUniqueInput
    create: XOR<accidenttransactionsCreateWithoutCauseofinjurydetailInput, accidenttransactionsUncheckedCreateWithoutCauseofinjurydetailInput>
  }

  export type accidenttransactionsUpsertWithoutCauseofinjurydetailInput = {
    update: XOR<accidenttransactionsUpdateWithoutCauseofinjurydetailInput, accidenttransactionsUncheckedUpdateWithoutCauseofinjurydetailInput>
    create: XOR<accidenttransactionsCreateWithoutCauseofinjurydetailInput, accidenttransactionsUncheckedCreateWithoutCauseofinjurydetailInput>
    where?: accidenttransactionsWhereInput
  }

  export type accidenttransactionsUpdateToOneWithWhereWithoutCauseofinjurydetailInput = {
    where?: accidenttransactionsWhereInput
    data: XOR<accidenttransactionsUpdateWithoutCauseofinjurydetailInput, accidenttransactionsUncheckedUpdateWithoutCauseofinjurydetailInput>
  }

  export type accidenttransactionsUpdateWithoutCauseofinjurydetailInput = {
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    accidentplace?: NullableStringFieldUpdateOperationsInput | string | null
    accidentdate?: NullableStringFieldUpdateOperationsInput | string | null
    insurers?: insurersUpdateOneWithoutAccidenttransactionsNestedInput
    injurydetail?: injurydetailUpdateManyWithoutAccidenttransactionsNestedInput
  }

  export type accidenttransactionsUncheckedUpdateWithoutCauseofinjurydetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    accidentplace?: NullableStringFieldUpdateOperationsInput | string | null
    accidentdate?: NullableStringFieldUpdateOperationsInput | string | null
    injurydetail?: injurydetailUncheckedUpdateManyWithoutAccidenttransactionsNestedInput
  }

  export type accidenttransactionsCreateWithoutInjurydetailInput = {
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    accidentplace?: string | null
    accidentdate?: string | null
    insurers?: insurersCreateNestedOneWithoutAccidenttransactionsInput
    causeofinjurydetail?: causeofinjurydetailCreateNestedManyWithoutAccidenttransactionsInput
  }

  export type accidenttransactionsUncheckedCreateWithoutInjurydetailInput = {
    id?: number
    insurerid?: number | null
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    accidentplace?: string | null
    accidentdate?: string | null
    causeofinjurydetail?: causeofinjurydetailUncheckedCreateNestedManyWithoutAccidenttransactionsInput
  }

  export type accidenttransactionsCreateOrConnectWithoutInjurydetailInput = {
    where: accidenttransactionsWhereUniqueInput
    create: XOR<accidenttransactionsCreateWithoutInjurydetailInput, accidenttransactionsUncheckedCreateWithoutInjurydetailInput>
  }

  export type accidenttransactionsUpsertWithoutInjurydetailInput = {
    update: XOR<accidenttransactionsUpdateWithoutInjurydetailInput, accidenttransactionsUncheckedUpdateWithoutInjurydetailInput>
    create: XOR<accidenttransactionsCreateWithoutInjurydetailInput, accidenttransactionsUncheckedCreateWithoutInjurydetailInput>
    where?: accidenttransactionsWhereInput
  }

  export type accidenttransactionsUpdateToOneWithWhereWithoutInjurydetailInput = {
    where?: accidenttransactionsWhereInput
    data: XOR<accidenttransactionsUpdateWithoutInjurydetailInput, accidenttransactionsUncheckedUpdateWithoutInjurydetailInput>
  }

  export type accidenttransactionsUpdateWithoutInjurydetailInput = {
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    accidentplace?: NullableStringFieldUpdateOperationsInput | string | null
    accidentdate?: NullableStringFieldUpdateOperationsInput | string | null
    insurers?: insurersUpdateOneWithoutAccidenttransactionsNestedInput
    causeofinjurydetail?: causeofinjurydetailUpdateManyWithoutAccidenttransactionsNestedInput
  }

  export type accidenttransactionsUncheckedUpdateWithoutInjurydetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerid?: NullableIntFieldUpdateOperationsInput | number | null
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    accidentplace?: NullableStringFieldUpdateOperationsInput | string | null
    accidentdate?: NullableStringFieldUpdateOperationsInput | string | null
    causeofinjurydetail?: causeofinjurydetailUncheckedUpdateManyWithoutAccidenttransactionsNestedInput
  }

  export type transactionclaimstatusCreateManyClaimstatusInput = {
    id?: number
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    batchnumber?: string | null
    claimno?: string | null
    invoicenumber?: string | null
    status_changed_at?: Date | string | null
    note?: string | null
    totalapproveamount?: string | null
    paymentdate?: string | null
  }

  export type transactionclaimstatusUpdateWithoutClaimstatusInput = {
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    batchnumber?: NullableStringFieldUpdateOperationsInput | string | null
    claimno?: NullableStringFieldUpdateOperationsInput | string | null
    invoicenumber?: NullableStringFieldUpdateOperationsInput | string | null
    status_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    totalapproveamount?: NullableStringFieldUpdateOperationsInput | string | null
    paymentdate?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type transactionclaimstatusUncheckedUpdateWithoutClaimstatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    batchnumber?: NullableStringFieldUpdateOperationsInput | string | null
    claimno?: NullableStringFieldUpdateOperationsInput | string | null
    invoicenumber?: NullableStringFieldUpdateOperationsInput | string | null
    status_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    totalapproveamount?: NullableStringFieldUpdateOperationsInput | string | null
    paymentdate?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type transactionclaimstatusUncheckedUpdateManyWithoutClaimstatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    batchnumber?: NullableStringFieldUpdateOperationsInput | string | null
    claimno?: NullableStringFieldUpdateOperationsInput | string | null
    invoicenumber?: NullableStringFieldUpdateOperationsInput | string | null
    status_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    totalapproveamount?: NullableStringFieldUpdateOperationsInput | string | null
    paymentdate?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type accidentcauseover45daysCreateManyInsurersInput = {
    id?: number
    causeovercode: string
    causeoverdesc?: string | null
  }

  export type accidentplaceCreateManyInsurersInput = {
    id?: number
    accidentplacecode: string
    accidentplacename?: string | null
  }

  export type accidenttransactionsCreateManyInsurersInput = {
    id?: number
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    accidentplace?: string | null
    accidentdate?: string | null
  }

  export type accidenttransactions22CreateManyInsurersInput = {
    id?: number
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    accidentplace?: string | null
    accidentdate?: string | null
    causeofinjury?: string | null
    commentofinjury?: string | null
    woundtype?: string | null
    injuryside?: string | null
    injuryarea?: string | null
  }

  export type causeofinjurysideCreateManyInsurersInput = {
    id?: number
    injurysidename: string
    injurysidecode?: string | null
  }

  export type causeofinjurywoundtypeCreateManyInsurersInput = {
    id?: number
    woundtypename: string
    woundtypecode?: string | null
  }

  export type claimantsCreateManyInsurersInput = {
    id?: number
    national_id?: string | null
    passportnumber?: string | null
    hn?: string | null
    patientid?: number | null
    title_th?: string | null
    givenname_th?: string | null
    surname_th?: string | null
    title_en?: string | null
    givenname_en?: string | null
    surname_en?: string | null
    mobilephone?: string | null
    statusactive?: boolean | null
    dateofbirth?: string | null
    gender?: string | null
    registrationdate?: Date | string | null
  }

  export type claimdocumentsCreateManyInsurersInput = {
    id?: number
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    documentname?: string | null
    documenttypecode?: string | null
    documenttypename?: string | null
    serverpath?: string | null
    filepath: string
    filesize?: bigint | number | null
    filemimetype?: string | null
    uploaddate?: Date | string | null
    uploadedby?: string | null
  }

  export type claimstatusCreateManyInsurersInput = {
    id?: number
    claimstatuscode: string
    claimstatusdesc_th?: string | null
    claimstatusdesc_en?: string | null
  }

  export type diagnosistypemappingCreateManyInsurersInput = {
    id?: number
    dxtypecodetrakcare: string
    dxtypenametrakcare?: string | null
    dxtypecodeinsurance?: string | null
    dxtypenameinsurance?: string | null
  }

  export type documenttypeCreateManyInsurersInput = {
    id?: number
    documenttypecode: string
    documenttypename?: string | null
  }

  export type illnesssurgeryCreateManyInsurersInput = {
    id?: number
    iscode: string
    isdesc?: string | null
  }

  export type illnesstypeCreateManyInsurersInput = {
    id?: number
    illnesstypecode: string
    illnesstypedesc?: string | null
  }

  export type policytypeCreateManyInsurersInput = {
    id?: number
    policytypecode: string
    policytypedesc?: string | null
  }

  export type proceduretransactionsCreateManyInsurersInput = {
    id?: number
    refid?: string | null
    transactionno?: string | null
    hn?: string | null
    vn?: string | null
    icd9?: string | null
    procedurename?: string | null
    proceduredate?: string | null
  }

  export type servicesettingCreateManyInsurersInput = {
    id?: number
    servicesettingcode: string
    servicesettingdesc: string
  }

  export type accidentcauseover45daysUpdateWithoutInsurersInput = {
    causeovercode?: StringFieldUpdateOperationsInput | string
    causeoverdesc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type accidentcauseover45daysUncheckedUpdateWithoutInsurersInput = {
    id?: IntFieldUpdateOperationsInput | number
    causeovercode?: StringFieldUpdateOperationsInput | string
    causeoverdesc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type accidentcauseover45daysUncheckedUpdateManyWithoutInsurersInput = {
    id?: IntFieldUpdateOperationsInput | number
    causeovercode?: StringFieldUpdateOperationsInput | string
    causeoverdesc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type accidentplaceUpdateWithoutInsurersInput = {
    accidentplacecode?: StringFieldUpdateOperationsInput | string
    accidentplacename?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type accidentplaceUncheckedUpdateWithoutInsurersInput = {
    id?: IntFieldUpdateOperationsInput | number
    accidentplacecode?: StringFieldUpdateOperationsInput | string
    accidentplacename?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type accidentplaceUncheckedUpdateManyWithoutInsurersInput = {
    id?: IntFieldUpdateOperationsInput | number
    accidentplacecode?: StringFieldUpdateOperationsInput | string
    accidentplacename?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type accidenttransactionsUpdateWithoutInsurersInput = {
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    accidentplace?: NullableStringFieldUpdateOperationsInput | string | null
    accidentdate?: NullableStringFieldUpdateOperationsInput | string | null
    causeofinjurydetail?: causeofinjurydetailUpdateManyWithoutAccidenttransactionsNestedInput
    injurydetail?: injurydetailUpdateManyWithoutAccidenttransactionsNestedInput
  }

  export type accidenttransactionsUncheckedUpdateWithoutInsurersInput = {
    id?: IntFieldUpdateOperationsInput | number
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    accidentplace?: NullableStringFieldUpdateOperationsInput | string | null
    accidentdate?: NullableStringFieldUpdateOperationsInput | string | null
    causeofinjurydetail?: causeofinjurydetailUncheckedUpdateManyWithoutAccidenttransactionsNestedInput
    injurydetail?: injurydetailUncheckedUpdateManyWithoutAccidenttransactionsNestedInput
  }

  export type accidenttransactionsUncheckedUpdateManyWithoutInsurersInput = {
    id?: IntFieldUpdateOperationsInput | number
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    accidentplace?: NullableStringFieldUpdateOperationsInput | string | null
    accidentdate?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type accidenttransactions22UpdateWithoutInsurersInput = {
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    accidentplace?: NullableStringFieldUpdateOperationsInput | string | null
    accidentdate?: NullableStringFieldUpdateOperationsInput | string | null
    causeofinjury?: NullableStringFieldUpdateOperationsInput | string | null
    commentofinjury?: NullableStringFieldUpdateOperationsInput | string | null
    woundtype?: NullableStringFieldUpdateOperationsInput | string | null
    injuryside?: NullableStringFieldUpdateOperationsInput | string | null
    injuryarea?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type accidenttransactions22UncheckedUpdateWithoutInsurersInput = {
    id?: IntFieldUpdateOperationsInput | number
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    accidentplace?: NullableStringFieldUpdateOperationsInput | string | null
    accidentdate?: NullableStringFieldUpdateOperationsInput | string | null
    causeofinjury?: NullableStringFieldUpdateOperationsInput | string | null
    commentofinjury?: NullableStringFieldUpdateOperationsInput | string | null
    woundtype?: NullableStringFieldUpdateOperationsInput | string | null
    injuryside?: NullableStringFieldUpdateOperationsInput | string | null
    injuryarea?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type accidenttransactions22UncheckedUpdateManyWithoutInsurersInput = {
    id?: IntFieldUpdateOperationsInput | number
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    accidentplace?: NullableStringFieldUpdateOperationsInput | string | null
    accidentdate?: NullableStringFieldUpdateOperationsInput | string | null
    causeofinjury?: NullableStringFieldUpdateOperationsInput | string | null
    commentofinjury?: NullableStringFieldUpdateOperationsInput | string | null
    woundtype?: NullableStringFieldUpdateOperationsInput | string | null
    injuryside?: NullableStringFieldUpdateOperationsInput | string | null
    injuryarea?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type causeofinjurysideUpdateWithoutInsurersInput = {
    injurysidename?: StringFieldUpdateOperationsInput | string
    injurysidecode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type causeofinjurysideUncheckedUpdateWithoutInsurersInput = {
    id?: IntFieldUpdateOperationsInput | number
    injurysidename?: StringFieldUpdateOperationsInput | string
    injurysidecode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type causeofinjurysideUncheckedUpdateManyWithoutInsurersInput = {
    id?: IntFieldUpdateOperationsInput | number
    injurysidename?: StringFieldUpdateOperationsInput | string
    injurysidecode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type causeofinjurywoundtypeUpdateWithoutInsurersInput = {
    woundtypename?: StringFieldUpdateOperationsInput | string
    woundtypecode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type causeofinjurywoundtypeUncheckedUpdateWithoutInsurersInput = {
    id?: IntFieldUpdateOperationsInput | number
    woundtypename?: StringFieldUpdateOperationsInput | string
    woundtypecode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type causeofinjurywoundtypeUncheckedUpdateManyWithoutInsurersInput = {
    id?: IntFieldUpdateOperationsInput | number
    woundtypename?: StringFieldUpdateOperationsInput | string
    woundtypecode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type claimantsUpdateWithoutInsurersInput = {
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    passportnumber?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    patientid?: NullableIntFieldUpdateOperationsInput | number | null
    title_th?: NullableStringFieldUpdateOperationsInput | string | null
    givenname_th?: NullableStringFieldUpdateOperationsInput | string | null
    surname_th?: NullableStringFieldUpdateOperationsInput | string | null
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    givenname_en?: NullableStringFieldUpdateOperationsInput | string | null
    surname_en?: NullableStringFieldUpdateOperationsInput | string | null
    mobilephone?: NullableStringFieldUpdateOperationsInput | string | null
    statusactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dateofbirth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    registrationdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type claimantsUncheckedUpdateWithoutInsurersInput = {
    id?: IntFieldUpdateOperationsInput | number
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    passportnumber?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    patientid?: NullableIntFieldUpdateOperationsInput | number | null
    title_th?: NullableStringFieldUpdateOperationsInput | string | null
    givenname_th?: NullableStringFieldUpdateOperationsInput | string | null
    surname_th?: NullableStringFieldUpdateOperationsInput | string | null
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    givenname_en?: NullableStringFieldUpdateOperationsInput | string | null
    surname_en?: NullableStringFieldUpdateOperationsInput | string | null
    mobilephone?: NullableStringFieldUpdateOperationsInput | string | null
    statusactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dateofbirth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    registrationdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type claimantsUncheckedUpdateManyWithoutInsurersInput = {
    id?: IntFieldUpdateOperationsInput | number
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    passportnumber?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    patientid?: NullableIntFieldUpdateOperationsInput | number | null
    title_th?: NullableStringFieldUpdateOperationsInput | string | null
    givenname_th?: NullableStringFieldUpdateOperationsInput | string | null
    surname_th?: NullableStringFieldUpdateOperationsInput | string | null
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    givenname_en?: NullableStringFieldUpdateOperationsInput | string | null
    surname_en?: NullableStringFieldUpdateOperationsInput | string | null
    mobilephone?: NullableStringFieldUpdateOperationsInput | string | null
    statusactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dateofbirth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    registrationdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type claimdocumentsUpdateWithoutInsurersInput = {
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    documentname?: NullableStringFieldUpdateOperationsInput | string | null
    documenttypecode?: NullableStringFieldUpdateOperationsInput | string | null
    documenttypename?: NullableStringFieldUpdateOperationsInput | string | null
    serverpath?: NullableStringFieldUpdateOperationsInput | string | null
    filepath?: StringFieldUpdateOperationsInput | string
    filesize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    filemimetype?: NullableStringFieldUpdateOperationsInput | string | null
    uploaddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedby?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type claimdocumentsUncheckedUpdateWithoutInsurersInput = {
    id?: IntFieldUpdateOperationsInput | number
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    documentname?: NullableStringFieldUpdateOperationsInput | string | null
    documenttypecode?: NullableStringFieldUpdateOperationsInput | string | null
    documenttypename?: NullableStringFieldUpdateOperationsInput | string | null
    serverpath?: NullableStringFieldUpdateOperationsInput | string | null
    filepath?: StringFieldUpdateOperationsInput | string
    filesize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    filemimetype?: NullableStringFieldUpdateOperationsInput | string | null
    uploaddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedby?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type claimdocumentsUncheckedUpdateManyWithoutInsurersInput = {
    id?: IntFieldUpdateOperationsInput | number
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    documentname?: NullableStringFieldUpdateOperationsInput | string | null
    documenttypecode?: NullableStringFieldUpdateOperationsInput | string | null
    documenttypename?: NullableStringFieldUpdateOperationsInput | string | null
    serverpath?: NullableStringFieldUpdateOperationsInput | string | null
    filepath?: StringFieldUpdateOperationsInput | string
    filesize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    filemimetype?: NullableStringFieldUpdateOperationsInput | string | null
    uploaddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedby?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type claimstatusUpdateWithoutInsurersInput = {
    claimstatuscode?: StringFieldUpdateOperationsInput | string
    claimstatusdesc_th?: NullableStringFieldUpdateOperationsInput | string | null
    claimstatusdesc_en?: NullableStringFieldUpdateOperationsInput | string | null
    transactionclaimstatus?: transactionclaimstatusUpdateManyWithoutClaimstatusNestedInput
  }

  export type claimstatusUncheckedUpdateWithoutInsurersInput = {
    id?: IntFieldUpdateOperationsInput | number
    claimstatuscode?: StringFieldUpdateOperationsInput | string
    claimstatusdesc_th?: NullableStringFieldUpdateOperationsInput | string | null
    claimstatusdesc_en?: NullableStringFieldUpdateOperationsInput | string | null
    transactionclaimstatus?: transactionclaimstatusUncheckedUpdateManyWithoutClaimstatusNestedInput
  }

  export type claimstatusUncheckedUpdateManyWithoutInsurersInput = {
    id?: IntFieldUpdateOperationsInput | number
    claimstatuscode?: StringFieldUpdateOperationsInput | string
    claimstatusdesc_th?: NullableStringFieldUpdateOperationsInput | string | null
    claimstatusdesc_en?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type diagnosistypemappingUpdateWithoutInsurersInput = {
    dxtypecodetrakcare?: StringFieldUpdateOperationsInput | string
    dxtypenametrakcare?: NullableStringFieldUpdateOperationsInput | string | null
    dxtypecodeinsurance?: NullableStringFieldUpdateOperationsInput | string | null
    dxtypenameinsurance?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type diagnosistypemappingUncheckedUpdateWithoutInsurersInput = {
    id?: IntFieldUpdateOperationsInput | number
    dxtypecodetrakcare?: StringFieldUpdateOperationsInput | string
    dxtypenametrakcare?: NullableStringFieldUpdateOperationsInput | string | null
    dxtypecodeinsurance?: NullableStringFieldUpdateOperationsInput | string | null
    dxtypenameinsurance?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type diagnosistypemappingUncheckedUpdateManyWithoutInsurersInput = {
    id?: IntFieldUpdateOperationsInput | number
    dxtypecodetrakcare?: StringFieldUpdateOperationsInput | string
    dxtypenametrakcare?: NullableStringFieldUpdateOperationsInput | string | null
    dxtypecodeinsurance?: NullableStringFieldUpdateOperationsInput | string | null
    dxtypenameinsurance?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type documenttypeUpdateWithoutInsurersInput = {
    documenttypecode?: StringFieldUpdateOperationsInput | string
    documenttypename?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type documenttypeUncheckedUpdateWithoutInsurersInput = {
    id?: IntFieldUpdateOperationsInput | number
    documenttypecode?: StringFieldUpdateOperationsInput | string
    documenttypename?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type documenttypeUncheckedUpdateManyWithoutInsurersInput = {
    id?: IntFieldUpdateOperationsInput | number
    documenttypecode?: StringFieldUpdateOperationsInput | string
    documenttypename?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type illnesssurgeryUpdateWithoutInsurersInput = {
    iscode?: StringFieldUpdateOperationsInput | string
    isdesc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type illnesssurgeryUncheckedUpdateWithoutInsurersInput = {
    id?: IntFieldUpdateOperationsInput | number
    iscode?: StringFieldUpdateOperationsInput | string
    isdesc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type illnesssurgeryUncheckedUpdateManyWithoutInsurersInput = {
    id?: IntFieldUpdateOperationsInput | number
    iscode?: StringFieldUpdateOperationsInput | string
    isdesc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type illnesstypeUpdateWithoutInsurersInput = {
    illnesstypecode?: StringFieldUpdateOperationsInput | string
    illnesstypedesc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type illnesstypeUncheckedUpdateWithoutInsurersInput = {
    id?: IntFieldUpdateOperationsInput | number
    illnesstypecode?: StringFieldUpdateOperationsInput | string
    illnesstypedesc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type illnesstypeUncheckedUpdateManyWithoutInsurersInput = {
    id?: IntFieldUpdateOperationsInput | number
    illnesstypecode?: StringFieldUpdateOperationsInput | string
    illnesstypedesc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type policytypeUpdateWithoutInsurersInput = {
    policytypecode?: StringFieldUpdateOperationsInput | string
    policytypedesc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type policytypeUncheckedUpdateWithoutInsurersInput = {
    id?: IntFieldUpdateOperationsInput | number
    policytypecode?: StringFieldUpdateOperationsInput | string
    policytypedesc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type policytypeUncheckedUpdateManyWithoutInsurersInput = {
    id?: IntFieldUpdateOperationsInput | number
    policytypecode?: StringFieldUpdateOperationsInput | string
    policytypedesc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type proceduretransactionsUpdateWithoutInsurersInput = {
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    icd9?: NullableStringFieldUpdateOperationsInput | string | null
    procedurename?: NullableStringFieldUpdateOperationsInput | string | null
    proceduredate?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type proceduretransactionsUncheckedUpdateWithoutInsurersInput = {
    id?: IntFieldUpdateOperationsInput | number
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    icd9?: NullableStringFieldUpdateOperationsInput | string | null
    procedurename?: NullableStringFieldUpdateOperationsInput | string | null
    proceduredate?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type proceduretransactionsUncheckedUpdateManyWithoutInsurersInput = {
    id?: IntFieldUpdateOperationsInput | number
    refid?: NullableStringFieldUpdateOperationsInput | string | null
    transactionno?: NullableStringFieldUpdateOperationsInput | string | null
    hn?: NullableStringFieldUpdateOperationsInput | string | null
    vn?: NullableStringFieldUpdateOperationsInput | string | null
    icd9?: NullableStringFieldUpdateOperationsInput | string | null
    procedurename?: NullableStringFieldUpdateOperationsInput | string | null
    proceduredate?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicesettingUpdateWithoutInsurersInput = {
    servicesettingcode?: StringFieldUpdateOperationsInput | string
    servicesettingdesc?: StringFieldUpdateOperationsInput | string
  }

  export type servicesettingUncheckedUpdateWithoutInsurersInput = {
    id?: IntFieldUpdateOperationsInput | number
    servicesettingcode?: StringFieldUpdateOperationsInput | string
    servicesettingdesc?: StringFieldUpdateOperationsInput | string
  }

  export type servicesettingUncheckedUpdateManyWithoutInsurersInput = {
    id?: IntFieldUpdateOperationsInput | number
    servicesettingcode?: StringFieldUpdateOperationsInput | string
    servicesettingdesc?: StringFieldUpdateOperationsInput | string
  }

  export type causeofinjurydetailCreateManyAccidenttransactionsInput = {
    id?: number
    causeofinjury?: string | null
    commentofinjury?: string | null
  }

  export type injurydetailCreateManyAccidenttransactionsInput = {
    id?: number
    woundtype?: string | null
    injuryside?: string | null
    injuryarea?: string | null
  }

  export type causeofinjurydetailUpdateWithoutAccidenttransactionsInput = {
    causeofinjury?: NullableStringFieldUpdateOperationsInput | string | null
    commentofinjury?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type causeofinjurydetailUncheckedUpdateWithoutAccidenttransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    causeofinjury?: NullableStringFieldUpdateOperationsInput | string | null
    commentofinjury?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type causeofinjurydetailUncheckedUpdateManyWithoutAccidenttransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    causeofinjury?: NullableStringFieldUpdateOperationsInput | string | null
    commentofinjury?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type injurydetailUpdateWithoutAccidenttransactionsInput = {
    woundtype?: NullableStringFieldUpdateOperationsInput | string | null
    injuryside?: NullableStringFieldUpdateOperationsInput | string | null
    injuryarea?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type injurydetailUncheckedUpdateWithoutAccidenttransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    woundtype?: NullableStringFieldUpdateOperationsInput | string | null
    injuryside?: NullableStringFieldUpdateOperationsInput | string | null
    injuryarea?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type injurydetailUncheckedUpdateManyWithoutAccidenttransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    woundtype?: NullableStringFieldUpdateOperationsInput | string | null
    injuryside?: NullableStringFieldUpdateOperationsInput | string | null
    injuryarea?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use ClaimstatusCountOutputTypeDefaultArgs instead
     */
    export type ClaimstatusCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClaimstatusCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InsurersCountOutputTypeDefaultArgs instead
     */
    export type InsurersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InsurersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccidenttransactionsCountOutputTypeDefaultArgs instead
     */
    export type AccidenttransactionsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccidenttransactionsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use accidentcauseover45daysDefaultArgs instead
     */
    export type accidentcauseover45daysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = accidentcauseover45daysDefaultArgs<ExtArgs>
    /**
     * @deprecated Use accidentplaceDefaultArgs instead
     */
    export type accidentplaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = accidentplaceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use causeofinjurysideDefaultArgs instead
     */
    export type causeofinjurysideArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = causeofinjurysideDefaultArgs<ExtArgs>
    /**
     * @deprecated Use causeofinjurywoundtypeDefaultArgs instead
     */
    export type causeofinjurywoundtypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = causeofinjurywoundtypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use claimantsDefaultArgs instead
     */
    export type claimantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = claimantsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use claimdocumentsDefaultArgs instead
     */
    export type claimdocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = claimdocumentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use claimstatusDefaultArgs instead
     */
    export type claimstatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = claimstatusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use diagnosistypemappingDefaultArgs instead
     */
    export type diagnosistypemappingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = diagnosistypemappingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use documenttypeDefaultArgs instead
     */
    export type documenttypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = documenttypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use illnesssurgeryDefaultArgs instead
     */
    export type illnesssurgeryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = illnesssurgeryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use illnesstypeDefaultArgs instead
     */
    export type illnesstypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = illnesstypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use insurersDefaultArgs instead
     */
    export type insurersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = insurersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use medicaltransactionsDefaultArgs instead
     */
    export type medicaltransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = medicaltransactionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use policytypeDefaultArgs instead
     */
    export type policytypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = policytypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use servicesettingDefaultArgs instead
     */
    export type servicesettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = servicesettingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use transactionclaimDefaultArgs instead
     */
    export type transactionclaimArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = transactionclaimDefaultArgs<ExtArgs>
    /**
     * @deprecated Use transactionclaimstatusDefaultArgs instead
     */
    export type transactionclaimstatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = transactionclaimstatusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use accidenttransactionsDefaultArgs instead
     */
    export type accidenttransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = accidenttransactionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use proceduretransactionsDefaultArgs instead
     */
    export type proceduretransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = proceduretransactionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use accidenttransactions22DefaultArgs instead
     */
    export type accidenttransactions22Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = accidenttransactions22DefaultArgs<ExtArgs>
    /**
     * @deprecated Use causeofinjurydetailDefaultArgs instead
     */
    export type causeofinjurydetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = causeofinjurydetailDefaultArgs<ExtArgs>
    /**
     * @deprecated Use injurydetailDefaultArgs instead
     */
    export type injurydetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = injurydetailDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}